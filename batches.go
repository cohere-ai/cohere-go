// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/cohere-ai/cohere-go/v2/internal"
	big "math/big"
	time "time"
)

var (
	batchesListBatchesRequestFieldPageSize  = big.NewInt(1 << 0)
	batchesListBatchesRequestFieldPageToken = big.NewInt(1 << 1)
	batchesListBatchesRequestFieldOrderBy   = big.NewInt(1 << 2)
)

type BatchesListBatchesRequest struct {
	// The maximum number of batches to return. The service may return fewer than
	// this value.
	// If unspecified, at most 50 batches will be returned.
	// The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// A page token, received from a previous `ListBatches` call.
	// Provide this to retrieve the subsequent page.
	PageToken *string `json:"-" url:"page_token,omitempty"`
	// Batches can be ordered by creation time or last updated time.
	// Use `created_at` for creation time or `updated_at` for last updated time.
	OrderBy *string `json:"-" url:"order_by,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BatchesListBatchesRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetPageSize sets the PageSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BatchesListBatchesRequest) SetPageSize(pageSize *int) {
	b.PageSize = pageSize
	b.require(batchesListBatchesRequestFieldPageSize)
}

// SetPageToken sets the PageToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BatchesListBatchesRequest) SetPageToken(pageToken *string) {
	b.PageToken = pageToken
	b.require(batchesListBatchesRequestFieldPageToken)
}

// SetOrderBy sets the OrderBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BatchesListBatchesRequest) SetOrderBy(orderBy *string) {
	b.OrderBy = orderBy
	b.require(batchesListBatchesRequestFieldOrderBy)
}

// This resource represents a batch job.
var (
	batchFieldId                   = big.NewInt(1 << 0)
	batchFieldName                 = big.NewInt(1 << 1)
	batchFieldCreatorId            = big.NewInt(1 << 2)
	batchFieldOrgId                = big.NewInt(1 << 3)
	batchFieldStatus               = big.NewInt(1 << 4)
	batchFieldCreatedAt            = big.NewInt(1 << 5)
	batchFieldUpdatedAt            = big.NewInt(1 << 6)
	batchFieldInputDatasetId       = big.NewInt(1 << 7)
	batchFieldOutputDatasetId      = big.NewInt(1 << 8)
	batchFieldInputTokens          = big.NewInt(1 << 9)
	batchFieldOutputTokens         = big.NewInt(1 << 10)
	batchFieldModel                = big.NewInt(1 << 11)
	batchFieldNumRecords           = big.NewInt(1 << 12)
	batchFieldNumSuccessfulRecords = big.NewInt(1 << 13)
	batchFieldNumFailedRecords     = big.NewInt(1 << 14)
	batchFieldStatusReason         = big.NewInt(1 << 15)
)

type Batch struct {
	// read-only. Batch ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Batch name (e.g. `foobar`).
	Name string `json:"name" url:"name"`
	// read-only. User ID of the creator.
	CreatorId *string `json:"creator_id,omitempty" url:"creator_id,omitempty"`
	// read-only. Organization ID.
	OrgId *string `json:"org_id,omitempty" url:"org_id,omitempty"`
	// read-only. Current stage in the life-cycle of the batch.
	Status *BatchStatus `json:"status,omitempty" url:"status,omitempty"`
	// read-only. Creation timestamp.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// read-only. Latest update timestamp.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// ID of the dataset the batch reads inputs from.
	InputDatasetId  string  `json:"input_dataset_id" url:"input_dataset_id"`
	OutputDatasetId *string `json:"output_dataset_id,omitempty" url:"output_dataset_id,omitempty"`
	// read-only. The total number of input tokens in the batch.
	InputTokens *string `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// read-only. The total number of output tokens in the batch.
	OutputTokens *string `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`
	// The name of the model the batch uses.
	Model string `json:"model" url:"model"`
	// read-only. The total number of records in the batch.
	NumRecords *int `json:"num_records,omitempty" url:"num_records,omitempty"`
	// read-only. The current number of successful records in the batch.
	NumSuccessfulRecords *int `json:"num_successful_records,omitempty" url:"num_successful_records,omitempty"`
	// read-only. The current number of failed records in the batch.
	NumFailedRecords *int `json:"num_failed_records,omitempty" url:"num_failed_records,omitempty"`
	// read-only. More details about the reason for the status of a batch job.
	StatusReason *string `json:"status_reason,omitempty" url:"status_reason,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Batch) GetId() *string {
	if b == nil {
		return nil
	}
	return b.Id
}

func (b *Batch) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *Batch) GetCreatorId() *string {
	if b == nil {
		return nil
	}
	return b.CreatorId
}

func (b *Batch) GetOrgId() *string {
	if b == nil {
		return nil
	}
	return b.OrgId
}

func (b *Batch) GetStatus() *BatchStatus {
	if b == nil {
		return nil
	}
	return b.Status
}

func (b *Batch) GetCreatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *Batch) GetUpdatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.UpdatedAt
}

func (b *Batch) GetInputDatasetId() string {
	if b == nil {
		return ""
	}
	return b.InputDatasetId
}

func (b *Batch) GetOutputDatasetId() *string {
	if b == nil {
		return nil
	}
	return b.OutputDatasetId
}

func (b *Batch) GetInputTokens() *string {
	if b == nil {
		return nil
	}
	return b.InputTokens
}

func (b *Batch) GetOutputTokens() *string {
	if b == nil {
		return nil
	}
	return b.OutputTokens
}

func (b *Batch) GetModel() string {
	if b == nil {
		return ""
	}
	return b.Model
}

func (b *Batch) GetNumRecords() *int {
	if b == nil {
		return nil
	}
	return b.NumRecords
}

func (b *Batch) GetNumSuccessfulRecords() *int {
	if b == nil {
		return nil
	}
	return b.NumSuccessfulRecords
}

func (b *Batch) GetNumFailedRecords() *int {
	if b == nil {
		return nil
	}
	return b.NumFailedRecords
}

func (b *Batch) GetStatusReason() *string {
	if b == nil {
		return nil
	}
	return b.StatusReason
}

func (b *Batch) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Batch) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetId(id *string) {
	b.Id = id
	b.require(batchFieldId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetName(name string) {
	b.Name = name
	b.require(batchFieldName)
}

// SetCreatorId sets the CreatorId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetCreatorId(creatorId *string) {
	b.CreatorId = creatorId
	b.require(batchFieldCreatorId)
}

// SetOrgId sets the OrgId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetOrgId(orgId *string) {
	b.OrgId = orgId
	b.require(batchFieldOrgId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetStatus(status *BatchStatus) {
	b.Status = status
	b.require(batchFieldStatus)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetCreatedAt(createdAt *time.Time) {
	b.CreatedAt = createdAt
	b.require(batchFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetUpdatedAt(updatedAt *time.Time) {
	b.UpdatedAt = updatedAt
	b.require(batchFieldUpdatedAt)
}

// SetInputDatasetId sets the InputDatasetId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetInputDatasetId(inputDatasetId string) {
	b.InputDatasetId = inputDatasetId
	b.require(batchFieldInputDatasetId)
}

// SetOutputDatasetId sets the OutputDatasetId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetOutputDatasetId(outputDatasetId *string) {
	b.OutputDatasetId = outputDatasetId
	b.require(batchFieldOutputDatasetId)
}

// SetInputTokens sets the InputTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetInputTokens(inputTokens *string) {
	b.InputTokens = inputTokens
	b.require(batchFieldInputTokens)
}

// SetOutputTokens sets the OutputTokens field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetOutputTokens(outputTokens *string) {
	b.OutputTokens = outputTokens
	b.require(batchFieldOutputTokens)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetModel(model string) {
	b.Model = model
	b.require(batchFieldModel)
}

// SetNumRecords sets the NumRecords field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetNumRecords(numRecords *int) {
	b.NumRecords = numRecords
	b.require(batchFieldNumRecords)
}

// SetNumSuccessfulRecords sets the NumSuccessfulRecords field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetNumSuccessfulRecords(numSuccessfulRecords *int) {
	b.NumSuccessfulRecords = numSuccessfulRecords
	b.require(batchFieldNumSuccessfulRecords)
}

// SetNumFailedRecords sets the NumFailedRecords field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetNumFailedRecords(numFailedRecords *int) {
	b.NumFailedRecords = numFailedRecords
	b.require(batchFieldNumFailedRecords)
}

// SetStatusReason sets the StatusReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetStatusReason(statusReason *string) {
	b.StatusReason = statusReason
	b.require(batchFieldStatusReason)
}

func (b *Batch) UnmarshalJSON(data []byte) error {
	type embed Batch
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Batch(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Batch) MarshalJSON() ([]byte, error) {
	type embed Batch
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewOptionalDateTime(b.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(b.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *Batch) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The possible stages of a batch life-cycle.
//
//   - BATCH_STATUS_UNSPECIFIED: Unspecified status.
//   - BATCH_STATUS_QUEUED: The batch has been queued.
//   - BATCH_STATUS_IN_PROGRESS: The batch is in-progress.
//   - BATCH_STATUS_CANCELING: The batch is being canceled.
//   - BATCH_STATUS_COMPLETED: The batch has been completed.
//   - BATCH_STATUS_FAILED: The batch has failed.
//   - BATCH_STATUS_CANCELED: The batch has been canceled.
type BatchStatus string

const (
	BatchStatusBatchStatusUnspecified BatchStatus = "BATCH_STATUS_UNSPECIFIED"
	BatchStatusBatchStatusQueued      BatchStatus = "BATCH_STATUS_QUEUED"
	BatchStatusBatchStatusInProgress  BatchStatus = "BATCH_STATUS_IN_PROGRESS"
	BatchStatusBatchStatusCanceling   BatchStatus = "BATCH_STATUS_CANCELING"
	BatchStatusBatchStatusCompleted   BatchStatus = "BATCH_STATUS_COMPLETED"
	BatchStatusBatchStatusFailed      BatchStatus = "BATCH_STATUS_FAILED"
	BatchStatusBatchStatusCanceled    BatchStatus = "BATCH_STATUS_CANCELED"
)

func NewBatchStatusFromString(s string) (BatchStatus, error) {
	switch s {
	case "BATCH_STATUS_UNSPECIFIED":
		return BatchStatusBatchStatusUnspecified, nil
	case "BATCH_STATUS_QUEUED":
		return BatchStatusBatchStatusQueued, nil
	case "BATCH_STATUS_IN_PROGRESS":
		return BatchStatusBatchStatusInProgress, nil
	case "BATCH_STATUS_CANCELING":
		return BatchStatusBatchStatusCanceling, nil
	case "BATCH_STATUS_COMPLETED":
		return BatchStatusBatchStatusCompleted, nil
	case "BATCH_STATUS_FAILED":
		return BatchStatusBatchStatusFailed, nil
	case "BATCH_STATUS_CANCELED":
		return BatchStatusBatchStatusCanceled, nil
	}
	var t BatchStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BatchStatus) Ptr() *BatchStatus {
	return &b
}

// Response to a request to cancel a batch.
type CancelBatchResponse = map[string]interface{}

// Response to request to create a batch.
var (
	createBatchResponseFieldBatch = big.NewInt(1 << 0)
)

type CreateBatchResponse struct {
	// Information about the batch.
	Batch *Batch `json:"batch" url:"batch"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateBatchResponse) GetBatch() *Batch {
	if c == nil {
		return nil
	}
	return c.Batch
}

func (c *CreateBatchResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBatchResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetBatch sets the Batch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateBatchResponse) SetBatch(batch *Batch) {
	c.Batch = batch
	c.require(createBatchResponseFieldBatch)
}

func (c *CreateBatchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBatchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBatchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBatchResponse) MarshalJSON() ([]byte, error) {
	type embed CreateBatchResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateBatchResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response to a request to get a batch.
var (
	getBatchResponseFieldBatch = big.NewInt(1 << 0)
)

type GetBatchResponse struct {
	// Information about the batch.
	Batch *Batch `json:"batch" url:"batch"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetBatchResponse) GetBatch() *Batch {
	if g == nil {
		return nil
	}
	return g.Batch
}

func (g *GetBatchResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBatchResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetBatch sets the Batch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetBatchResponse) SetBatch(batch *Batch) {
	g.Batch = batch
	g.require(getBatchResponseFieldBatch)
}

func (g *GetBatchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBatchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBatchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBatchResponse) MarshalJSON() ([]byte, error) {
	type embed GetBatchResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GetBatchResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Response to a request to list batches.
var (
	listBatchesResponseFieldBatches       = big.NewInt(1 << 0)
	listBatchesResponseFieldNextPageToken = big.NewInt(1 << 1)
)

type ListBatchesResponse struct {
	// The batches that belong to the authenticated user.
	Batches []*Batch `json:"batches,omitempty" url:"batches,omitempty"`
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"next_page_token,omitempty" url:"next_page_token,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListBatchesResponse) GetBatches() []*Batch {
	if l == nil {
		return nil
	}
	return l.Batches
}

func (l *ListBatchesResponse) GetNextPageToken() *string {
	if l == nil {
		return nil
	}
	return l.NextPageToken
}

func (l *ListBatchesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBatchesResponse) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetBatches sets the Batches field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListBatchesResponse) SetBatches(batches []*Batch) {
	l.Batches = batches
	l.require(listBatchesResponseFieldBatches)
}

// SetNextPageToken sets the NextPageToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListBatchesResponse) SetNextPageToken(nextPageToken *string) {
	l.NextPageToken = nextPageToken
	l.require(listBatchesResponseFieldNextPageToken)
}

func (l *ListBatchesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBatchesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBatchesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBatchesResponse) MarshalJSON() ([]byte, error) {
	type embed ListBatchesResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *ListBatchesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}
