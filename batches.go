// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/cohere-ai/cohere-go/v2/internal"
	time "time"
)

type BatchesListBatchesRequest struct {
	// The maximum number of batches to return. The service may return fewer than
	// this value.
	// If unspecified, at most 50 batches will be returned.
	// The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// A page token, received from a previous `ListBatches` call.
	// Provide this to retrieve the subsequent page.
	PageToken *string `json:"-" url:"page_token,omitempty"`
	// Batches can be ordered by creation time or last updated time.
	// Use `created_at` for creation time or `updated_at` for last updated time.
	OrderBy *string `json:"-" url:"order_by,omitempty"`
}

// This resource represents a batch job.
type Batch struct {
	// read-only. Batch ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Batch name (e.g. `foobar`).
	Name string `json:"name" url:"name"`
	// read-only. User ID of the creator.
	CreatorId *string `json:"creator_id,omitempty" url:"creator_id,omitempty"`
	// read-only. Organization ID.
	OrgId *string `json:"org_id,omitempty" url:"org_id,omitempty"`
	// read-only. Current stage in the life-cycle of the batch.
	Status *BatchStatus `json:"status,omitempty" url:"status,omitempty"`
	// read-only. Creation timestamp.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// read-only. Latest update timestamp.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// ID of the dataset the batch reads inputs from.
	InputDatasetId  string  `json:"input_dataset_id" url:"input_dataset_id"`
	OutputDatasetId *string `json:"output_dataset_id,omitempty" url:"output_dataset_id,omitempty"`
	// read-only. The total number of input tokens in the batch.
	InputTokens *string `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// read-only. The total number of output tokens in the batch.
	OutputTokens *string `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`
	// The name of the model the batch uses.
	Model string `json:"model" url:"model"`
	// read-only. The total number of records in the batch.
	NumRecords *int `json:"num_records,omitempty" url:"num_records,omitempty"`
	// read-only. The current number of successful records in the batch.
	NumSuccessfulRecords *int `json:"num_successful_records,omitempty" url:"num_successful_records,omitempty"`
	// read-only. The current number of failed records in the batch.
	NumFailedRecords *int `json:"num_failed_records,omitempty" url:"num_failed_records,omitempty"`
	// read-only. More details about the reason for the status of a batch job.
	StatusReason *string `json:"status_reason,omitempty" url:"status_reason,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Batch) GetId() *string {
	if b == nil {
		return nil
	}
	return b.Id
}

func (b *Batch) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *Batch) GetCreatorId() *string {
	if b == nil {
		return nil
	}
	return b.CreatorId
}

func (b *Batch) GetOrgId() *string {
	if b == nil {
		return nil
	}
	return b.OrgId
}

func (b *Batch) GetStatus() *BatchStatus {
	if b == nil {
		return nil
	}
	return b.Status
}

func (b *Batch) GetCreatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *Batch) GetUpdatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.UpdatedAt
}

func (b *Batch) GetInputDatasetId() string {
	if b == nil {
		return ""
	}
	return b.InputDatasetId
}

func (b *Batch) GetOutputDatasetId() *string {
	if b == nil {
		return nil
	}
	return b.OutputDatasetId
}

func (b *Batch) GetInputTokens() *string {
	if b == nil {
		return nil
	}
	return b.InputTokens
}

func (b *Batch) GetOutputTokens() *string {
	if b == nil {
		return nil
	}
	return b.OutputTokens
}

func (b *Batch) GetModel() string {
	if b == nil {
		return ""
	}
	return b.Model
}

func (b *Batch) GetNumRecords() *int {
	if b == nil {
		return nil
	}
	return b.NumRecords
}

func (b *Batch) GetNumSuccessfulRecords() *int {
	if b == nil {
		return nil
	}
	return b.NumSuccessfulRecords
}

func (b *Batch) GetNumFailedRecords() *int {
	if b == nil {
		return nil
	}
	return b.NumFailedRecords
}

func (b *Batch) GetStatusReason() *string {
	if b == nil {
		return nil
	}
	return b.StatusReason
}

func (b *Batch) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Batch) UnmarshalJSON(data []byte) error {
	type embed Batch
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Batch(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Batch) MarshalJSON() ([]byte, error) {
	type embed Batch
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewOptionalDateTime(b.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *Batch) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The possible stages of a batch life-cycle.
//
//   - BATCH_STATUS_UNSPECIFIED: Unspecified status.
//   - BATCH_STATUS_QUEUED: The batch has been queued.
//   - BATCH_STATUS_IN_PROGRESS: The batch is in-progress.
//   - BATCH_STATUS_CANCELING: The batch is being canceled.
//   - BATCH_STATUS_COMPLETED: The batch has been completed.
//   - BATCH_STATUS_FAILED: The batch has failed.
//   - BATCH_STATUS_CANCELED: The batch has been canceled.
type BatchStatus string

const (
	BatchStatusBatchStatusUnspecified BatchStatus = "BATCH_STATUS_UNSPECIFIED"
	BatchStatusBatchStatusQueued      BatchStatus = "BATCH_STATUS_QUEUED"
	BatchStatusBatchStatusInProgress  BatchStatus = "BATCH_STATUS_IN_PROGRESS"
	BatchStatusBatchStatusCanceling   BatchStatus = "BATCH_STATUS_CANCELING"
	BatchStatusBatchStatusCompleted   BatchStatus = "BATCH_STATUS_COMPLETED"
	BatchStatusBatchStatusFailed      BatchStatus = "BATCH_STATUS_FAILED"
	BatchStatusBatchStatusCanceled    BatchStatus = "BATCH_STATUS_CANCELED"
)

func NewBatchStatusFromString(s string) (BatchStatus, error) {
	switch s {
	case "BATCH_STATUS_UNSPECIFIED":
		return BatchStatusBatchStatusUnspecified, nil
	case "BATCH_STATUS_QUEUED":
		return BatchStatusBatchStatusQueued, nil
	case "BATCH_STATUS_IN_PROGRESS":
		return BatchStatusBatchStatusInProgress, nil
	case "BATCH_STATUS_CANCELING":
		return BatchStatusBatchStatusCanceling, nil
	case "BATCH_STATUS_COMPLETED":
		return BatchStatusBatchStatusCompleted, nil
	case "BATCH_STATUS_FAILED":
		return BatchStatusBatchStatusFailed, nil
	case "BATCH_STATUS_CANCELED":
		return BatchStatusBatchStatusCanceled, nil
	}
	var t BatchStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BatchStatus) Ptr() *BatchStatus {
	return &b
}

// Response to a request to cancel a batch.
type CancelBatchResponse = map[string]interface{}

// Response to request to create a batch.
type CreateBatchResponse struct {
	// Information about the batch.
	Batch *Batch `json:"batch" url:"batch"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateBatchResponse) GetBatch() *Batch {
	if c == nil {
		return nil
	}
	return c.Batch
}

func (c *CreateBatchResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBatchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBatchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBatchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBatchResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response to a request to get a batch.
type GetBatchResponse struct {
	// Information about the batch.
	Batch *Batch `json:"batch" url:"batch"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetBatchResponse) GetBatch() *Batch {
	if g == nil {
		return nil
	}
	return g.Batch
}

func (g *GetBatchResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBatchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBatchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBatchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBatchResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Response to a request to list batches.
type ListBatchesResponse struct {
	// The batches that belong to the authenticated user.
	Batches []*Batch `json:"batches,omitempty" url:"batches,omitempty"`
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"next_page_token,omitempty" url:"next_page_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListBatchesResponse) GetBatches() []*Batch {
	if l == nil {
		return nil
	}
	return l.Batches
}

func (l *ListBatchesResponse) GetNextPageToken() *string {
	if l == nil {
		return nil
	}
	return l.NextPageToken
}

func (l *ListBatchesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBatchesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBatchesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBatchesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBatchesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}
