// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/cohere-ai/cohere-go/v2/core"
)

type CreateRequest struct {
	// A human-readable name for the connector.
	Name string `json:"name"`
	// A description of the connector.
	Description *string `json:"description,omitempty"`
	// The URL of the connector that will be used to search for documents.
	Url string `json:"url"`
	// A list of fields to exclude from the prompt (fields remain in the document).
	Excludes []string `json:"excludes,omitempty"`
	// The OAuth 2.0 configuration for the connector. Cannot be specified if service_auth is specified.
	Oauth *CreateConnectorOAuth `json:"oauth,omitempty"`
	// Whether the connector is active or not.
	Active *bool `json:"active,omitempty"`
	// Whether a chat request should continue or not if the request to this connector fails.
	ContinueOnFailure *bool `json:"continue_on_failure,omitempty"`
	// The service to service authentication configuration for the connector. Cannot be specified if oauth is specified.
	ServiceAuth *CreateConnectorServiceAuth `json:"service_auth,omitempty"`
}

type ConnectorsListRequest struct {
	// Maximum number of connectors to return [0, 100].
	Limit *float64 `json:"-"`
	// Number of connectors to skip before returning results [0, inf].
	Offset *float64 `json:"-"`
}

type CreateConnectorOAuth struct {
	// The OAuth 2.0 client ID. This fields is encrypted at rest.
	ClientId string `json:"clientId"`
	// The OAuth 2.0 client Secret. This field is encrypted at rest and never returned in a response.
	ClientSecret string `json:"clientSecret"`
	// The OAuth 2.0 /authorize endpoint to use when users authorize the connector.
	AuthorizeUrl string `json:"authorizeUrl"`
	// The OAuth 2.0 /token endpoint to use when users authorize the connector.
	TokenUrl string `json:"tokenUrl"`
	// The OAuth scopes to request when users authorize the connector.
	Scope *string `json:"scope,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectorOAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorOAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorOAuth(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorOAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorServiceAuth struct {
	// The token_type specifies the way the token is passed in the Authorization header. Valid values are "bearer", "basic", and "noscheme".
	Type string `json:"type"`
	// The token that will be used in the HTTP Authorization header when making requests to the connector. This field is encrypted at rest and never returned in a response.
	Token string `json:"token"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectorServiceAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorServiceAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorServiceAuth(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorServiceAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateResponse struct {
	Connector *Connector `json:"connector,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DeleteResponse = map[string]interface{}

type GetResponse struct {
	Connector *Connector `json:"connector,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListResponse struct {
	Connectors []*Connector `json:"connectors,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type OAuthAuthorizeResponse struct {
	// The OAuth 2.0 redirect url. Redirect the user to this url to authorize the connector.
	RedirectUrl *string `json:"redirect_url,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OAuthAuthorizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthAuthorizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthAuthorizeResponse(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuthAuthorizeResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type UpdateResponse struct {
	Connector *Connector `json:"connector,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateRequest struct {
	// A human-readable name for the connector.
	Name *string `json:"name,omitempty"`
	// The URL of the connector that will be used to search for documents.
	Url *string `json:"url,omitempty"`
	// A list of fields to exclude from the prompt (fields remain in the document).
	Excludes []string `json:"excludes,omitempty"`
	// The OAuth 2.0 configuration for the connector. Cannot be specified if service_auth is specified.
	Oauth             *CreateConnectorOAuth `json:"oauth,omitempty"`
	Active            *bool                 `json:"active,omitempty"`
	ContinueOnFailure *bool                 `json:"continue_on_failure,omitempty"`
	// The service to service authentication configuration for the connector. Cannot be specified if oauth is specified.
	ServiceAuth *CreateConnectorServiceAuth `json:"service_auth,omitempty"`
}
