// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/cohere-ai/cohere-go/v2/internal"
)

type ModelsListRequest struct {
	// Maximum number of models to include in a page
	// Defaults to `20`, min value of `1`, max value of `1000`.
	PageSize *float64 `json:"-" url:"page_size,omitempty"`
	// Page token provided in the `next_page_token` field of a previous response.
	PageToken *string `json:"-" url:"page_token,omitempty"`
	// When provided, filters the list of models to only those that are compatible with the specified endpoint.
	Endpoint *CompatibleEndpoint `json:"-" url:"endpoint,omitempty"`
	// When provided, filters the list of models to only the default model to the endpoint. This parameter is only valid when `endpoint` is provided.
	DefaultOnly *bool `json:"-" url:"default_only,omitempty"`
}

// One of the Cohere API endpoints that the model can be used with.
type CompatibleEndpoint string

const (
	CompatibleEndpointChat      CompatibleEndpoint = "chat"
	CompatibleEndpointEmbed     CompatibleEndpoint = "embed"
	CompatibleEndpointClassify  CompatibleEndpoint = "classify"
	CompatibleEndpointSummarize CompatibleEndpoint = "summarize"
	CompatibleEndpointRerank    CompatibleEndpoint = "rerank"
	CompatibleEndpointRate      CompatibleEndpoint = "rate"
	CompatibleEndpointGenerate  CompatibleEndpoint = "generate"
)

func NewCompatibleEndpointFromString(s string) (CompatibleEndpoint, error) {
	switch s {
	case "chat":
		return CompatibleEndpointChat, nil
	case "embed":
		return CompatibleEndpointEmbed, nil
	case "classify":
		return CompatibleEndpointClassify, nil
	case "summarize":
		return CompatibleEndpointSummarize, nil
	case "rerank":
		return CompatibleEndpointRerank, nil
	case "rate":
		return CompatibleEndpointRate, nil
	case "generate":
		return CompatibleEndpointGenerate, nil
	}
	var t CompatibleEndpoint
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CompatibleEndpoint) Ptr() *CompatibleEndpoint {
	return &c
}

// Contains information about the model and which API endpoints it can be used with.
type GetModelResponse struct {
	// Specify this name in the `model` parameter of API requests to use your chosen model.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The API endpoints that the model is compatible with.
	Endpoints []CompatibleEndpoint `json:"endpoints,omitempty" url:"endpoints,omitempty"`
	// Whether the model has been fine-tuned or not.
	Finetuned *bool `json:"finetuned,omitempty" url:"finetuned,omitempty"`
	// The maximum number of tokens that the model can process in a single request. Note that not all of these tokens are always available due to special tokens and preambles that Cohere has added by default.
	ContextLength *float64 `json:"context_length,omitempty" url:"context_length,omitempty"`
	// Public URL to the tokenizer's configuration file.
	TokenizerUrl *string `json:"tokenizer_url,omitempty" url:"tokenizer_url,omitempty"`
	// The API endpoints that the model is default to.
	DefaultEndpoints []CompatibleEndpoint `json:"default_endpoints,omitempty" url:"default_endpoints,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetModelResponse) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *GetModelResponse) GetEndpoints() []CompatibleEndpoint {
	if g == nil {
		return nil
	}
	return g.Endpoints
}

func (g *GetModelResponse) GetFinetuned() *bool {
	if g == nil {
		return nil
	}
	return g.Finetuned
}

func (g *GetModelResponse) GetContextLength() *float64 {
	if g == nil {
		return nil
	}
	return g.ContextLength
}

func (g *GetModelResponse) GetTokenizerUrl() *string {
	if g == nil {
		return nil
	}
	return g.TokenizerUrl
}

func (g *GetModelResponse) GetDefaultEndpoints() []CompatibleEndpoint {
	if g == nil {
		return nil
	}
	return g.DefaultEndpoints
}

func (g *GetModelResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetModelResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetModelResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetModelResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetModelResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListModelsResponse struct {
	Models []*GetModelResponse `json:"models,omitempty" url:"models,omitempty"`
	// A token to retrieve the next page of results. Provide in the page_token parameter of the next request.
	NextPageToken *string `json:"next_page_token,omitempty" url:"next_page_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListModelsResponse) GetModels() []*GetModelResponse {
	if l == nil {
		return nil
	}
	return l.Models
}

func (l *ListModelsResponse) GetNextPageToken() *string {
	if l == nil {
		return nil
	}
	return l.NextPageToken
}

func (l *ListModelsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListModelsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListModelsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListModelsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListModelsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}
