// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/cohere-ai/cohere-go/v2/core"
	time "time"
)

type ChatRequest struct {
	// Text input for the model to respond to.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Message string `json:"message" url:"-"`
	// Defaults to `command-r-plus`.
	//
	// The name of a compatible [Cohere model](https://docs.cohere.com/docs/models) or the ID of a [fine-tuned](https://docs.cohere.com/docs/chat-fine-tuning) model.
	// Compatible Deployments: Cohere Platform, Private Deployments
	Model *string `json:"model,omitempty" url:"-"`
	// Defaults to `false`.
	//
	// When `true`, the response will be a JSON stream of events. The final event will contain the complete response, and will have an `event_type` of `"stream-end"`.
	//
	// Streaming is beneficial for user interfaces that render the contents of the response piece by piece, as it gets generated.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	//
	// When specified, the default Cohere preamble will be replaced with the provided one. Preambles are a part of the prompt used to adjust the model's overall behavior and conversation style, and use the `SYSTEM` role.
	//
	// The `SYSTEM` role is also used for the contents of the optional `chat_history=` parameter. When used with the `chat_history=` parameter it adds content throughout a conversation. Conversely, when used with the `preamble=` parameter it adds content at the start of the conversation only.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Preamble *string `json:"preamble,omitempty" url:"-"`
	// A list of previous messages between the user and the model, giving the model conversational context for responding to the user's `message`.
	//
	// Each item represents a single message in the chat history, excluding the current user turn. It has two properties: `role` and `message`. The `role` identifies the sender (`CHATBOT`, `SYSTEM`, or `USER`), while the `message` contains the text content.
	//
	// The chat_history parameter should not be used for `SYSTEM` messages in most cases. Instead, to add a `SYSTEM` role message at the beginning of a conversation, the `preamble` parameter should be used.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	ChatHistory []*Message `json:"chat_history,omitempty" url:"-"`
	// An alternative to `chat_history`.
	//
	// Providing a `conversation_id` creates or resumes a persisted conversation with the specified ID. The ID can be any non empty string.
	// Compatible Deployments: Cohere Platform
	ConversationId *string `json:"conversation_id,omitempty" url:"-"`
	// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
	//
	// Dictates how the prompt will be constructed.
	//
	// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be changed and ranked by relevance.
	//
	// With `prompt_truncation` set to "AUTO_PRESERVE_ORDER", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be preserved as they are inputted into the API.
	//
	// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
	// Compatible Deployments: Cohere Platform Only AUTO_PRESERVE_ORDER: Azure, AWS Sagemaker, Private Deployments
	PromptTruncation *ChatRequestPromptTruncation `json:"prompt_truncation,omitempty" url:"-"`
	// Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.
	//
	// When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).
	// Compatible Deployments: Cohere Platform
	Connectors []*ChatConnector `json:"connectors,omitempty" url:"-"`
	// Defaults to `false`.
	//
	// When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	SearchQueriesOnly *bool `json:"search_queries_only,omitempty" url:"-"`
	// A list of relevant documents that the model can cite to generate a more accurate reply. Each document is a string-string dictionary.
	//
	// Example:
	// `[
	//
	//	{ "title": "Tall penguins", "text": "Emperor penguins are the tallest." },
	//	{ "title": "Penguin habitats", "text": "Emperor penguins only live in Antarctica." },
	//
	// ]`
	//
	// Keys and values from each document will be serialized to a string and passed to the model. The resulting generation will include citations that reference some of these documents.
	//
	// Some suggested keys are "text", "author", and "date". For better generation quality, it is recommended to keep the total word count of the strings in the dictionary to under 300 words.
	//
	// An `id` field (string) can be optionally supplied to identify the document in the citations. This field will not be passed to the model.
	//
	// An `_excludes` field (array of strings) can be optionally supplied to omit some key-value pairs from being shown to the model. The omitted fields will still show up in the citation object. The "_excludes" field will not be passed to the model.
	//
	// See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Documents []ChatDocument `json:"documents,omitempty" url:"-"`
	// Defaults to `"accurate"`.
	//
	// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	CitationQuality *ChatRequestCitationQuality `json:"citation_quality,omitempty" url:"-"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Temperature *float64 `json:"temperature,omitempty" url:"-"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// The maximum number of input tokens to send to the model. If not specified, `max_input_tokens` is the model's context length limit minus a small buffer.
	//
	// Input will be truncated according to the `prompt_truncation` parameter.
	// Compatible Deployments: Cohere Platform
	MaxInputTokens *int `json:"max_input_tokens,omitempty" url:"-"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	K *int `json:"k,omitempty" url:"-"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	P *float64 `json:"p,omitempty" url:"-"`
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Seed *int `json:"seed,omitempty" url:"-"`
	// A list of up to 5 strings that the model will use to stop generation. If the model generates a string that matches any of the strings in the list, it will stop generating tokens and return the generated text up to that point not including the stop sequence.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	StopSequences []string `json:"stop_sequences,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"-"`
	// When enabled, the user's prompt will be sent to the model without
	// any pre-processing.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"-"`
	// The prompt is returned in the `prompt` response field when this is enabled.
	ReturnPrompt *bool `json:"return_prompt,omitempty" url:"-"`
	// A list of available tools (functions) that the model may suggest invoking before producing a text response.
	//
	// When `tools` is passed (without `tool_results`), the `text` field in the response will be `""` and the `tool_calls` field in the response will be populated with a list of tool calls that need to be made. If no calls need to be made, the `tool_calls` array will be empty.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Tools []*Tool `json:"tools,omitempty" url:"-"`
	// A list of results from invoking tools recommended by the model in the previous chat turn. Results are used to produce a text response and will be referenced in citations. When using `tool_results`, `tools` must be passed as well.
	// Each tool_result contains information about how it was invoked, as well as a list of outputs in the form of dictionaries.
	//
	// **Note**: `outputs` must be a list of objects. If your tool returns a single object (eg `{"status": 200}`), make sure to wrap it in a list.
	// ```
	// tool_results = [
	//
	//	{
	//	  "call": {
	//	    "name": <tool name>,
	//	    "parameters": {
	//	      <param name>: <param value>
	//	    }
	//	  },
	//	  "outputs": [{
	//	    <key>: <value>
	//	  }]
	//	},
	//	...
	//
	// ]
	// ```
	// **Note**: Chat calls with `tool_results` should not be included in the Chat history to avoid duplication of the message text.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	ToolResults []*ToolResult `json:"tool_results,omitempty" url:"-"`
	// Forces the chat to be single step. Defaults to `false`.
	ForceSingleStep *bool `json:"force_single_step,omitempty" url:"-"`
	stream          bool
}

func (c *ChatRequest) Stream() bool {
	return c.stream
}

func (c *ChatRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = ChatRequest(body)
	c.stream = false
	return nil
}

func (c *ChatRequest) MarshalJSON() ([]byte, error) {
	type embed ChatRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*c),
		Stream: false,
	}
	return json.Marshal(marshaler)
}

type ChatStreamRequest struct {
	// Text input for the model to respond to.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Message string `json:"message" url:"-"`
	// Defaults to `command-r-plus`.
	//
	// The name of a compatible [Cohere model](https://docs.cohere.com/docs/models) or the ID of a [fine-tuned](https://docs.cohere.com/docs/chat-fine-tuning) model.
	// Compatible Deployments: Cohere Platform, Private Deployments
	Model *string `json:"model,omitempty" url:"-"`
	// Defaults to `false`.
	//
	// When `true`, the response will be a JSON stream of events. The final event will contain the complete response, and will have an `event_type` of `"stream-end"`.
	//
	// Streaming is beneficial for user interfaces that render the contents of the response piece by piece, as it gets generated.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	//
	// When specified, the default Cohere preamble will be replaced with the provided one. Preambles are a part of the prompt used to adjust the model's overall behavior and conversation style, and use the `SYSTEM` role.
	//
	// The `SYSTEM` role is also used for the contents of the optional `chat_history=` parameter. When used with the `chat_history=` parameter it adds content throughout a conversation. Conversely, when used with the `preamble=` parameter it adds content at the start of the conversation only.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Preamble *string `json:"preamble,omitempty" url:"-"`
	// A list of previous messages between the user and the model, giving the model conversational context for responding to the user's `message`.
	//
	// Each item represents a single message in the chat history, excluding the current user turn. It has two properties: `role` and `message`. The `role` identifies the sender (`CHATBOT`, `SYSTEM`, or `USER`), while the `message` contains the text content.
	//
	// The chat_history parameter should not be used for `SYSTEM` messages in most cases. Instead, to add a `SYSTEM` role message at the beginning of a conversation, the `preamble` parameter should be used.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	ChatHistory []*Message `json:"chat_history,omitempty" url:"-"`
	// An alternative to `chat_history`.
	//
	// Providing a `conversation_id` creates or resumes a persisted conversation with the specified ID. The ID can be any non empty string.
	// Compatible Deployments: Cohere Platform
	ConversationId *string `json:"conversation_id,omitempty" url:"-"`
	// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
	//
	// Dictates how the prompt will be constructed.
	//
	// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be changed and ranked by relevance.
	//
	// With `prompt_truncation` set to "AUTO_PRESERVE_ORDER", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be preserved as they are inputted into the API.
	//
	// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
	// Compatible Deployments: Cohere Platform Only AUTO_PRESERVE_ORDER: Azure, AWS Sagemaker, Private Deployments
	PromptTruncation *ChatStreamRequestPromptTruncation `json:"prompt_truncation,omitempty" url:"-"`
	// Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.
	//
	// When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).
	// Compatible Deployments: Cohere Platform
	Connectors []*ChatConnector `json:"connectors,omitempty" url:"-"`
	// Defaults to `false`.
	//
	// When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	SearchQueriesOnly *bool `json:"search_queries_only,omitempty" url:"-"`
	// A list of relevant documents that the model can cite to generate a more accurate reply. Each document is a string-string dictionary.
	//
	// Example:
	// `[
	//
	//	{ "title": "Tall penguins", "text": "Emperor penguins are the tallest." },
	//	{ "title": "Penguin habitats", "text": "Emperor penguins only live in Antarctica." },
	//
	// ]`
	//
	// Keys and values from each document will be serialized to a string and passed to the model. The resulting generation will include citations that reference some of these documents.
	//
	// Some suggested keys are "text", "author", and "date". For better generation quality, it is recommended to keep the total word count of the strings in the dictionary to under 300 words.
	//
	// An `id` field (string) can be optionally supplied to identify the document in the citations. This field will not be passed to the model.
	//
	// An `_excludes` field (array of strings) can be optionally supplied to omit some key-value pairs from being shown to the model. The omitted fields will still show up in the citation object. The "_excludes" field will not be passed to the model.
	//
	// See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Documents []ChatDocument `json:"documents,omitempty" url:"-"`
	// Defaults to `"accurate"`.
	//
	// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	CitationQuality *ChatStreamRequestCitationQuality `json:"citation_quality,omitempty" url:"-"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Temperature *float64 `json:"temperature,omitempty" url:"-"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// The maximum number of input tokens to send to the model. If not specified, `max_input_tokens` is the model's context length limit minus a small buffer.
	//
	// Input will be truncated according to the `prompt_truncation` parameter.
	// Compatible Deployments: Cohere Platform
	MaxInputTokens *int `json:"max_input_tokens,omitempty" url:"-"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	K *int `json:"k,omitempty" url:"-"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	P *float64 `json:"p,omitempty" url:"-"`
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Seed *int `json:"seed,omitempty" url:"-"`
	// A list of up to 5 strings that the model will use to stop generation. If the model generates a string that matches any of the strings in the list, it will stop generating tokens and return the generated text up to that point not including the stop sequence.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	StopSequences []string `json:"stop_sequences,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"-"`
	// When enabled, the user's prompt will be sent to the model without
	// any pre-processing.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"-"`
	// The prompt is returned in the `prompt` response field when this is enabled.
	ReturnPrompt *bool `json:"return_prompt,omitempty" url:"-"`
	// A list of available tools (functions) that the model may suggest invoking before producing a text response.
	//
	// When `tools` is passed (without `tool_results`), the `text` field in the response will be `""` and the `tool_calls` field in the response will be populated with a list of tool calls that need to be made. If no calls need to be made, the `tool_calls` array will be empty.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Tools []*Tool `json:"tools,omitempty" url:"-"`
	// A list of results from invoking tools recommended by the model in the previous chat turn. Results are used to produce a text response and will be referenced in citations. When using `tool_results`, `tools` must be passed as well.
	// Each tool_result contains information about how it was invoked, as well as a list of outputs in the form of dictionaries.
	//
	// **Note**: `outputs` must be a list of objects. If your tool returns a single object (eg `{"status": 200}`), make sure to wrap it in a list.
	// ```
	// tool_results = [
	//
	//	{
	//	  "call": {
	//	    "name": <tool name>,
	//	    "parameters": {
	//	      <param name>: <param value>
	//	    }
	//	  },
	//	  "outputs": [{
	//	    <key>: <value>
	//	  }]
	//	},
	//	...
	//
	// ]
	// ```
	// **Note**: Chat calls with `tool_results` should not be included in the Chat history to avoid duplication of the message text.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	ToolResults []*ToolResult `json:"tool_results,omitempty" url:"-"`
	// Forces the chat to be single step. Defaults to `false`.
	ForceSingleStep *bool `json:"force_single_step,omitempty" url:"-"`
	stream          bool
}

func (c *ChatStreamRequest) Stream() bool {
	return c.stream
}

func (c *ChatStreamRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = ChatStreamRequest(body)
	c.stream = true
	return nil
}

func (c *ChatStreamRequest) MarshalJSON() ([]byte, error) {
	type embed ChatStreamRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*c),
		Stream: true,
	}
	return json.Marshal(marshaler)
}

type ClassifyRequest struct {
	// A list of up to 96 texts to be classified. Each one must be a non-empty string.
	// There is, however, no consistent, universal limit to the length a particular input can be. We perform classification on the first `x` tokens of each input, and `x` varies depending on which underlying model is powering classification. The maximum token length for each model is listed in the "max tokens" column [here](https://docs.cohere.com/docs/models).
	// Note: by default the `truncate` parameter is set to `END`, so tokens exceeding the limit will be automatically dropped. This behavior can be disabled by setting `truncate` to `NONE`, which will result in validation errors for longer texts.
	Inputs []string `json:"inputs,omitempty" url:"-"`
	// An array of examples to provide context to the model. Each example is a text string and its associated label/class. Each unique label requires at least 2 examples associated with it; the maximum number of examples is 2500, and each example has a maximum length of 512 tokens. The values should be structured as `{text: "...",label: "..."}`.
	// Note: [Fine-tuned Models](https://docs.cohere.com/docs/classify-fine-tuning) trained on classification examples don't require the `examples` parameter to be passed in explicitly.
	Examples []*ClassifyExample `json:"examples,omitempty" url:"-"`
	// The identifier of the model. Currently available models are `embed-multilingual-v2.0`, `embed-english-light-v2.0`, and `embed-english-v2.0` (default). Smaller "light" models are faster, while larger models will perform better. [Fine-tuned models](https://docs.cohere.com/docs/fine-tuning) can also be supplied with their full ID.
	Model *string `json:"model,omitempty" url:"-"`
	// The ID of a custom playground preset. You can create presets in the [playground](https://dashboard.cohere.com/playground/classify?model=large). If you use a preset, all other parameters become optional, and any included parameters will override the preset's parameters.
	Preset *string `json:"preset,omitempty" url:"-"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *ClassifyRequestTruncate `json:"truncate,omitempty" url:"-"`
}

type DetokenizeRequest struct {
	// The list of tokens to be detokenized.
	Tokens []int `json:"tokens,omitempty" url:"-"`
	// An optional parameter to provide the model name. This will ensure that the detokenization is done by the tokenizer used by that model.
	Model string `json:"model" url:"-"`
}

type EmbedRequest struct {
	// An array of strings for the model to embed. Maximum number of texts per call is `96`. We recommend reducing the length of each text to be under `512` tokens for optimal quality.
	Texts []string `json:"texts,omitempty" url:"-"`
	// Defaults to embed-english-v2.0
	//
	// The identifier of the model. Smaller "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
	//
	// Available models and corresponding embedding dimensions:
	//
	// * `embed-english-v3.0`  1024
	// * `embed-multilingual-v3.0`  1024
	// * `embed-english-light-v3.0`  384
	// * `embed-multilingual-light-v3.0`  384
	//
	// * `embed-english-v2.0`  4096
	// * `embed-english-light-v2.0`  1024
	// * `embed-multilingual-v2.0`  768
	Model     *string         `json:"model,omitempty" url:"-"`
	InputType *EmbedInputType `json:"input_type,omitempty" url:"-"`
	// Specifies the types of embeddings you want to get back. Not required and default is None, which returns the Embed Floats response type. Can be one or more of the following types.
	//
	// * `"float"`: Use this when you want to get back the default float embeddings. Valid for all models.
	// * `"int8"`: Use this when you want to get back signed int8 embeddings. Valid for only v3 models.
	// * `"uint8"`: Use this when you want to get back unsigned int8 embeddings. Valid for only v3 models.
	// * `"binary"`: Use this when you want to get back signed binary embeddings. Valid for only v3 models.
	// * `"ubinary"`: Use this when you want to get back unsigned binary embeddings. Valid for only v3 models.
	EmbeddingTypes []EmbeddingType `json:"embedding_types,omitempty" url:"-"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *EmbedRequestTruncate `json:"truncate,omitempty" url:"-"`
}

type GenerateRequest struct {
	// The input text that serves as the starting point for generating the response.
	// Note: The prompt will be pre-processed and modified before reaching the model.
	Prompt string `json:"prompt" url:"-"`
	// The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
	// Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
	Model *string `json:"model,omitempty" url:"-"`
	// The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.
	NumGenerations *int `json:"num_generations,omitempty" url:"-"`
	// When `true`, the response will be a JSON stream of events. Streaming is beneficial for user interfaces that render the contents of the response piece by piece, as it gets generated.
	//
	// The final event will contain the complete response, and will contain an `is_finished` field set to `true`. The event will also contain a `finish_reason`, which can be one of the following:
	// - `COMPLETE` - the model sent back a finished reply
	// - `MAX_TOKENS` - the reply was cut off because the model reached the maximum number of tokens for its context length
	// - `ERROR` - something went wrong when generating the reply
	// - `ERROR_TOXIC` - the model generated a reply that was deemed toxic
	//
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	//
	// This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.
	//
	// Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *GenerateRequestTruncate `json:"truncate,omitempty" url:"-"`
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
	// Defaults to `0.75`, min value of `0.0`, max value of `5.0`.
	Temperature *float64 `json:"temperature,omitempty" url:"-"`
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Seed *int `json:"seed,omitempty" url:"-"`
	// Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.com/playground/generate).
	// When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.
	Preset *string `json:"preset,omitempty" url:"-"`
	// The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.
	EndSequences []string `json:"end_sequences,omitempty" url:"-"`
	// The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.
	StopSequences []string `json:"stop_sequences,omitempty" url:"-"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"-"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"-"`
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"-"`
	// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
	//
	// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
	//
	// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
	ReturnLikelihoods *GenerateRequestReturnLikelihoods `json:"return_likelihoods,omitempty" url:"-"`
	// When enabled, the user's prompt will be sent to the model without any pre-processing.
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"-"`
	stream       bool
}

func (g *GenerateRequest) Stream() bool {
	return g.stream
}

func (g *GenerateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*g = GenerateRequest(body)
	g.stream = false
	return nil
}

func (g *GenerateRequest) MarshalJSON() ([]byte, error) {
	type embed GenerateRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*g),
		Stream: false,
	}
	return json.Marshal(marshaler)
}

type GenerateStreamRequest struct {
	// The input text that serves as the starting point for generating the response.
	// Note: The prompt will be pre-processed and modified before reaching the model.
	Prompt string `json:"prompt" url:"-"`
	// The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
	// Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
	Model *string `json:"model,omitempty" url:"-"`
	// The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.
	NumGenerations *int `json:"num_generations,omitempty" url:"-"`
	// When `true`, the response will be a JSON stream of events. Streaming is beneficial for user interfaces that render the contents of the response piece by piece, as it gets generated.
	//
	// The final event will contain the complete response, and will contain an `is_finished` field set to `true`. The event will also contain a `finish_reason`, which can be one of the following:
	// - `COMPLETE` - the model sent back a finished reply
	// - `MAX_TOKENS` - the reply was cut off because the model reached the maximum number of tokens for its context length
	// - `ERROR` - something went wrong when generating the reply
	// - `ERROR_TOXIC` - the model generated a reply that was deemed toxic
	//
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	//
	// This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.
	//
	// Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *GenerateStreamRequestTruncate `json:"truncate,omitempty" url:"-"`
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
	// Defaults to `0.75`, min value of `0.0`, max value of `5.0`.
	Temperature *float64 `json:"temperature,omitempty" url:"-"`
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Seed *int `json:"seed,omitempty" url:"-"`
	// Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.com/playground/generate).
	// When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.
	Preset *string `json:"preset,omitempty" url:"-"`
	// The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.
	EndSequences []string `json:"end_sequences,omitempty" url:"-"`
	// The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.
	StopSequences []string `json:"stop_sequences,omitempty" url:"-"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"-"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"-"`
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"-"`
	// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
	//
	// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
	//
	// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
	ReturnLikelihoods *GenerateStreamRequestReturnLikelihoods `json:"return_likelihoods,omitempty" url:"-"`
	// When enabled, the user's prompt will be sent to the model without any pre-processing.
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"-"`
	stream       bool
}

func (g *GenerateStreamRequest) Stream() bool {
	return g.stream
}

func (g *GenerateStreamRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*g = GenerateStreamRequest(body)
	g.stream = true
	return nil
}

func (g *GenerateStreamRequest) MarshalJSON() ([]byte, error) {
	type embed GenerateStreamRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*g),
		Stream: true,
	}
	return json.Marshal(marshaler)
}

type RerankRequest struct {
	// The identifier of the model to use, one of : `rerank-english-v3.0`, `rerank-multilingual-v3.0`, `rerank-english-v2.0`, `rerank-multilingual-v2.0`
	Model *string `json:"model,omitempty" url:"-"`
	// The search query
	Query string `json:"query" url:"-"`
	// A list of document objects or strings to rerank.
	// If a document is provided the text fields is required and all other fields will be preserved in the response.
	//
	// The total max chunks (length of documents * max_chunks_per_doc) must be less than 10000.
	//
	// We recommend a maximum of 1,000 documents for optimal endpoint performance.
	Documents []*RerankRequestDocumentsItem `json:"documents,omitempty" url:"-"`
	// The number of most relevant documents or indices to return, defaults to the length of the documents
	TopN *int `json:"top_n,omitempty" url:"-"`
	// If a JSON object is provided, you can specify which keys you would like to have considered for reranking. The model will rerank based on order of the fields passed in (i.e. rank_fields=['title','author','text'] will rerank using the values in title, author, text  sequentially. If the length of title, author, and text exceeds the context length of the model, the chunking will not re-consider earlier fields). If not provided, the model will use the default text field for ranking.
	RankFields []string `json:"rank_fields,omitempty" url:"-"`
	// - If false, returns results without the doc text - the api will return a list of {index, relevance score} where index is inferred from the list passed into the request.
	// - If true, returns results with the doc text passed in - the api will return an ordered list of {index, text, relevance score} where index + text refers to the list passed into the request.
	ReturnDocuments *bool `json:"return_documents,omitempty" url:"-"`
	// The maximum number of chunks to produce internally from a document
	MaxChunksPerDoc *int `json:"max_chunks_per_doc,omitempty" url:"-"`
}

type SummarizeRequest struct {
	// The text to generate a summary for. Can be up to 100,000 characters long. Currently the only supported language is English.
	Text string `json:"text" url:"-"`
	// One of `short`, `medium`, `long`, or `auto` defaults to `auto`. Indicates the approximate length of the summary. If `auto` is selected, the best option will be picked based on the input text.
	Length *SummarizeRequestLength `json:"length,omitempty" url:"-"`
	// One of `paragraph`, `bullets`, or `auto`, defaults to `auto`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If `auto` is selected, the best option will be picked based on the input text.
	Format *SummarizeRequestFormat `json:"format,omitempty" url:"-"`
	// The identifier of the model to generate the summary with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental). Smaller, "light" models are faster, while larger models will perform better.
	Model *string `json:"model,omitempty" url:"-"`
	// One of `low`, `medium`, `high`, or `auto`, defaults to `auto`. Controls how close to the original text the summary is. `high` extractiveness summaries will lean towards reusing sentences verbatim, while `low` extractiveness summaries will tend to paraphrase more. If `auto` is selected, the best option will be picked based on the input text.
	Extractiveness *SummarizeRequestExtractiveness `json:"extractiveness,omitempty" url:"-"`
	// Ranges from 0 to 5. Controls the randomness of the output. Lower values tend to generate more “predictable” output, while higher values tend to generate more “creative” output. The sweet spot is typically between 0 and 1.
	Temperature *float64 `json:"temperature,omitempty" url:"-"`
	// A free-form instruction for modifying how the summaries get generated. Should complete the sentence "Generate a summary _". Eg. "focusing on the next steps" or "written by Yoda"
	AdditionalCommand *string `json:"additional_command,omitempty" url:"-"`
}

type TokenizeRequest struct {
	// The string to be tokenized, the minimum text length is 1 character, and the maximum text length is 65536 characters.
	Text string `json:"text" url:"-"`
	// An optional parameter to provide the model name. This will ensure that the tokenization uses the tokenizer used by that model.
	Model string `json:"model" url:"-"`
}

type ApiMeta struct {
	ApiVersion  *ApiMetaApiVersion  `json:"api_version,omitempty" url:"api_version,omitempty"`
	BilledUnits *ApiMetaBilledUnits `json:"billed_units,omitempty" url:"billed_units,omitempty"`
	Tokens      *ApiMetaTokens      `json:"tokens,omitempty" url:"tokens,omitempty"`
	Warnings    []string            `json:"warnings,omitempty" url:"warnings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiMeta) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMeta(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMeta) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiMetaApiVersion struct {
	Version        string `json:"version" url:"version"`
	IsDeprecated   *bool  `json:"is_deprecated,omitempty" url:"is_deprecated,omitempty"`
	IsExperimental *bool  `json:"is_experimental,omitempty" url:"is_experimental,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiMetaApiVersion) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiMetaApiVersion) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMetaApiVersion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMetaApiVersion(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMetaApiVersion) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiMetaBilledUnits struct {
	// The number of billed input tokens.
	InputTokens *float64 `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// The number of billed output tokens.
	OutputTokens *float64 `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`
	// The number of billed search units.
	SearchUnits *float64 `json:"search_units,omitempty" url:"search_units,omitempty"`
	// The number of billed classifications units.
	Classifications *float64 `json:"classifications,omitempty" url:"classifications,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiMetaBilledUnits) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiMetaBilledUnits) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMetaBilledUnits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMetaBilledUnits(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMetaBilledUnits) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiMetaTokens struct {
	// The number of tokens used as input to the model.
	InputTokens *float64 `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// The number of tokens produced by the model.
	OutputTokens *float64 `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiMetaTokens) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiMetaTokens) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMetaTokens
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMetaTokens(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMetaTokens) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The token_type specifies the way the token is passed in the Authorization header. Valid values are "bearer", "basic", and "noscheme".
type AuthTokenType string

const (
	AuthTokenTypeBearer   AuthTokenType = "bearer"
	AuthTokenTypeBasic    AuthTokenType = "basic"
	AuthTokenTypeNoscheme AuthTokenType = "noscheme"
)

func NewAuthTokenTypeFromString(s string) (AuthTokenType, error) {
	switch s {
	case "bearer":
		return AuthTokenTypeBearer, nil
	case "basic":
		return AuthTokenTypeBasic, nil
	case "noscheme":
		return AuthTokenTypeNoscheme, nil
	}
	var t AuthTokenType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthTokenType) Ptr() *AuthTokenType {
	return &a
}

// A section of the generated reply which cites external knowledge.
type ChatCitation struct {
	// The index of text that the citation starts at, counting from zero. For example, a generation of `Hello, world!` with a citation on `world` would have a start value of `7`. This is because the citation starts at `w`, which is the seventh character.
	Start int `json:"start" url:"start"`
	// The index of text that the citation ends after, counting from zero. For example, a generation of `Hello, world!` with a citation on `world` would have an end value of `11`. This is because the citation ends after `d`, which is the eleventh character.
	End int `json:"end" url:"end"`
	// The text of the citation. For example, a generation of `Hello, world!` with a citation of `world` would have a text value of `world`.
	Text string `json:"text" url:"text"`
	// Identifiers of documents cited by this section of the generated reply.
	DocumentIds []string `json:"document_ids,omitempty" url:"document_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatCitation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatCitation) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCitation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCitation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCitation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatCitationGenerationEvent struct {
	// Citations for the generated reply.
	Citations []*ChatCitation `json:"citations,omitempty" url:"citations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatCitationGenerationEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatCitationGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCitationGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCitationGenerationEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCitationGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The connector used for fetching documents.
type ChatConnector struct {
	// The identifier of the connector.
	Id string `json:"id" url:"id"`
	// When specified, this user access token will be passed to the connector in the Authorization header instead of the Cohere generated one.
	UserAccessToken *string `json:"user_access_token,omitempty" url:"user_access_token,omitempty"`
	// Defaults to `false`.
	//
	// When `true`, the request will continue if this connector returned an error.
	ContinueOnFailure *bool `json:"continue_on_failure,omitempty" url:"continue_on_failure,omitempty"`
	// Provides the connector with different settings at request time. The key/value pairs of this object are specific to each connector.
	//
	// For example, the connector `web-search` supports the `site` option, which limits search results to the specified domain.
	Options map[string]interface{} `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatConnector) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatConnector) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatConnector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatConnector(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatConnector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatDataMetrics struct {
	// The sum of all turns of valid train examples.
	NumTrainTurns *int64 `json:"num_train_turns,omitempty" url:"num_train_turns,omitempty"`
	// The sum of all turns of valid eval examples.
	NumEvalTurns *int64 `json:"num_eval_turns,omitempty" url:"num_eval_turns,omitempty"`
	// The preamble of this dataset.
	Preamble *string `json:"preamble,omitempty" url:"preamble,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatDataMetrics) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatDataMetrics) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatDataMetrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatDataMetrics(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatDataMetrics) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Relevant information that could be used by the model to generate a more accurate reply.
// The contents of each document are generally short (under 300 words), and are passed in the form of a
// dictionary of strings. Some suggested keys are "text", "author", "date". Both the key name and the value will be
// passed to the model.
type ChatDocument = map[string]string

// Represents a single message in the chat history, excluding the current user turn. It has two properties: `role` and `message`. The `role` identifies the sender (`CHATBOT`, `SYSTEM`, or `USER`), while the `message` contains the text content.
//
// The chat_history parameter should not be used for `SYSTEM` messages in most cases. Instead, to add a `SYSTEM` role message at the beginning of a conversation, the `preamble` parameter should be used.
type ChatMessage struct {
	// Contents of the chat message.
	Message   string      `json:"message" url:"message"`
	ToolCalls []*ToolCall `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `"accurate"`.
//
// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
type ChatRequestCitationQuality string

const (
	ChatRequestCitationQualityFast     ChatRequestCitationQuality = "fast"
	ChatRequestCitationQualityAccurate ChatRequestCitationQuality = "accurate"
)

func NewChatRequestCitationQualityFromString(s string) (ChatRequestCitationQuality, error) {
	switch s {
	case "fast":
		return ChatRequestCitationQualityFast, nil
	case "accurate":
		return ChatRequestCitationQualityAccurate, nil
	}
	var t ChatRequestCitationQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatRequestCitationQuality) Ptr() *ChatRequestCitationQuality {
	return &c
}

// (internal) Sets inference and model options for RAG search query and tool use generations. Defaults are used when options are not specified here, meaning that other parameters outside of connectors_search_options are ignored (such as model= or temperature=).
type ChatRequestConnectorsSearchOptions struct {
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Seed *int `json:"seed,omitempty" url:"seed,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatRequestConnectorsSearchOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatRequestConnectorsSearchOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatRequestConnectorsSearchOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatRequestConnectorsSearchOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatRequestConnectorsSearchOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
//
// Dictates how the prompt will be constructed.
//
// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be changed and ranked by relevance.
//
// With `prompt_truncation` set to "AUTO_PRESERVE_ORDER", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be preserved as they are inputted into the API.
//
// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
// Compatible Deployments: Cohere Platform Only AUTO_PRESERVE_ORDER: Azure, AWS Sagemaker, Private Deployments
type ChatRequestPromptTruncation string

const (
	ChatRequestPromptTruncationOff               ChatRequestPromptTruncation = "OFF"
	ChatRequestPromptTruncationAuto              ChatRequestPromptTruncation = "AUTO"
	ChatRequestPromptTruncationAutoPreserveOrder ChatRequestPromptTruncation = "AUTO_PRESERVE_ORDER"
)

func NewChatRequestPromptTruncationFromString(s string) (ChatRequestPromptTruncation, error) {
	switch s {
	case "OFF":
		return ChatRequestPromptTruncationOff, nil
	case "AUTO":
		return ChatRequestPromptTruncationAuto, nil
	case "AUTO_PRESERVE_ORDER":
		return ChatRequestPromptTruncationAutoPreserveOrder, nil
	}
	var t ChatRequestPromptTruncation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatRequestPromptTruncation) Ptr() *ChatRequestPromptTruncation {
	return &c
}

type ChatSearchQueriesGenerationEvent struct {
	// Generated search queries, meant to be used as part of the RAG flow.
	SearchQueries []*ChatSearchQuery `json:"search_queries,omitempty" url:"search_queries,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatSearchQueriesGenerationEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatSearchQueriesGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchQueriesGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchQueriesGenerationEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchQueriesGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The generated search query. Contains the text of the query and a unique identifier for the query.
type ChatSearchQuery struct {
	// The text of the search query.
	Text string `json:"text" url:"text"`
	// Unique identifier for the generated search query. Useful for submitting feedback.
	GenerationId string `json:"generation_id" url:"generation_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatSearchQuery) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatSearchQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchQuery) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatSearchResult struct {
	SearchQuery *ChatSearchQuery `json:"search_query,omitempty" url:"search_query,omitempty"`
	// The connector from which this result comes from.
	Connector *ChatSearchResultConnector `json:"connector,omitempty" url:"connector,omitempty"`
	// Identifiers of documents found by this search query.
	DocumentIds []string `json:"document_ids,omitempty" url:"document_ids,omitempty"`
	// An error message if the search failed.
	ErrorMessage *string `json:"error_message,omitempty" url:"error_message,omitempty"`
	// Whether a chat request should continue or not if the request to this connector fails.
	ContinueOnFailure *bool `json:"continue_on_failure,omitempty" url:"continue_on_failure,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatSearchResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatSearchResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The connector used for fetching documents.
type ChatSearchResultConnector struct {
	// The identifier of the connector.
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatSearchResultConnector) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatSearchResultConnector) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchResultConnector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchResultConnector(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchResultConnector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatSearchResultsEvent struct {
	// Conducted searches and the ids of documents retrieved from each of them.
	SearchResults []*ChatSearchResult `json:"search_results,omitempty" url:"search_results,omitempty"`
	// Documents fetched from searches or provided by the user.
	Documents []ChatDocument `json:"documents,omitempty" url:"documents,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatSearchResultsEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatSearchResultsEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchResultsEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchResultsEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchResultsEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatStreamEndEvent struct {
	// - `COMPLETE` - the model sent back a finished reply
	// - `ERROR_LIMIT` - the reply was cut off because the model reached the maximum number of tokens for its context length
	// - `MAX_TOKENS` - the reply was cut off because the model reached the maximum number of tokens specified by the max_tokens parameter
	// - `ERROR` - something went wrong when generating the reply
	// - `ERROR_TOXIC` - the model generated a reply that was deemed toxic
	FinishReason ChatStreamEndEventFinishReason `json:"finish_reason" url:"finish_reason"`
	// The consolidated response from the model. Contains the generated reply and all the other information streamed back in the previous events.
	Response *NonStreamedChatResponse `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatStreamEndEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatStreamEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamEndEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamEndEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// - `COMPLETE` - the model sent back a finished reply
// - `ERROR_LIMIT` - the reply was cut off because the model reached the maximum number of tokens for its context length
// - `MAX_TOKENS` - the reply was cut off because the model reached the maximum number of tokens specified by the max_tokens parameter
// - `ERROR` - something went wrong when generating the reply
// - `ERROR_TOXIC` - the model generated a reply that was deemed toxic
type ChatStreamEndEventFinishReason string

const (
	ChatStreamEndEventFinishReasonComplete   ChatStreamEndEventFinishReason = "COMPLETE"
	ChatStreamEndEventFinishReasonErrorLimit ChatStreamEndEventFinishReason = "ERROR_LIMIT"
	ChatStreamEndEventFinishReasonMaxTokens  ChatStreamEndEventFinishReason = "MAX_TOKENS"
	ChatStreamEndEventFinishReasonError      ChatStreamEndEventFinishReason = "ERROR"
	ChatStreamEndEventFinishReasonErrorToxic ChatStreamEndEventFinishReason = "ERROR_TOXIC"
)

func NewChatStreamEndEventFinishReasonFromString(s string) (ChatStreamEndEventFinishReason, error) {
	switch s {
	case "COMPLETE":
		return ChatStreamEndEventFinishReasonComplete, nil
	case "ERROR_LIMIT":
		return ChatStreamEndEventFinishReasonErrorLimit, nil
	case "MAX_TOKENS":
		return ChatStreamEndEventFinishReasonMaxTokens, nil
	case "ERROR":
		return ChatStreamEndEventFinishReasonError, nil
	case "ERROR_TOXIC":
		return ChatStreamEndEventFinishReasonErrorToxic, nil
	}
	var t ChatStreamEndEventFinishReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatStreamEndEventFinishReason) Ptr() *ChatStreamEndEventFinishReason {
	return &c
}

type ChatStreamEvent struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatStreamEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatStreamEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `"accurate"`.
//
// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
type ChatStreamRequestCitationQuality string

const (
	ChatStreamRequestCitationQualityFast     ChatStreamRequestCitationQuality = "fast"
	ChatStreamRequestCitationQualityAccurate ChatStreamRequestCitationQuality = "accurate"
)

func NewChatStreamRequestCitationQualityFromString(s string) (ChatStreamRequestCitationQuality, error) {
	switch s {
	case "fast":
		return ChatStreamRequestCitationQualityFast, nil
	case "accurate":
		return ChatStreamRequestCitationQualityAccurate, nil
	}
	var t ChatStreamRequestCitationQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatStreamRequestCitationQuality) Ptr() *ChatStreamRequestCitationQuality {
	return &c
}

// (internal) Sets inference and model options for RAG search query and tool use generations. Defaults are used when options are not specified here, meaning that other parameters outside of connectors_search_options are ignored (such as model= or temperature=).
type ChatStreamRequestConnectorsSearchOptions struct {
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker, Private Deployments
	Seed *int `json:"seed,omitempty" url:"seed,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatStreamRequestConnectorsSearchOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatStreamRequestConnectorsSearchOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamRequestConnectorsSearchOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamRequestConnectorsSearchOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamRequestConnectorsSearchOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
//
// Dictates how the prompt will be constructed.
//
// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be changed and ranked by relevance.
//
// With `prompt_truncation` set to "AUTO_PRESERVE_ORDER", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be preserved as they are inputted into the API.
//
// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
// Compatible Deployments: Cohere Platform Only AUTO_PRESERVE_ORDER: Azure, AWS Sagemaker, Private Deployments
type ChatStreamRequestPromptTruncation string

const (
	ChatStreamRequestPromptTruncationOff               ChatStreamRequestPromptTruncation = "OFF"
	ChatStreamRequestPromptTruncationAuto              ChatStreamRequestPromptTruncation = "AUTO"
	ChatStreamRequestPromptTruncationAutoPreserveOrder ChatStreamRequestPromptTruncation = "AUTO_PRESERVE_ORDER"
)

func NewChatStreamRequestPromptTruncationFromString(s string) (ChatStreamRequestPromptTruncation, error) {
	switch s {
	case "OFF":
		return ChatStreamRequestPromptTruncationOff, nil
	case "AUTO":
		return ChatStreamRequestPromptTruncationAuto, nil
	case "AUTO_PRESERVE_ORDER":
		return ChatStreamRequestPromptTruncationAutoPreserveOrder, nil
	}
	var t ChatStreamRequestPromptTruncation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatStreamRequestPromptTruncation) Ptr() *ChatStreamRequestPromptTruncation {
	return &c
}

type ChatStreamStartEvent struct {
	// Unique identifier for the generated reply. Useful for submitting feedback.
	GenerationId string `json:"generation_id" url:"generation_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatStreamStartEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatStreamStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamStartEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamStartEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatTextGenerationEvent struct {
	// The next batch of text generated by the model.
	Text string `json:"text" url:"text"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatTextGenerationEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatTextGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatTextGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatTextGenerationEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatTextGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallsChunkEvent struct {
	ToolCallDelta *ToolCallDelta `json:"tool_call_delta,omitempty" url:"tool_call_delta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatToolCallsChunkEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallsChunkEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallsChunkEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallsChunkEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallsChunkEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallsGenerationEvent struct {
	// The text generated related to the tool calls generated
	Text      *string     `json:"text,omitempty" url:"text,omitempty"`
	ToolCalls []*ToolCall `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChatToolCallsGenerationEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallsGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallsGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallsGenerationEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallsGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckApiKeyResponse struct {
	Valid          bool    `json:"valid" url:"valid"`
	OrganizationId *string `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	OwnerId        *string `json:"owner_id,omitempty" url:"owner_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckApiKeyResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckApiKeyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckApiKeyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckApiKeyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckApiKeyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClassifyDataMetrics struct {
	LabelMetrics []*LabelMetric `json:"label_metrics,omitempty" url:"label_metrics,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClassifyDataMetrics) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClassifyDataMetrics) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyDataMetrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyDataMetrics(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyDataMetrics) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClassifyExample struct {
	Text  *string `json:"text,omitempty" url:"text,omitempty"`
	Label *string `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClassifyExample) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClassifyExample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyExample(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyExample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type ClassifyRequestTruncate string

const (
	ClassifyRequestTruncateNone  ClassifyRequestTruncate = "NONE"
	ClassifyRequestTruncateStart ClassifyRequestTruncate = "START"
	ClassifyRequestTruncateEnd   ClassifyRequestTruncate = "END"
)

func NewClassifyRequestTruncateFromString(s string) (ClassifyRequestTruncate, error) {
	switch s {
	case "NONE":
		return ClassifyRequestTruncateNone, nil
	case "START":
		return ClassifyRequestTruncateStart, nil
	case "END":
		return ClassifyRequestTruncateEnd, nil
	}
	var t ClassifyRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClassifyRequestTruncate) Ptr() *ClassifyRequestTruncate {
	return &c
}

type ClassifyResponse struct {
	Id              string                                 `json:"id" url:"id"`
	Classifications []*ClassifyResponseClassificationsItem `json:"classifications,omitempty" url:"classifications,omitempty"`
	Meta            *ApiMeta                               `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClassifyResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClassifyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClassifyResponseClassificationsItem struct {
	Id string `json:"id" url:"id"`
	// The input text that was classified
	Input *string `json:"input,omitempty" url:"input,omitempty"`
	// The predicted label for the associated query (only filled for single-label models)
	Prediction *string `json:"prediction,omitempty" url:"prediction,omitempty"`
	// An array containing the predicted labels for the associated query (only filled for single-label classification)
	Predictions []string `json:"predictions,omitempty" url:"predictions,omitempty"`
	// The confidence score for the top predicted class (only filled for single-label classification)
	Confidence *float64 `json:"confidence,omitempty" url:"confidence,omitempty"`
	// An array containing the confidence scores of all the predictions in the same order
	Confidences []float64 `json:"confidences,omitempty" url:"confidences,omitempty"`
	// A map containing each label and its confidence score according to the classifier. All the confidence scores add up to 1 for single-label classification. For multi-label classification the label confidences are independent of each other, so they don't have to sum up to 1.
	Labels map[string]*ClassifyResponseClassificationsItemLabelsValue `json:"labels,omitempty" url:"labels,omitempty"`
	// The type of classification performed
	ClassificationType ClassifyResponseClassificationsItemClassificationType `json:"classification_type" url:"classification_type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClassifyResponseClassificationsItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClassifyResponseClassificationsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyResponseClassificationsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyResponseClassificationsItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyResponseClassificationsItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of classification performed
type ClassifyResponseClassificationsItemClassificationType string

const (
	ClassifyResponseClassificationsItemClassificationTypeSingleLabel ClassifyResponseClassificationsItemClassificationType = "single-label"
	ClassifyResponseClassificationsItemClassificationTypeMultiLabel  ClassifyResponseClassificationsItemClassificationType = "multi-label"
)

func NewClassifyResponseClassificationsItemClassificationTypeFromString(s string) (ClassifyResponseClassificationsItemClassificationType, error) {
	switch s {
	case "single-label":
		return ClassifyResponseClassificationsItemClassificationTypeSingleLabel, nil
	case "multi-label":
		return ClassifyResponseClassificationsItemClassificationTypeMultiLabel, nil
	}
	var t ClassifyResponseClassificationsItemClassificationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClassifyResponseClassificationsItemClassificationType) Ptr() *ClassifyResponseClassificationsItemClassificationType {
	return &c
}

type ClassifyResponseClassificationsItemLabelsValue struct {
	Confidence *float64 `json:"confidence,omitempty" url:"confidence,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClassifyResponseClassificationsItemLabelsValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClassifyResponseClassificationsItemLabelsValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyResponseClassificationsItemLabelsValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyResponseClassificationsItemLabelsValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyResponseClassificationsItemLabelsValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClientClosedRequestErrorBody struct {
	Data *string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClientClosedRequestErrorBody) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClientClosedRequestErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ClientClosedRequestErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClientClosedRequestErrorBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClientClosedRequestErrorBody) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// One of the Cohere API endpoints that the model can be used with.
type CompatibleEndpoint string

const (
	CompatibleEndpointChat      CompatibleEndpoint = "chat"
	CompatibleEndpointEmbed     CompatibleEndpoint = "embed"
	CompatibleEndpointClassify  CompatibleEndpoint = "classify"
	CompatibleEndpointSummarize CompatibleEndpoint = "summarize"
	CompatibleEndpointRerank    CompatibleEndpoint = "rerank"
	CompatibleEndpointRate      CompatibleEndpoint = "rate"
	CompatibleEndpointGenerate  CompatibleEndpoint = "generate"
)

func NewCompatibleEndpointFromString(s string) (CompatibleEndpoint, error) {
	switch s {
	case "chat":
		return CompatibleEndpointChat, nil
	case "embed":
		return CompatibleEndpointEmbed, nil
	case "classify":
		return CompatibleEndpointClassify, nil
	case "summarize":
		return CompatibleEndpointSummarize, nil
	case "rerank":
		return CompatibleEndpointRerank, nil
	case "rate":
		return CompatibleEndpointRate, nil
	case "generate":
		return CompatibleEndpointGenerate, nil
	}
	var t CompatibleEndpoint
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CompatibleEndpoint) Ptr() *CompatibleEndpoint {
	return &c
}

// A connector allows you to integrate data sources with the '/chat' endpoint to create grounded generations with citations to the data source.
// documents to help answer users.
type Connector struct {
	// The unique identifier of the connector (used in both `/connectors` & `/chat` endpoints).
	// This is automatically created from the name of the connector upon registration.
	Id string `json:"id" url:"id"`
	// The organization to which this connector belongs. This is automatically set to
	// the organization of the user who created the connector.
	OrganizationId *string `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	// A human-readable name for the connector.
	Name string `json:"name" url:"name"`
	// A description of the connector.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The URL of the connector that will be used to search for documents.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The UTC time at which the connector was created.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The UTC time at which the connector was last updated.
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// A list of fields to exclude from the prompt (fields remain in the document).
	Excludes []string `json:"excludes,omitempty" url:"excludes,omitempty"`
	// The type of authentication/authorization used by the connector. Possible values: [oauth, service_auth]
	AuthType *string `json:"auth_type,omitempty" url:"auth_type,omitempty"`
	// The OAuth 2.0 configuration for the connector.
	Oauth *ConnectorOAuth `json:"oauth,omitempty" url:"oauth,omitempty"`
	// The OAuth status for the user making the request. One of ["valid", "expired", ""]. Empty string (field is omitted) means the user has not authorized the connector yet.
	AuthStatus *ConnectorAuthStatus `json:"auth_status,omitempty" url:"auth_status,omitempty"`
	// Whether the connector is active or not.
	Active *bool `json:"active,omitempty" url:"active,omitempty"`
	// Whether a chat request should continue or not if the request to this connector fails.
	ContinueOnFailure *bool `json:"continue_on_failure,omitempty" url:"continue_on_failure,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Connector) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Connector) UnmarshalJSON(data []byte) error {
	type embed Connector
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Connector(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Connector) MarshalJSON() ([]byte, error) {
	type embed Connector
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Connector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The OAuth status for the user making the request. One of ["valid", "expired", ""]. Empty string (field is omitted) means the user has not authorized the connector yet.
type ConnectorAuthStatus string

const (
	ConnectorAuthStatusValid   ConnectorAuthStatus = "valid"
	ConnectorAuthStatusExpired ConnectorAuthStatus = "expired"
)

func NewConnectorAuthStatusFromString(s string) (ConnectorAuthStatus, error) {
	switch s {
	case "valid":
		return ConnectorAuthStatusValid, nil
	case "expired":
		return ConnectorAuthStatusExpired, nil
	}
	var t ConnectorAuthStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectorAuthStatus) Ptr() *ConnectorAuthStatus {
	return &c
}

type ConnectorOAuth struct {
	// The OAuth 2.0 client ID. This field is encrypted at rest.
	ClientId *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// The OAuth 2.0 client Secret. This field is encrypted at rest and never returned in a response.
	ClientSecret *string `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	// The OAuth 2.0 /authorize endpoint to use when users authorize the connector.
	AuthorizeUrl string `json:"authorize_url" url:"authorize_url"`
	// The OAuth 2.0 /token endpoint to use when users authorize the connector.
	TokenUrl string `json:"token_url" url:"token_url"`
	// The OAuth scopes to request when users authorize the connector.
	Scope *string `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConnectorOAuth) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConnectorOAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectorOAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectorOAuth(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectorOAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorOAuth struct {
	// The OAuth 2.0 client ID. This fields is encrypted at rest.
	ClientId *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// The OAuth 2.0 client Secret. This field is encrypted at rest and never returned in a response.
	ClientSecret *string `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	// The OAuth 2.0 /authorize endpoint to use when users authorize the connector.
	AuthorizeUrl *string `json:"authorize_url,omitempty" url:"authorize_url,omitempty"`
	// The OAuth 2.0 /token endpoint to use when users authorize the connector.
	TokenUrl *string `json:"token_url,omitempty" url:"token_url,omitempty"`
	// The OAuth scopes to request when users authorize the connector.
	Scope *string `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateConnectorOAuth) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateConnectorOAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorOAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorOAuth(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorOAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorResponse struct {
	Connector *Connector `json:"connector,omitempty" url:"connector,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateConnectorResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateConnectorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorServiceAuth struct {
	Type AuthTokenType `json:"type" url:"type"`
	// The token that will be used in the HTTP Authorization header when making requests to the connector. This field is encrypted at rest and never returned in a response.
	Token string `json:"token" url:"token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateConnectorServiceAuth) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateConnectorServiceAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorServiceAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorServiceAuth(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorServiceAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response from creating an embed job.
type CreateEmbedJobResponse struct {
	JobId string   `json:"job_id" url:"job_id"`
	Meta  *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateEmbedJobResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateEmbedJobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateEmbedJobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateEmbedJobResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEmbedJobResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Dataset struct {
	// The dataset ID
	Id string `json:"id" url:"id"`
	// The name of the dataset
	Name string `json:"name" url:"name"`
	// The creation date
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The last update date
	UpdatedAt        time.Time               `json:"updated_at" url:"updated_at"`
	DatasetType      DatasetType             `json:"dataset_type" url:"dataset_type"`
	ValidationStatus DatasetValidationStatus `json:"validation_status" url:"validation_status"`
	// Errors found during validation
	ValidationError *string `json:"validation_error,omitempty" url:"validation_error,omitempty"`
	// the avro schema of the dataset
	Schema         *string  `json:"schema,omitempty" url:"schema,omitempty"`
	RequiredFields []string `json:"required_fields,omitempty" url:"required_fields,omitempty"`
	PreserveFields []string `json:"preserve_fields,omitempty" url:"preserve_fields,omitempty"`
	// the underlying files that make up the dataset
	DatasetParts []*DatasetPart `json:"dataset_parts,omitempty" url:"dataset_parts,omitempty"`
	// warnings found during validation
	ValidationWarnings []string `json:"validation_warnings,omitempty" url:"validation_warnings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Dataset) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Dataset) UnmarshalJSON(data []byte) error {
	type embed Dataset
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = Dataset(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Dataset) MarshalJSON() ([]byte, error) {
	type embed Dataset
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*d),
		CreatedAt: core.NewDateTime(d.CreatedAt),
		UpdatedAt: core.NewDateTime(d.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *Dataset) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DatasetPart struct {
	// The dataset part ID
	Id string `json:"id" url:"id"`
	// The name of the dataset part
	Name string `json:"name" url:"name"`
	// The download url of the file
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The index of the file
	Index *int `json:"index,omitempty" url:"index,omitempty"`
	// The size of the file in bytes
	SizeBytes *int `json:"size_bytes,omitempty" url:"size_bytes,omitempty"`
	// The number of rows in the file
	NumRows *int `json:"num_rows,omitempty" url:"num_rows,omitempty"`
	// The download url of the original file
	OriginalUrl *string `json:"original_url,omitempty" url:"original_url,omitempty"`
	// The first few rows of the parsed file
	Samples []string `json:"samples,omitempty" url:"samples,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DatasetPart) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DatasetPart) UnmarshalJSON(data []byte) error {
	type unmarshaler DatasetPart
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DatasetPart(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DatasetPart) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The type of the dataset
type DatasetType string

const (
	DatasetTypeEmbedInput                             DatasetType = "embed-input"
	DatasetTypeEmbedResult                            DatasetType = "embed-result"
	DatasetTypeClusterResult                          DatasetType = "cluster-result"
	DatasetTypeClusterOutliers                        DatasetType = "cluster-outliers"
	DatasetTypeRerankerFinetuneInput                  DatasetType = "reranker-finetune-input"
	DatasetTypeSingleLabelClassificationFinetuneInput DatasetType = "single-label-classification-finetune-input"
	DatasetTypeChatFinetuneInput                      DatasetType = "chat-finetune-input"
	DatasetTypeMultiLabelClassificationFinetuneInput  DatasetType = "multi-label-classification-finetune-input"
)

func NewDatasetTypeFromString(s string) (DatasetType, error) {
	switch s {
	case "embed-input":
		return DatasetTypeEmbedInput, nil
	case "embed-result":
		return DatasetTypeEmbedResult, nil
	case "cluster-result":
		return DatasetTypeClusterResult, nil
	case "cluster-outliers":
		return DatasetTypeClusterOutliers, nil
	case "reranker-finetune-input":
		return DatasetTypeRerankerFinetuneInput, nil
	case "single-label-classification-finetune-input":
		return DatasetTypeSingleLabelClassificationFinetuneInput, nil
	case "chat-finetune-input":
		return DatasetTypeChatFinetuneInput, nil
	case "multi-label-classification-finetune-input":
		return DatasetTypeMultiLabelClassificationFinetuneInput, nil
	}
	var t DatasetType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatasetType) Ptr() *DatasetType {
	return &d
}

// The validation status of the dataset
type DatasetValidationStatus string

const (
	DatasetValidationStatusUnknown    DatasetValidationStatus = "unknown"
	DatasetValidationStatusQueued     DatasetValidationStatus = "queued"
	DatasetValidationStatusProcessing DatasetValidationStatus = "processing"
	DatasetValidationStatusFailed     DatasetValidationStatus = "failed"
	DatasetValidationStatusValidated  DatasetValidationStatus = "validated"
	DatasetValidationStatusSkipped    DatasetValidationStatus = "skipped"
)

func NewDatasetValidationStatusFromString(s string) (DatasetValidationStatus, error) {
	switch s {
	case "unknown":
		return DatasetValidationStatusUnknown, nil
	case "queued":
		return DatasetValidationStatusQueued, nil
	case "processing":
		return DatasetValidationStatusProcessing, nil
	case "failed":
		return DatasetValidationStatusFailed, nil
	case "validated":
		return DatasetValidationStatusValidated, nil
	case "skipped":
		return DatasetValidationStatusSkipped, nil
	}
	var t DatasetValidationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatasetValidationStatus) Ptr() *DatasetValidationStatus {
	return &d
}

type DeleteConnectorResponse = map[string]interface{}

type DetokenizeResponse struct {
	// A string representing the list of tokens.
	Text string   `json:"text" url:"text"`
	Meta *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DetokenizeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DetokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DetokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetokenizeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetokenizeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EmbedByTypeResponse struct {
	Id string `json:"id" url:"id"`
	// An object with different embedding types. The length of each embedding type array will be the same as the length of the original `texts` array.
	Embeddings *EmbedByTypeResponseEmbeddings `json:"embeddings,omitempty" url:"embeddings,omitempty"`
	// The text entries for which embeddings were returned.
	Texts []string `json:"texts,omitempty" url:"texts,omitempty"`
	Meta  *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmbedByTypeResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedByTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedByTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedByTypeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedByTypeResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// An object with different embedding types. The length of each embedding type array will be the same as the length of the original `texts` array.
type EmbedByTypeResponseEmbeddings struct {
	// An array of float embeddings.
	Float [][]float64 `json:"float,omitempty" url:"float,omitempty"`
	// An array of signed int8 embeddings. Each value is between -128 and 127.
	Int8 [][]int `json:"int8,omitempty" url:"int8,omitempty"`
	// An array of unsigned int8 embeddings. Each value is between 0 and 255.
	Uint8 [][]int `json:"uint8,omitempty" url:"uint8,omitempty"`
	// An array of packed signed binary embeddings. The length of each binary embedding is 1/8 the length of the float embeddings of the provided model. Each value is between -128 and 127.
	Binary [][]int `json:"binary,omitempty" url:"binary,omitempty"`
	// An array of packed unsigned binary embeddings. The length of each binary embedding is 1/8 the length of the float embeddings of the provided model. Each value is between 0 and 255.
	Ubinary [][]int `json:"ubinary,omitempty" url:"ubinary,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmbedByTypeResponseEmbeddings) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedByTypeResponseEmbeddings) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedByTypeResponseEmbeddings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedByTypeResponseEmbeddings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedByTypeResponseEmbeddings) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmbedFloatsResponse struct {
	Id string `json:"id" url:"id"`
	// An array of embeddings, where each embedding is an array of floats. The length of the `embeddings` array will be the same as the length of the original `texts` array.
	Embeddings [][]float64 `json:"embeddings,omitempty" url:"embeddings,omitempty"`
	// The text entries for which embeddings were returned.
	Texts []string `json:"texts,omitempty" url:"texts,omitempty"`
	Meta  *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmbedFloatsResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedFloatsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedFloatsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedFloatsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedFloatsResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Specifies the type of input passed to the model. Required for embedding models v3 and higher.
//
// - `"search_document"`: Used for embeddings stored in a vector database for search use-cases.
// - `"search_query"`: Used for embeddings of search queries run against a vector DB to find relevant documents.
// - `"classification"`: Used for embeddings passed through a text classifier.
// - `"clustering"`: Used for the embeddings run through a clustering algorithm.
type EmbedInputType string

const (
	EmbedInputTypeSearchDocument EmbedInputType = "search_document"
	EmbedInputTypeSearchQuery    EmbedInputType = "search_query"
	EmbedInputTypeClassification EmbedInputType = "classification"
	EmbedInputTypeClustering     EmbedInputType = "clustering"
)

func NewEmbedInputTypeFromString(s string) (EmbedInputType, error) {
	switch s {
	case "search_document":
		return EmbedInputTypeSearchDocument, nil
	case "search_query":
		return EmbedInputTypeSearchQuery, nil
	case "classification":
		return EmbedInputTypeClassification, nil
	case "clustering":
		return EmbedInputTypeClustering, nil
	}
	var t EmbedInputType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedInputType) Ptr() *EmbedInputType {
	return &e
}

type EmbedJob struct {
	// ID of the embed job
	JobId string `json:"job_id" url:"job_id"`
	// The name of the embed job
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The status of the embed job
	Status EmbedJobStatus `json:"status" url:"status"`
	// The creation date of the embed job
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// ID of the input dataset
	InputDatasetId string `json:"input_dataset_id" url:"input_dataset_id"`
	// ID of the resulting output dataset
	OutputDatasetId *string `json:"output_dataset_id,omitempty" url:"output_dataset_id,omitempty"`
	// ID of the model used to embed
	Model string `json:"model" url:"model"`
	// The truncation option used
	Truncate EmbedJobTruncate `json:"truncate" url:"truncate"`
	Meta     *ApiMeta         `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmbedJob) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedJob) UnmarshalJSON(data []byte) error {
	type embed EmbedJob
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EmbedJob(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedJob) MarshalJSON() ([]byte, error) {
	type embed EmbedJob
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EmbedJob) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The status of the embed job
type EmbedJobStatus string

const (
	EmbedJobStatusProcessing EmbedJobStatus = "processing"
	EmbedJobStatusComplete   EmbedJobStatus = "complete"
	EmbedJobStatusCancelling EmbedJobStatus = "cancelling"
	EmbedJobStatusCancelled  EmbedJobStatus = "cancelled"
	EmbedJobStatusFailed     EmbedJobStatus = "failed"
)

func NewEmbedJobStatusFromString(s string) (EmbedJobStatus, error) {
	switch s {
	case "processing":
		return EmbedJobStatusProcessing, nil
	case "complete":
		return EmbedJobStatusComplete, nil
	case "cancelling":
		return EmbedJobStatusCancelling, nil
	case "cancelled":
		return EmbedJobStatusCancelled, nil
	case "failed":
		return EmbedJobStatusFailed, nil
	}
	var t EmbedJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedJobStatus) Ptr() *EmbedJobStatus {
	return &e
}

// The truncation option used
type EmbedJobTruncate string

const (
	EmbedJobTruncateStart EmbedJobTruncate = "START"
	EmbedJobTruncateEnd   EmbedJobTruncate = "END"
)

func NewEmbedJobTruncateFromString(s string) (EmbedJobTruncate, error) {
	switch s {
	case "START":
		return EmbedJobTruncateStart, nil
	case "END":
		return EmbedJobTruncateEnd, nil
	}
	var t EmbedJobTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedJobTruncate) Ptr() *EmbedJobTruncate {
	return &e
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type EmbedRequestTruncate string

const (
	EmbedRequestTruncateNone  EmbedRequestTruncate = "NONE"
	EmbedRequestTruncateStart EmbedRequestTruncate = "START"
	EmbedRequestTruncateEnd   EmbedRequestTruncate = "END"
)

func NewEmbedRequestTruncateFromString(s string) (EmbedRequestTruncate, error) {
	switch s {
	case "NONE":
		return EmbedRequestTruncateNone, nil
	case "START":
		return EmbedRequestTruncateStart, nil
	case "END":
		return EmbedRequestTruncateEnd, nil
	}
	var t EmbedRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedRequestTruncate) Ptr() *EmbedRequestTruncate {
	return &e
}

type EmbedResponse struct {
	ResponseType     string
	EmbeddingsFloats *EmbedFloatsResponse
	EmbeddingsByType *EmbedByTypeResponse
}

func (e *EmbedResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ResponseType string `json:"response_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.ResponseType = unmarshaler.ResponseType
	switch unmarshaler.ResponseType {
	case "embeddings_floats":
		value := new(EmbedFloatsResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EmbeddingsFloats = value
	case "embeddings_by_type":
		value := new(EmbedByTypeResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EmbeddingsByType = value
	}
	return nil
}

func (e EmbedResponse) MarshalJSON() ([]byte, error) {
	if e.EmbeddingsFloats != nil {
		return core.MarshalJSONWithExtraProperty(e.EmbeddingsFloats, "response_type", "embeddings_floats")
	}
	if e.EmbeddingsByType != nil {
		return core.MarshalJSONWithExtraProperty(e.EmbeddingsByType, "response_type", "embeddings_by_type")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EmbedResponseVisitor interface {
	VisitEmbeddingsFloats(*EmbedFloatsResponse) error
	VisitEmbeddingsByType(*EmbedByTypeResponse) error
}

func (e *EmbedResponse) Accept(visitor EmbedResponseVisitor) error {
	if e.EmbeddingsFloats != nil {
		return visitor.VisitEmbeddingsFloats(e.EmbeddingsFloats)
	}
	if e.EmbeddingsByType != nil {
		return visitor.VisitEmbeddingsByType(e.EmbeddingsByType)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EmbeddingType string

const (
	EmbeddingTypeFloat   EmbeddingType = "float"
	EmbeddingTypeInt8    EmbeddingType = "int8"
	EmbeddingTypeUint8   EmbeddingType = "uint8"
	EmbeddingTypeBinary  EmbeddingType = "binary"
	EmbeddingTypeUbinary EmbeddingType = "ubinary"
)

func NewEmbeddingTypeFromString(s string) (EmbeddingType, error) {
	switch s {
	case "float":
		return EmbeddingTypeFloat, nil
	case "int8":
		return EmbeddingTypeInt8, nil
	case "uint8":
		return EmbeddingTypeUint8, nil
	case "binary":
		return EmbeddingTypeBinary, nil
	case "ubinary":
		return EmbeddingTypeUbinary, nil
	}
	var t EmbeddingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbeddingType) Ptr() *EmbeddingType {
	return &e
}

type FinetuneDatasetMetrics struct {
	// The number of tokens of valid examples that can be used for training.
	TrainableTokenCount *int64 `json:"trainable_token_count,omitempty" url:"trainable_token_count,omitempty"`
	// The overall number of examples.
	TotalExamples *int64 `json:"total_examples,omitempty" url:"total_examples,omitempty"`
	// The number of training examples.
	TrainExamples *int64 `json:"train_examples,omitempty" url:"train_examples,omitempty"`
	// The size in bytes of all training examples.
	TrainSizeBytes *int64 `json:"train_size_bytes,omitempty" url:"train_size_bytes,omitempty"`
	// Number of evaluation examples.
	EvalExamples *int64 `json:"eval_examples,omitempty" url:"eval_examples,omitempty"`
	// The size in bytes of all eval examples.
	EvalSizeBytes *int64 `json:"eval_size_bytes,omitempty" url:"eval_size_bytes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FinetuneDatasetMetrics) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FinetuneDatasetMetrics) UnmarshalJSON(data []byte) error {
	type unmarshaler FinetuneDatasetMetrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinetuneDatasetMetrics(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinetuneDatasetMetrics) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FinishReason string

const (
	FinishReasonComplete     FinishReason = "COMPLETE"
	FinishReasonStopSequence FinishReason = "STOP_SEQUENCE"
	FinishReasonError        FinishReason = "ERROR"
	FinishReasonErrorToxic   FinishReason = "ERROR_TOXIC"
	FinishReasonErrorLimit   FinishReason = "ERROR_LIMIT"
	FinishReasonUserCancel   FinishReason = "USER_CANCEL"
	FinishReasonMaxTokens    FinishReason = "MAX_TOKENS"
)

func NewFinishReasonFromString(s string) (FinishReason, error) {
	switch s {
	case "COMPLETE":
		return FinishReasonComplete, nil
	case "STOP_SEQUENCE":
		return FinishReasonStopSequence, nil
	case "ERROR":
		return FinishReasonError, nil
	case "ERROR_TOXIC":
		return FinishReasonErrorToxic, nil
	case "ERROR_LIMIT":
		return FinishReasonErrorLimit, nil
	case "USER_CANCEL":
		return FinishReasonUserCancel, nil
	case "MAX_TOKENS":
		return FinishReasonMaxTokens, nil
	}
	var t FinishReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FinishReason) Ptr() *FinishReason {
	return &f
}

type GatewayTimeoutErrorBody struct {
	Data *string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GatewayTimeoutErrorBody) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GatewayTimeoutErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler GatewayTimeoutErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GatewayTimeoutErrorBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GatewayTimeoutErrorBody) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
//
// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
//
// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
type GenerateRequestReturnLikelihoods string

const (
	GenerateRequestReturnLikelihoodsGeneration GenerateRequestReturnLikelihoods = "GENERATION"
	GenerateRequestReturnLikelihoodsAll        GenerateRequestReturnLikelihoods = "ALL"
	GenerateRequestReturnLikelihoodsNone       GenerateRequestReturnLikelihoods = "NONE"
)

func NewGenerateRequestReturnLikelihoodsFromString(s string) (GenerateRequestReturnLikelihoods, error) {
	switch s {
	case "GENERATION":
		return GenerateRequestReturnLikelihoodsGeneration, nil
	case "ALL":
		return GenerateRequestReturnLikelihoodsAll, nil
	case "NONE":
		return GenerateRequestReturnLikelihoodsNone, nil
	}
	var t GenerateRequestReturnLikelihoods
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateRequestReturnLikelihoods) Ptr() *GenerateRequestReturnLikelihoods {
	return &g
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type GenerateRequestTruncate string

const (
	GenerateRequestTruncateNone  GenerateRequestTruncate = "NONE"
	GenerateRequestTruncateStart GenerateRequestTruncate = "START"
	GenerateRequestTruncateEnd   GenerateRequestTruncate = "END"
)

func NewGenerateRequestTruncateFromString(s string) (GenerateRequestTruncate, error) {
	switch s {
	case "NONE":
		return GenerateRequestTruncateNone, nil
	case "START":
		return GenerateRequestTruncateStart, nil
	case "END":
		return GenerateRequestTruncateEnd, nil
	}
	var t GenerateRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateRequestTruncate) Ptr() *GenerateRequestTruncate {
	return &g
}

type GenerateStreamEnd struct {
	IsFinished   bool                       `json:"is_finished" url:"is_finished"`
	FinishReason *FinishReason              `json:"finish_reason,omitempty" url:"finish_reason,omitempty"`
	Response     *GenerateStreamEndResponse `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GenerateStreamEnd) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerateStreamEnd) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamEnd
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamEnd(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamEnd) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateStreamEndResponse struct {
	Id          string                      `json:"id" url:"id"`
	Prompt      *string                     `json:"prompt,omitempty" url:"prompt,omitempty"`
	Generations []*SingleGenerationInStream `json:"generations,omitempty" url:"generations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GenerateStreamEndResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerateStreamEndResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamEndResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamEndResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamEndResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateStreamError struct {
	// Refers to the nth generation. Only present when `num_generations` is greater than zero.
	Index        *int         `json:"index,omitempty" url:"index,omitempty"`
	IsFinished   bool         `json:"is_finished" url:"is_finished"`
	FinishReason FinishReason `json:"finish_reason" url:"finish_reason"`
	// Error message
	Err string `json:"err" url:"err"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GenerateStreamError) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerateStreamError) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamError) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateStreamEvent struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GenerateStreamEvent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerateStreamEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamEvent) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
//
// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
//
// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
type GenerateStreamRequestReturnLikelihoods string

const (
	GenerateStreamRequestReturnLikelihoodsGeneration GenerateStreamRequestReturnLikelihoods = "GENERATION"
	GenerateStreamRequestReturnLikelihoodsAll        GenerateStreamRequestReturnLikelihoods = "ALL"
	GenerateStreamRequestReturnLikelihoodsNone       GenerateStreamRequestReturnLikelihoods = "NONE"
)

func NewGenerateStreamRequestReturnLikelihoodsFromString(s string) (GenerateStreamRequestReturnLikelihoods, error) {
	switch s {
	case "GENERATION":
		return GenerateStreamRequestReturnLikelihoodsGeneration, nil
	case "ALL":
		return GenerateStreamRequestReturnLikelihoodsAll, nil
	case "NONE":
		return GenerateStreamRequestReturnLikelihoodsNone, nil
	}
	var t GenerateStreamRequestReturnLikelihoods
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateStreamRequestReturnLikelihoods) Ptr() *GenerateStreamRequestReturnLikelihoods {
	return &g
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type GenerateStreamRequestTruncate string

const (
	GenerateStreamRequestTruncateNone  GenerateStreamRequestTruncate = "NONE"
	GenerateStreamRequestTruncateStart GenerateStreamRequestTruncate = "START"
	GenerateStreamRequestTruncateEnd   GenerateStreamRequestTruncate = "END"
)

func NewGenerateStreamRequestTruncateFromString(s string) (GenerateStreamRequestTruncate, error) {
	switch s {
	case "NONE":
		return GenerateStreamRequestTruncateNone, nil
	case "START":
		return GenerateStreamRequestTruncateStart, nil
	case "END":
		return GenerateStreamRequestTruncateEnd, nil
	}
	var t GenerateStreamRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateStreamRequestTruncate) Ptr() *GenerateStreamRequestTruncate {
	return &g
}

type GenerateStreamText struct {
	// A segment of text of the generation.
	Text string `json:"text" url:"text"`
	// Refers to the nth generation. Only present when `num_generations` is greater than zero, and only when text responses are being streamed.
	Index      *int `json:"index,omitempty" url:"index,omitempty"`
	IsFinished bool `json:"is_finished" url:"is_finished"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GenerateStreamText) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerateStreamText) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamText(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamText) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Response in content type stream when `stream` is `true` in the request parameters. Generation tokens are streamed with the GenerationStream response. The final response is of type GenerationFinalResponse.
type GenerateStreamedResponse struct {
	EventType      string
	TextGeneration *GenerateStreamText
	StreamEnd      *GenerateStreamEnd
	StreamError    *GenerateStreamError
}

func (g *GenerateStreamedResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"event_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.EventType = unmarshaler.EventType
	switch unmarshaler.EventType {
	case "text-generation":
		value := new(GenerateStreamText)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.TextGeneration = value
	case "stream-end":
		value := new(GenerateStreamEnd)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.StreamEnd = value
	case "stream-error":
		value := new(GenerateStreamError)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.StreamError = value
	}
	return nil
}

func (g GenerateStreamedResponse) MarshalJSON() ([]byte, error) {
	if g.TextGeneration != nil {
		return core.MarshalJSONWithExtraProperty(g.TextGeneration, "event_type", "text-generation")
	}
	if g.StreamEnd != nil {
		return core.MarshalJSONWithExtraProperty(g.StreamEnd, "event_type", "stream-end")
	}
	if g.StreamError != nil {
		return core.MarshalJSONWithExtraProperty(g.StreamError, "event_type", "stream-error")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GenerateStreamedResponseVisitor interface {
	VisitTextGeneration(*GenerateStreamText) error
	VisitStreamEnd(*GenerateStreamEnd) error
	VisitStreamError(*GenerateStreamError) error
}

func (g *GenerateStreamedResponse) Accept(visitor GenerateStreamedResponseVisitor) error {
	if g.TextGeneration != nil {
		return visitor.VisitTextGeneration(g.TextGeneration)
	}
	if g.StreamEnd != nil {
		return visitor.VisitStreamEnd(g.StreamEnd)
	}
	if g.StreamError != nil {
		return visitor.VisitStreamError(g.StreamError)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

type Generation struct {
	Id string `json:"id" url:"id"`
	// Prompt used for generations.
	Prompt *string `json:"prompt,omitempty" url:"prompt,omitempty"`
	// List of generated results
	Generations []*SingleGeneration `json:"generations,omitempty" url:"generations,omitempty"`
	Meta        *ApiMeta            `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *Generation) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Generation) UnmarshalJSON(data []byte) error {
	type unmarshaler Generation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Generation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Generation) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetConnectorResponse struct {
	Connector *Connector `json:"connector,omitempty" url:"connector,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetConnectorResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetConnectorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetConnectorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetConnectorResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetConnectorResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Contains information about the model and which API endpoints it can be used with.
type GetModelResponse struct {
	// Specify this name in the `model` parameter of API requests to use your chosen model.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The API endpoints that the model is compatible with.
	Endpoints []CompatibleEndpoint `json:"endpoints,omitempty" url:"endpoints,omitempty"`
	// Whether the model has been fine-tuned or not.
	Finetuned *bool `json:"finetuned,omitempty" url:"finetuned,omitempty"`
	// The maximum number of tokens that the model can process in a single request. Note that not all of these tokens are always available due to special tokens and preambles that Cohere has added by default.
	ContextLength *float64 `json:"context_length,omitempty" url:"context_length,omitempty"`
	// Public URL to the tokenizer's configuration file.
	TokenizerUrl *string `json:"tokenizer_url,omitempty" url:"tokenizer_url,omitempty"`
	// The API endpoints that the model is default to.
	DefaultEndpoints []CompatibleEndpoint `json:"default_endpoints,omitempty" url:"default_endpoints,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetModelResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetModelResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetModelResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetModelResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetModelResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type LabelMetric struct {
	// Total number of examples for this label
	TotalExamples *int64 `json:"total_examples,omitempty" url:"total_examples,omitempty"`
	// value of the label
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// samples for this label
	Samples []string `json:"samples,omitempty" url:"samples,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LabelMetric) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabelMetric) UnmarshalJSON(data []byte) error {
	type unmarshaler LabelMetric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabelMetric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabelMetric) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListConnectorsResponse struct {
	Connectors []*Connector `json:"connectors,omitempty" url:"connectors,omitempty"`
	// Total number of connectors.
	TotalCount *float64 `json:"total_count,omitempty" url:"total_count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListConnectorsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListConnectorsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListConnectorsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListConnectorsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListConnectorsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListEmbedJobResponse struct {
	EmbedJobs []*EmbedJob `json:"embed_jobs,omitempty" url:"embed_jobs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListEmbedJobResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListEmbedJobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEmbedJobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEmbedJobResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEmbedJobResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListModelsResponse struct {
	Models []*GetModelResponse `json:"models,omitempty" url:"models,omitempty"`
	// A token to retrieve the next page of results. Provide in the page_token parameter of the next request.
	NextPageToken *string `json:"next_page_token,omitempty" url:"next_page_token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListModelsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListModelsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListModelsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListModelsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListModelsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Message struct {
	Role    string
	Chatbot *ChatMessage
	System  *ChatMessage
	User    *ChatMessage
	Tool    *ToolMessage
}

func (m *Message) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Role string `json:"role"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	m.Role = unmarshaler.Role
	switch unmarshaler.Role {
	case "CHATBOT":
		value := new(ChatMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		m.Chatbot = value
	case "SYSTEM":
		value := new(ChatMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		m.System = value
	case "USER":
		value := new(ChatMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		m.User = value
	case "TOOL":
		value := new(ToolMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		m.Tool = value
	}
	return nil
}

func (m Message) MarshalJSON() ([]byte, error) {
	if m.Chatbot != nil {
		return core.MarshalJSONWithExtraProperty(m.Chatbot, "role", "CHATBOT")
	}
	if m.System != nil {
		return core.MarshalJSONWithExtraProperty(m.System, "role", "SYSTEM")
	}
	if m.User != nil {
		return core.MarshalJSONWithExtraProperty(m.User, "role", "USER")
	}
	if m.Tool != nil {
		return core.MarshalJSONWithExtraProperty(m.Tool, "role", "TOOL")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", m)
}

type MessageVisitor interface {
	VisitChatbot(*ChatMessage) error
	VisitSystem(*ChatMessage) error
	VisitUser(*ChatMessage) error
	VisitTool(*ToolMessage) error
}

func (m *Message) Accept(visitor MessageVisitor) error {
	if m.Chatbot != nil {
		return visitor.VisitChatbot(m.Chatbot)
	}
	if m.System != nil {
		return visitor.VisitSystem(m.System)
	}
	if m.User != nil {
		return visitor.VisitUser(m.User)
	}
	if m.Tool != nil {
		return visitor.VisitTool(m.Tool)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", m)
}

type Metrics struct {
	FinetuneDatasetMetrics *FinetuneDatasetMetrics `json:"finetune_dataset_metrics,omitempty" url:"finetune_dataset_metrics,omitempty"`
	EmbedData              *MetricsEmbedData       `json:"embed_data,omitempty" url:"embed_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Metrics) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metrics) UnmarshalJSON(data []byte) error {
	type unmarshaler Metrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metrics(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metrics) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetricsEmbedData struct {
	// the fields in the dataset
	Fields []*MetricsEmbedDataFieldsItem `json:"fields,omitempty" url:"fields,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetricsEmbedData) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetricsEmbedData) UnmarshalJSON(data []byte) error {
	type unmarshaler MetricsEmbedData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetricsEmbedData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetricsEmbedData) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetricsEmbedDataFieldsItem struct {
	// the name of the field
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// the number of times the field appears in the dataset
	Count *float64 `json:"count,omitempty" url:"count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetricsEmbedDataFieldsItem) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetricsEmbedDataFieldsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler MetricsEmbedDataFieldsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetricsEmbedDataFieldsItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetricsEmbedDataFieldsItem) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NonStreamedChatResponse struct {
	// Contents of the reply generated by the model.
	Text string `json:"text" url:"text"`
	// Unique identifier for the generated reply. Useful for submitting feedback.
	GenerationId *string `json:"generation_id,omitempty" url:"generation_id,omitempty"`
	// Inline citations for the generated reply.
	Citations []*ChatCitation `json:"citations,omitempty" url:"citations,omitempty"`
	// Documents seen by the model when generating the reply.
	Documents []ChatDocument `json:"documents,omitempty" url:"documents,omitempty"`
	// Denotes that a search for documents is required during the RAG flow.
	IsSearchRequired *bool `json:"is_search_required,omitempty" url:"is_search_required,omitempty"`
	// Generated search queries, meant to be used as part of the RAG flow.
	SearchQueries []*ChatSearchQuery `json:"search_queries,omitempty" url:"search_queries,omitempty"`
	// Documents retrieved from each of the conducted searches.
	SearchResults []*ChatSearchResult `json:"search_results,omitempty" url:"search_results,omitempty"`
	FinishReason  *FinishReason       `json:"finish_reason,omitempty" url:"finish_reason,omitempty"`
	ToolCalls     []*ToolCall         `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`
	// A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's `message`.
	ChatHistory []*Message `json:"chat_history,omitempty" url:"chat_history,omitempty"`
	// The prompt that was used. Only present when `return_prompt` in the request is set to true.
	Prompt *string  `json:"prompt,omitempty" url:"prompt,omitempty"`
	Meta   *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NonStreamedChatResponse) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NonStreamedChatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler NonStreamedChatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NonStreamedChatResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NonStreamedChatResponse) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotImplementedErrorBody struct {
	Data *string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotImplementedErrorBody) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotImplementedErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler NotImplementedErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotImplementedErrorBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotImplementedErrorBody) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type OAuthAuthorizeResponse struct {
	// The OAuth 2.0 redirect url. Redirect the user to this url to authorize the connector.
	RedirectUrl *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OAuthAuthorizeResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthAuthorizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthAuthorizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthAuthorizeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuthAuthorizeResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type ParseInfo struct {
	Separator *string `json:"separator,omitempty" url:"separator,omitempty"`
	Delimiter *string `json:"delimiter,omitempty" url:"delimiter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ParseInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ParseInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ParseInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ParseInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ParseInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RerankRequestDocumentsItem struct {
	String                         string
	RerankRequestDocumentsItemText *RerankRequestDocumentsItemText
}

func (r *RerankRequestDocumentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.String = valueString
		return nil
	}
	valueRerankRequestDocumentsItemText := new(RerankRequestDocumentsItemText)
	if err := json.Unmarshal(data, &valueRerankRequestDocumentsItemText); err == nil {
		r.RerankRequestDocumentsItemText = valueRerankRequestDocumentsItemText
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RerankRequestDocumentsItem) MarshalJSON() ([]byte, error) {
	if r.String != "" {
		return json.Marshal(r.String)
	}
	if r.RerankRequestDocumentsItemText != nil {
		return json.Marshal(r.RerankRequestDocumentsItemText)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RerankRequestDocumentsItemVisitor interface {
	VisitString(string) error
	VisitRerankRequestDocumentsItemText(*RerankRequestDocumentsItemText) error
}

func (r *RerankRequestDocumentsItem) Accept(visitor RerankRequestDocumentsItemVisitor) error {
	if r.String != "" {
		return visitor.VisitString(r.String)
	}
	if r.RerankRequestDocumentsItemText != nil {
		return visitor.VisitRerankRequestDocumentsItemText(r.RerankRequestDocumentsItemText)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RerankRequestDocumentsItemText struct {
	// The text of the document to rerank.
	Text string `json:"text" url:"text"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RerankRequestDocumentsItemText) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RerankRequestDocumentsItemText) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankRequestDocumentsItemText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankRequestDocumentsItemText(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankRequestDocumentsItemText) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RerankResponse struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An ordered list of ranked documents
	Results []*RerankResponseResultsItem `json:"results,omitempty" url:"results,omitempty"`
	Meta    *ApiMeta                     `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RerankResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RerankResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RerankResponseResultsItem struct {
	// If `return_documents` is set as `false` this will return none, if `true` it will return the documents passed in
	Document *RerankResponseResultsItemDocument `json:"document,omitempty" url:"document,omitempty"`
	// Corresponds to the index in the original list of documents to which the ranked document belongs. (i.e. if the first value in the `results` object has an `index` value of 3, it means in the list of documents passed in, the document at `index=3` had the highest relevance)
	Index int `json:"index" url:"index"`
	// Relevance scores are normalized to be in the range `[0, 1]`. Scores close to `1` indicate a high relevance to the query, and scores closer to `0` indicate low relevance. It is not accurate to assume a score of 0.9 means the document is 2x more relevant than a document with a score of 0.45
	RelevanceScore float64 `json:"relevance_score" url:"relevance_score"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RerankResponseResultsItem) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RerankResponseResultsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankResponseResultsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankResponseResultsItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankResponseResultsItem) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// If `return_documents` is set as `false` this will return none, if `true` it will return the documents passed in
type RerankResponseResultsItemDocument struct {
	// The text of the document to rerank
	Text string `json:"text" url:"text"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RerankResponseResultsItemDocument) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RerankResponseResultsItemDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankResponseResultsItemDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankResponseResultsItemDocument(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankResponseResultsItemDocument) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RerankerDataMetrics struct {
	// The number of training queries.
	NumTrainQueries *int64 `json:"num_train_queries,omitempty" url:"num_train_queries,omitempty"`
	// The sum of all relevant passages of valid training examples.
	NumTrainRelevantPassages *int64 `json:"num_train_relevant_passages,omitempty" url:"num_train_relevant_passages,omitempty"`
	// The sum of all hard negatives of valid training examples.
	NumTrainHardNegatives *int64 `json:"num_train_hard_negatives,omitempty" url:"num_train_hard_negatives,omitempty"`
	// The number of evaluation queries.
	NumEvalQueries *int64 `json:"num_eval_queries,omitempty" url:"num_eval_queries,omitempty"`
	// The sum of all relevant passages of valid eval examples.
	NumEvalRelevantPassages *int64 `json:"num_eval_relevant_passages,omitempty" url:"num_eval_relevant_passages,omitempty"`
	// The sum of all hard negatives of valid eval examples.
	NumEvalHardNegatives *int64 `json:"num_eval_hard_negatives,omitempty" url:"num_eval_hard_negatives,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RerankerDataMetrics) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RerankerDataMetrics) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankerDataMetrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankerDataMetrics(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankerDataMetrics) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SingleGeneration struct {
	Id   string `json:"id" url:"id"`
	Text string `json:"text" url:"text"`
	// Refers to the nth generation. Only present when `num_generations` is greater than zero.
	Index      *int     `json:"index,omitempty" url:"index,omitempty"`
	Likelihood *float64 `json:"likelihood,omitempty" url:"likelihood,omitempty"`
	// Only returned if `return_likelihoods` is set to `GENERATION` or `ALL`. The likelihood refers to the average log-likelihood of the entire specified string, which is useful for [evaluating the performance of your model](likelihood-eval), especially if you've created a [custom model](/docs/training-custom-models). Individual token likelihoods provide the log-likelihood of each token. The first token will not have a likelihood.
	TokenLikelihoods []*SingleGenerationTokenLikelihoodsItem `json:"token_likelihoods,omitempty" url:"token_likelihoods,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleGeneration) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleGeneration) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleGeneration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleGeneration(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleGeneration) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleGenerationInStream struct {
	Id string `json:"id" url:"id"`
	// Full text of the generation.
	Text string `json:"text" url:"text"`
	// Refers to the nth generation. Only present when `num_generations` is greater than zero.
	Index        *int         `json:"index,omitempty" url:"index,omitempty"`
	FinishReason FinishReason `json:"finish_reason" url:"finish_reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleGenerationInStream) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleGenerationInStream) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleGenerationInStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleGenerationInStream(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleGenerationInStream) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleGenerationTokenLikelihoodsItem struct {
	Token      string  `json:"token" url:"token"`
	Likelihood float64 `json:"likelihood" url:"likelihood"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SingleGenerationTokenLikelihoodsItem) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleGenerationTokenLikelihoodsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleGenerationTokenLikelihoodsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleGenerationTokenLikelihoodsItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleGenerationTokenLikelihoodsItem) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// StreamedChatResponse is returned in streaming mode (specified with `stream=True` in the request).
type StreamedChatResponse struct {
	EventType               string
	StreamStart             *ChatStreamStartEvent
	SearchQueriesGeneration *ChatSearchQueriesGenerationEvent
	SearchResults           *ChatSearchResultsEvent
	TextGeneration          *ChatTextGenerationEvent
	CitationGeneration      *ChatCitationGenerationEvent
	ToolCallsGeneration     *ChatToolCallsGenerationEvent
	StreamEnd               *ChatStreamEndEvent
	ToolCallsChunk          *ChatToolCallsChunkEvent
}

func (s *StreamedChatResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"event_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.EventType = unmarshaler.EventType
	switch unmarshaler.EventType {
	case "stream-start":
		value := new(ChatStreamStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.StreamStart = value
	case "search-queries-generation":
		value := new(ChatSearchQueriesGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SearchQueriesGeneration = value
	case "search-results":
		value := new(ChatSearchResultsEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SearchResults = value
	case "text-generation":
		value := new(ChatTextGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.TextGeneration = value
	case "citation-generation":
		value := new(ChatCitationGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.CitationGeneration = value
	case "tool-calls-generation":
		value := new(ChatToolCallsGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.ToolCallsGeneration = value
	case "stream-end":
		value := new(ChatStreamEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.StreamEnd = value
	case "tool-calls-chunk":
		value := new(ChatToolCallsChunkEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.ToolCallsChunk = value
	}
	return nil
}

func (s StreamedChatResponse) MarshalJSON() ([]byte, error) {
	if s.StreamStart != nil {
		return core.MarshalJSONWithExtraProperty(s.StreamStart, "event_type", "stream-start")
	}
	if s.SearchQueriesGeneration != nil {
		return core.MarshalJSONWithExtraProperty(s.SearchQueriesGeneration, "event_type", "search-queries-generation")
	}
	if s.SearchResults != nil {
		return core.MarshalJSONWithExtraProperty(s.SearchResults, "event_type", "search-results")
	}
	if s.TextGeneration != nil {
		return core.MarshalJSONWithExtraProperty(s.TextGeneration, "event_type", "text-generation")
	}
	if s.CitationGeneration != nil {
		return core.MarshalJSONWithExtraProperty(s.CitationGeneration, "event_type", "citation-generation")
	}
	if s.ToolCallsGeneration != nil {
		return core.MarshalJSONWithExtraProperty(s.ToolCallsGeneration, "event_type", "tool-calls-generation")
	}
	if s.StreamEnd != nil {
		return core.MarshalJSONWithExtraProperty(s.StreamEnd, "event_type", "stream-end")
	}
	if s.ToolCallsChunk != nil {
		return core.MarshalJSONWithExtraProperty(s.ToolCallsChunk, "event_type", "tool-calls-chunk")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type StreamedChatResponseVisitor interface {
	VisitStreamStart(*ChatStreamStartEvent) error
	VisitSearchQueriesGeneration(*ChatSearchQueriesGenerationEvent) error
	VisitSearchResults(*ChatSearchResultsEvent) error
	VisitTextGeneration(*ChatTextGenerationEvent) error
	VisitCitationGeneration(*ChatCitationGenerationEvent) error
	VisitToolCallsGeneration(*ChatToolCallsGenerationEvent) error
	VisitStreamEnd(*ChatStreamEndEvent) error
	VisitToolCallsChunk(*ChatToolCallsChunkEvent) error
}

func (s *StreamedChatResponse) Accept(visitor StreamedChatResponseVisitor) error {
	if s.StreamStart != nil {
		return visitor.VisitStreamStart(s.StreamStart)
	}
	if s.SearchQueriesGeneration != nil {
		return visitor.VisitSearchQueriesGeneration(s.SearchQueriesGeneration)
	}
	if s.SearchResults != nil {
		return visitor.VisitSearchResults(s.SearchResults)
	}
	if s.TextGeneration != nil {
		return visitor.VisitTextGeneration(s.TextGeneration)
	}
	if s.CitationGeneration != nil {
		return visitor.VisitCitationGeneration(s.CitationGeneration)
	}
	if s.ToolCallsGeneration != nil {
		return visitor.VisitToolCallsGeneration(s.ToolCallsGeneration)
	}
	if s.StreamEnd != nil {
		return visitor.VisitStreamEnd(s.StreamEnd)
	}
	if s.ToolCallsChunk != nil {
		return visitor.VisitToolCallsChunk(s.ToolCallsChunk)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

// One of `low`, `medium`, `high`, or `auto`, defaults to `auto`. Controls how close to the original text the summary is. `high` extractiveness summaries will lean towards reusing sentences verbatim, while `low` extractiveness summaries will tend to paraphrase more. If `auto` is selected, the best option will be picked based on the input text.
type SummarizeRequestExtractiveness string

const (
	SummarizeRequestExtractivenessLow    SummarizeRequestExtractiveness = "low"
	SummarizeRequestExtractivenessMedium SummarizeRequestExtractiveness = "medium"
	SummarizeRequestExtractivenessHigh   SummarizeRequestExtractiveness = "high"
)

func NewSummarizeRequestExtractivenessFromString(s string) (SummarizeRequestExtractiveness, error) {
	switch s {
	case "low":
		return SummarizeRequestExtractivenessLow, nil
	case "medium":
		return SummarizeRequestExtractivenessMedium, nil
	case "high":
		return SummarizeRequestExtractivenessHigh, nil
	}
	var t SummarizeRequestExtractiveness
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SummarizeRequestExtractiveness) Ptr() *SummarizeRequestExtractiveness {
	return &s
}

// One of `paragraph`, `bullets`, or `auto`, defaults to `auto`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If `auto` is selected, the best option will be picked based on the input text.
type SummarizeRequestFormat string

const (
	SummarizeRequestFormatParagraph SummarizeRequestFormat = "paragraph"
	SummarizeRequestFormatBullets   SummarizeRequestFormat = "bullets"
)

func NewSummarizeRequestFormatFromString(s string) (SummarizeRequestFormat, error) {
	switch s {
	case "paragraph":
		return SummarizeRequestFormatParagraph, nil
	case "bullets":
		return SummarizeRequestFormatBullets, nil
	}
	var t SummarizeRequestFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SummarizeRequestFormat) Ptr() *SummarizeRequestFormat {
	return &s
}

// One of `short`, `medium`, `long`, or `auto` defaults to `auto`. Indicates the approximate length of the summary. If `auto` is selected, the best option will be picked based on the input text.
type SummarizeRequestLength string

const (
	SummarizeRequestLengthShort  SummarizeRequestLength = "short"
	SummarizeRequestLengthMedium SummarizeRequestLength = "medium"
	SummarizeRequestLengthLong   SummarizeRequestLength = "long"
)

func NewSummarizeRequestLengthFromString(s string) (SummarizeRequestLength, error) {
	switch s {
	case "short":
		return SummarizeRequestLengthShort, nil
	case "medium":
		return SummarizeRequestLengthMedium, nil
	case "long":
		return SummarizeRequestLengthLong, nil
	}
	var t SummarizeRequestLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SummarizeRequestLength) Ptr() *SummarizeRequestLength {
	return &s
}

type SummarizeResponse struct {
	// Generated ID for the summary
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Generated summary for the text
	Summary *string  `json:"summary,omitempty" url:"summary,omitempty"`
	Meta    *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SummarizeResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SummarizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SummarizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummarizeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummarizeResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TokenizeResponse struct {
	// An array of tokens, where each token is an integer.
	Tokens       []int    `json:"tokens,omitempty" url:"tokens,omitempty"`
	TokenStrings []string `json:"token_strings,omitempty" url:"token_strings,omitempty"`
	Meta         *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenizeResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TooManyRequestsErrorBody struct {
	Data *string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TooManyRequestsErrorBody) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TooManyRequestsErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler TooManyRequestsErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TooManyRequestsErrorBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TooManyRequestsErrorBody) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Tool struct {
	// The name of the tool to be called. Valid names contain only the characters `a-z`, `A-Z`, `0-9`, `_` and must not begin with a digit.
	Name string `json:"name" url:"name"`
	// The description of what the tool does, the model uses the description to choose when and how to call the function.
	Description string `json:"description" url:"description"`
	// The input parameters of the tool. Accepts a dictionary where the key is the name of the parameter and the value is the parameter spec. Valid parameter names contain only the characters `a-z`, `A-Z`, `0-9`, `_` and must not begin with a digit.
	//
	// ```
	//
	//	{
	//	  "my_param": {
	//	    "description": <string>,
	//	    "type": <string>, // any python data type, such as 'str', 'bool'
	//	    "required": <boolean>
	//	  }
	//	}
	//
	// ```
	ParameterDefinitions map[string]*ToolParameterDefinitionsValue `json:"parameter_definitions,omitempty" url:"parameter_definitions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Tool) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tool) UnmarshalJSON(data []byte) error {
	type unmarshaler Tool
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tool(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tool) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Contains the tool calls generated by the model. Use it to invoke your tools.
type ToolCall struct {
	// Name of the tool to call.
	Name string `json:"name" url:"name"`
	// The name and value of the parameters to use when invoking a tool.
	Parameters map[string]interface{} `json:"parameters,omitempty" url:"parameters,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolCall) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCall) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCall(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCall) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Contains the chunk of the tool call generation in the stream.
type ToolCallDelta struct {
	// Name of the tool call
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Index of the tool call generated
	Index *float64 `json:"index,omitempty" url:"index,omitempty"`
	// Chunk of the tool parameters
	Parameters *string `json:"parameters,omitempty" url:"parameters,omitempty"`
	// Chunk of the tool plan text
	Text *string `json:"text,omitempty" url:"text,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolCallDelta) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallDelta(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallDelta) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents tool result in the chat history.
type ToolMessage struct {
	ToolResults []*ToolResult `json:"tool_results,omitempty" url:"tool_results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolMessage) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolMessage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessage) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolParameterDefinitionsValue struct {
	// The description of the parameter.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The type of the parameter. Must be a valid Python type.
	Type string `json:"type" url:"type"`
	// Denotes whether the parameter is always present (required) or not. Defaults to not required.
	Required *bool `json:"required,omitempty" url:"required,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolParameterDefinitionsValue) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolParameterDefinitionsValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolParameterDefinitionsValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolParameterDefinitionsValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolParameterDefinitionsValue) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolResult struct {
	Call    *ToolCall                `json:"call,omitempty" url:"call,omitempty"`
	Outputs []map[string]interface{} `json:"outputs,omitempty" url:"outputs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ToolResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolResult) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UnprocessableEntityErrorBody struct {
	Data *string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UnprocessableEntityErrorBody) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UnprocessableEntityErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler UnprocessableEntityErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnprocessableEntityErrorBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UnprocessableEntityErrorBody) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateConnectorResponse struct {
	Connector *Connector `json:"connector,omitempty" url:"connector,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateConnectorResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateConnectorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateConnectorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateConnectorResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateConnectorResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// the underlying files that make up the dataset
type DatasetsCreateResponseDatasetPartsItem struct {
	// the name of the dataset part
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// the number of rows in the dataset part
	NumRows *float64 `json:"num_rows,omitempty" url:"num_rows,omitempty"`
	Samples []string `json:"samples,omitempty" url:"samples,omitempty"`
	// the kind of dataset part
	PartKind *string `json:"part_kind,omitempty" url:"part_kind,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DatasetsCreateResponseDatasetPartsItem) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DatasetsCreateResponseDatasetPartsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DatasetsCreateResponseDatasetPartsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DatasetsCreateResponseDatasetPartsItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DatasetsCreateResponseDatasetPartsItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}
