// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/cohere-ai/cohere-go/v2/core"
	time "time"
)

type ChatRequest struct {
	// Accepts a string.
	// The chat message from the user to the model.
	Message string `json:"message"`
	// Defaults to `command`.
	//
	// The identifier of the model, which can be one of the existing Cohere models or the full ID for a [fine-tuned custom model](https://docs.cohere.com/docs/chat-fine-tuning).
	//
	// Compatible Cohere models are `command` and `command-light` as well as the experimental `command-nightly` and `command-light-nightly` variants. Read more about [Cohere models](https://docs.cohere.com/docs/models).
	Model *string `json:"model,omitempty"`
	// When specified, the default Cohere preamble will be replaced with the provided one.
	PreambleOverride *string `json:"preamble_override,omitempty"`
	// A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's `message`.
	ChatHistory []*ChatMessage `json:"chat_history,omitempty"`
	// An alternative to `chat_history`. Previous conversations can be resumed by providing the conversation's identifier. The contents of `message` and the model's response will be stored as part of this conversation.
	//
	// If a conversation with this id does not already exist, a new conversation will be created.
	ConversationId *string `json:"conversation_id,omitempty"`
	// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
	//
	// Dictates how the prompt will be constructed.
	//
	// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.
	//
	// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
	PromptTruncation *ChatRequestPromptTruncation `json:"prompt_truncation,omitempty"`
	// Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.
	//
	// When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).
	Connectors []*ChatConnector `json:"connectors,omitempty"`
	// Defaults to `false`.
	//
	// When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.
	SearchQueriesOnly *bool `json:"search_queries_only,omitempty"`
	// A list of relevant documents that the model can use to enrich its reply. See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.
	Documents []ChatDocument `json:"documents,omitempty"`
	// Defaults to `"accurate"`.
	//
	// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
	CitationQuality *ChatRequestCitationQuality `json:"citation_quality,omitempty"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	Temperature *float64 `json:"temperature,omitempty"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	MaxTokens *int `json:"max_tokens,omitempty"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty"`
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`. Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	PresencePenalty *float64 `json:"presence_penalty,omitempty"`
	stream          bool
}

func (c *ChatRequest) Stream() bool {
	return c.stream
}

func (c *ChatRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = ChatRequest(body)
	c.stream = false
	return nil
}

func (c *ChatRequest) MarshalJSON() ([]byte, error) {
	type embed ChatRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*c),
		Stream: false,
	}
	return json.Marshal(marshaler)
}

type ChatStreamRequest struct {
	// Accepts a string.
	// The chat message from the user to the model.
	Message string `json:"message"`
	// Defaults to `command`.
	//
	// The identifier of the model, which can be one of the existing Cohere models or the full ID for a [fine-tuned custom model](https://docs.cohere.com/docs/chat-fine-tuning).
	//
	// Compatible Cohere models are `command` and `command-light` as well as the experimental `command-nightly` and `command-light-nightly` variants. Read more about [Cohere models](https://docs.cohere.com/docs/models).
	Model *string `json:"model,omitempty"`
	// When specified, the default Cohere preamble will be replaced with the provided one.
	PreambleOverride *string `json:"preamble_override,omitempty"`
	// A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's `message`.
	ChatHistory []*ChatMessage `json:"chat_history,omitempty"`
	// An alternative to `chat_history`. Previous conversations can be resumed by providing the conversation's identifier. The contents of `message` and the model's response will be stored as part of this conversation.
	//
	// If a conversation with this id does not already exist, a new conversation will be created.
	ConversationId *string `json:"conversation_id,omitempty"`
	// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
	//
	// Dictates how the prompt will be constructed.
	//
	// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.
	//
	// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
	PromptTruncation *ChatStreamRequestPromptTruncation `json:"prompt_truncation,omitempty"`
	// Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.
	//
	// When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).
	Connectors []*ChatConnector `json:"connectors,omitempty"`
	// Defaults to `false`.
	//
	// When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.
	SearchQueriesOnly *bool `json:"search_queries_only,omitempty"`
	// A list of relevant documents that the model can use to enrich its reply. See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.
	Documents []ChatDocument `json:"documents,omitempty"`
	// Defaults to `"accurate"`.
	//
	// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
	CitationQuality *ChatStreamRequestCitationQuality `json:"citation_quality,omitempty"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	Temperature *float64 `json:"temperature,omitempty"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	MaxTokens *int `json:"max_tokens,omitempty"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty"`
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`. Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	PresencePenalty *float64 `json:"presence_penalty,omitempty"`
	stream          bool
}

func (c *ChatStreamRequest) Stream() bool {
	return c.stream
}

func (c *ChatStreamRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = ChatStreamRequest(body)
	c.stream = true
	return nil
}

func (c *ChatStreamRequest) MarshalJSON() ([]byte, error) {
	type embed ChatStreamRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*c),
		Stream: true,
	}
	return json.Marshal(marshaler)
}

type ClassifyRequest struct {
	// A list of up to 96 texts to be classified. Each one must be a non-empty string.
	// There is, however, no consistent, universal limit to the length a particular input can be. We perform classification on the first `x` tokens of each input, and `x` varies depending on which underlying model is powering classification. The maximum token length for each model is listed in the "max tokens" column [here](https://docs.cohere.com/docs/models).
	// Note: by default the `truncate` parameter is set to `END`, so tokens exceeding the limit will be automatically dropped. This behavior can be disabled by setting `truncate` to `NONE`, which will result in validation errors for longer texts.
	Inputs []string `json:"inputs,omitempty"`
	// An array of examples to provide context to the model. Each example is a text string and its associated label/class. Each unique label requires at least 2 examples associated with it; the maximum number of examples is 2500, and each example has a maximum length of 512 tokens. The values should be structured as `{text: "...",label: "..."}`.
	// Note: [Fine-tuned Models](https://docs.cohere.com/docs/classify-fine-tuning) trained on classification examples don't require the `examples` parameter to be passed in explicitly.
	Examples []*ClassifyExample `json:"examples,omitempty"`
	// The identifier of the model. Currently available models are `embed-multilingual-v2.0`, `embed-english-light-v2.0`, and `embed-english-v2.0` (default). Smaller "light" models are faster, while larger models will perform better. [Fine-tuned models](https://docs.cohere.com/docs/fine-tuning) can also be supplied with their full ID.
	Model *string `json:"model,omitempty"`
	// The ID of a custom playground preset. You can create presets in the [playground](https://dashboard.cohere.ai/playground/classify?model=large). If you use a preset, all other parameters become optional, and any included parameters will override the preset's parameters.
	Preset *string `json:"preset,omitempty"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *ClassifyRequestTruncate `json:"truncate,omitempty"`
}

type DetokenizeRequest struct {
	// The list of tokens to be detokenized.
	Tokens []int `json:"tokens,omitempty"`
	// An optional parameter to provide the model name. This will ensure that the detokenization is done by the tokenizer used by that model.
	Model *string `json:"model,omitempty"`
}

type EmbedRequest struct {
	// An array of strings for the model to embed. Maximum number of texts per call is `96`. We recommend reducing the length of each text to be under `512` tokens for optimal quality.
	Texts []string `json:"texts,omitempty"`
	// Defaults to embed-english-v2.0
	//
	// The identifier of the model. Smaller "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
	//
	// Available models and corresponding embedding dimensions:
	//
	// * `embed-english-v3.0`  1024
	// * `embed-multilingual-v3.0`  1024
	// * `embed-english-light-v3.0`  384
	// * `embed-multilingual-light-v3.0`  384
	//
	// * `embed-english-v2.0`  4096
	// * `embed-english-light-v2.0`  1024
	// * `embed-multilingual-v2.0`  768
	Model     *string         `json:"model,omitempty"`
	InputType *EmbedInputType `json:"input_type,omitempty"`
	// Specifies the types of embeddings you want to get back. Not required and default is None, which returns the Embed Floats response type. Can be one or more of the following types.
	//
	// * `"float"`: Use this when you want to get back the default float embeddings. Valid for all models.
	// * `"int8"`: Use this when you want to get back signed int8 embeddings. Valid for only v3 models.
	// * `"uint8"`: Use this when you want to get back unsigned int8 embeddings. Valid for only v3 models.
	// * `"binary"`: Use this when you want to get back signed binary embeddings. Valid for only v3 models.
	// * `"ubinary"`: Use this when you want to get back unsigned binary embeddings. Valid for only v3 models.
	EmbeddingTypes []EmbedRequestEmbeddingTypesItem `json:"embedding_types,omitempty"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *EmbedRequestTruncate `json:"truncate,omitempty"`
}

type GenerateRequest struct {
	// The input text that serves as the starting point for generating the response.
	// Note: The prompt will be pre-processed and modified before reaching the model.
	Prompt string `json:"prompt"`
	// The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
	// Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
	Model *string `json:"model,omitempty"`
	// The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.
	NumGenerations *int `json:"num_generations,omitempty"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	//
	// This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.
	//
	// Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.
	MaxTokens *int `json:"max_tokens,omitempty"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *GenerateRequestTruncate `json:"truncate,omitempty"`
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
	// Defaults to `0.75`, min value of `0.0`, max value of `5.0`.
	Temperature *float64 `json:"temperature,omitempty"`
	// Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
	// When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.
	Preset *string `json:"preset,omitempty"`
	// The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.
	EndSequences []string `json:"end_sequences,omitempty"`
	// The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.
	StopSequences []string `json:"stop_sequences,omitempty"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty"`
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	PresencePenalty *float64 `json:"presence_penalty,omitempty"`
	// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
	//
	// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
	//
	// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
	ReturnLikelihoods *GenerateRequestReturnLikelihoods `json:"return_likelihoods,omitempty"`
	// Certain models support the `logit_bias` parameter.
	//
	// Used to prevent the model from generating unwanted tokens or to incentivize it to include desired tokens. The format is `{token_id: bias}` where bias is a float between -10 and 10. Tokens can be obtained from text using [Tokenize](/reference/tokenize).
	//
	// For example, if the value `{'11': -10}` is provided, the model will be very unlikely to include the token 11 (`"\n"`, the newline character) anywhere in the generated text. In contrast `{'11': 10}` will result in generations that nearly only contain that token. Values between -10 and 10 will proportionally affect the likelihood of the token appearing in the generated text.
	LogitBias map[string]float64 `json:"logit_bias,omitempty"`
	// When enabled, the user's prompt will be sent to the model without any pre-processing.
	RawPrompting *bool `json:"raw_prompting,omitempty"`
	stream       bool
}

func (g *GenerateRequest) Stream() bool {
	return g.stream
}

func (g *GenerateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*g = GenerateRequest(body)
	g.stream = false
	return nil
}

func (g *GenerateRequest) MarshalJSON() ([]byte, error) {
	type embed GenerateRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*g),
		Stream: false,
	}
	return json.Marshal(marshaler)
}

type GenerateStreamRequest struct {
	// The input text that serves as the starting point for generating the response.
	// Note: The prompt will be pre-processed and modified before reaching the model.
	Prompt string `json:"prompt"`
	// The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
	// Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
	Model *string `json:"model,omitempty"`
	// The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.
	NumGenerations *int `json:"num_generations,omitempty"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	//
	// This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.
	//
	// Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.
	MaxTokens *int `json:"max_tokens,omitempty"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *GenerateStreamRequestTruncate `json:"truncate,omitempty"`
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
	// Defaults to `0.75`, min value of `0.0`, max value of `5.0`.
	Temperature *float64 `json:"temperature,omitempty"`
	// Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
	// When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.
	Preset *string `json:"preset,omitempty"`
	// The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.
	EndSequences []string `json:"end_sequences,omitempty"`
	// The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.
	StopSequences []string `json:"stop_sequences,omitempty"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty"`
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	PresencePenalty *float64 `json:"presence_penalty,omitempty"`
	// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
	//
	// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
	//
	// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
	ReturnLikelihoods *GenerateStreamRequestReturnLikelihoods `json:"return_likelihoods,omitempty"`
	// Certain models support the `logit_bias` parameter.
	//
	// Used to prevent the model from generating unwanted tokens or to incentivize it to include desired tokens. The format is `{token_id: bias}` where bias is a float between -10 and 10. Tokens can be obtained from text using [Tokenize](/reference/tokenize).
	//
	// For example, if the value `{'11': -10}` is provided, the model will be very unlikely to include the token 11 (`"\n"`, the newline character) anywhere in the generated text. In contrast `{'11': 10}` will result in generations that nearly only contain that token. Values between -10 and 10 will proportionally affect the likelihood of the token appearing in the generated text.
	LogitBias map[string]float64 `json:"logit_bias,omitempty"`
	// When enabled, the user's prompt will be sent to the model without any pre-processing.
	RawPrompting *bool `json:"raw_prompting,omitempty"`
	stream       bool
}

func (g *GenerateStreamRequest) Stream() bool {
	return g.stream
}

func (g *GenerateStreamRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*g = GenerateStreamRequest(body)
	g.stream = true
	return nil
}

func (g *GenerateStreamRequest) MarshalJSON() ([]byte, error) {
	type embed GenerateStreamRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*g),
		Stream: true,
	}
	return json.Marshal(marshaler)
}

type RerankRequest struct {
	// The identifier of the model to use, one of : `rerank-english-v2.0`, `rerank-multilingual-v2.0`
	Model *string `json:"model,omitempty"`
	// The search query
	Query string `json:"query"`
	// A list of document objects or strings to rerank.
	// If a document is provided the text fields is required and all other fields will be preserved in the response.
	//
	// The total max chunks (length of documents * max_chunks_per_doc) must be less than 10000.
	//
	// We recommend a maximum of 1,000 documents for optimal endpoint performance.
	Documents []*RerankRequestDocumentsItem `json:"documents,omitempty"`
	// The number of most relevant documents or indices to return, defaults to the length of the documents
	TopN *int `json:"top_n,omitempty"`
	// - If false, returns results without the doc text - the api will return a list of {index, relevance score} where index is inferred from the list passed into the request.
	// - If true, returns results with the doc text passed in - the api will return an ordered list of {index, text, relevance score} where index + text refers to the list passed into the request.
	ReturnDocuments *bool `json:"return_documents,omitempty"`
	// The maximum number of chunks to produce internally from a document
	MaxChunksPerDoc *int `json:"max_chunks_per_doc,omitempty"`
}

type SummarizeRequest struct {
	// The text to generate a summary for. Can be up to 100,000 characters long. Currently the only supported language is English.
	Text string `json:"text"`
	// One of `short`, `medium`, `long`, or `auto` defaults to `auto`. Indicates the approximate length of the summary. If `auto` is selected, the best option will be picked based on the input text.
	Length *SummarizeRequestLength `json:"length,omitempty"`
	// One of `paragraph`, `bullets`, or `auto`, defaults to `auto`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If `auto` is selected, the best option will be picked based on the input text.
	Format *SummarizeRequestFormat `json:"format,omitempty"`
	// The identifier of the model to generate the summary with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental). Smaller, "light" models are faster, while larger models will perform better.
	Model *string `json:"model,omitempty"`
	// One of `low`, `medium`, `high`, or `auto`, defaults to `auto`. Controls how close to the original text the summary is. `high` extractiveness summaries will lean towards reusing sentences verbatim, while `low` extractiveness summaries will tend to paraphrase more. If `auto` is selected, the best option will be picked based on the input text.
	Extractiveness *SummarizeRequestExtractiveness `json:"extractiveness,omitempty"`
	// Ranges from 0 to 5. Controls the randomness of the output. Lower values tend to generate more “predictable” output, while higher values tend to generate more “creative” output. The sweet spot is typically between 0 and 1.
	Temperature *float64 `json:"temperature,omitempty"`
	// A free-form instruction for modifying how the summaries get generated. Should complete the sentence "Generate a summary _". Eg. "focusing on the next steps" or "written by Yoda"
	AdditionalCommand *string `json:"additional_command,omitempty"`
}

type TokenizeRequest struct {
	// The string to be tokenized, the minimum text length is 1 character, and the maximum text length is 65536 characters.
	Text string `json:"text"`
	// An optional parameter to provide the model name. This will ensure that the tokenization uses the tokenizer used by that model.
	Model *string `json:"model,omitempty"`
}

type ApiMeta struct {
	ApiVersion  *ApiMetaApiVersion  `json:"api_version,omitempty"`
	BilledUnits *ApiMetaBilledUnits `json:"billed_units,omitempty"`
	Warnings    []string            `json:"warnings,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMeta(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMeta) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiMetaApiVersion struct {
	Version        string `json:"version"`
	IsDeprecated   *bool  `json:"is_deprecated,omitempty"`
	IsExperimental *bool  `json:"is_experimental,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiMetaApiVersion) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMetaApiVersion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMetaApiVersion(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMetaApiVersion) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiMetaBilledUnits struct {
	// The number of billed input tokens.
	InputTokens *float64 `json:"input_tokens,omitempty"`
	// The number of billed output tokens.
	OutputTokens *float64 `json:"output_tokens,omitempty"`
	// The number of billed search units.
	SearchUnits *float64 `json:"search_units,omitempty"`
	// The number of billed classifications units.
	Classifications *float64 `json:"classifications,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiMetaBilledUnits) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMetaBilledUnits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMetaBilledUnits(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMetaBilledUnits) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The token_type specifies the way the token is passed in the Authorization header. Valid values are "bearer", "basic", and "noscheme".
type AuthTokenType string

const (
	AuthTokenTypeBearer   AuthTokenType = "bearer"
	AuthTokenTypeBasic    AuthTokenType = "basic"
	AuthTokenTypeNoscheme AuthTokenType = "noscheme"
)

func NewAuthTokenTypeFromString(s string) (AuthTokenType, error) {
	switch s {
	case "bearer":
		return AuthTokenTypeBearer, nil
	case "basic":
		return AuthTokenTypeBasic, nil
	case "noscheme":
		return AuthTokenTypeNoscheme, nil
	}
	var t AuthTokenType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthTokenType) Ptr() *AuthTokenType {
	return &a
}

// A section of the generated reply which cites external knowledge.
type ChatCitation struct {
	// The index of text that the citation starts at, counting from zero. For example, a generation of `Hello, world!` with a citation on `world` would have a start value of `7`. This is because the citation starts at `w`, which is the seventh character.
	Start int `json:"start"`
	// The index of text that the citation ends after, counting from zero. For example, a generation of `Hello, world!` with a citation on `world` would have an end value of `11`. This is because the citation ends after `d`, which is the eleventh character.
	End int `json:"end"`
	// The text of the citation. For example, a generation of `Hello, world!` with a citation of `world` would have a text value of `world`.
	Text string `json:"text"`
	// Identifiers of documents cited by this section of the generated reply.
	DocumentIds []string `json:"document_ids,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatCitation) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCitation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCitation(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCitation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatCitationGenerationEvent struct {
	// Citations for the generated reply.
	Citations []*ChatCitation `json:"citations,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatCitationGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCitationGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCitationGenerationEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCitationGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The connector used for fetching documents.
type ChatConnector struct {
	// The identifier of the connector.
	Id string `json:"id"`
	// An optional override to set the token that Cohere passes to the connector in the Authorization header.
	UserAccessToken *string `json:"user_access_token,omitempty"`
	// An optional override to set whether or not the request continues if this connector fails.
	ContinueOnFailure *bool `json:"continue_on_failure,omitempty"`
	// Provides the connector with different settings at request time. The key/value pairs of this object are specific to each connector.
	//
	// The supported options are:
	//
	// **web-search**
	//
	// **site** - The web search results will be restricted to this domain (and TLD) when specified. Only a single domain is specified, and subdomains are also accepted.
	// Examples:
	//
	// - `{"options": {"site": "cohere.com"}}` would restrict the results to all subdomains at cohere.com
	// - `{"options": {"site": "txt.cohere.com"}}` would restrict the results to `txt.cohere.com`
	Options map[string]interface{} `json:"options,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatConnector) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatConnector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatConnector(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatConnector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Relevant information that could be used by the model to generate a more accurate reply.
// The contents of each document are generally short (under 300 words), and are passed in the form of a
// dictionary of strings. Some suggested keys are "text", "author", "date". Both the key name and the value will be
// passed to the model.
type ChatDocument = map[string]string

// A single message in a chat history. Contains the role of the sender, the text contents of the message, and optionally a username.
type ChatMessage struct {
	Role     ChatMessageRole `json:"role,omitempty"`
	Message  string          `json:"message"`
	UserName *string         `json:"user_name,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessage(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatMessageRole string

const (
	ChatMessageRoleChatbot ChatMessageRole = "CHATBOT"
	ChatMessageRoleUser    ChatMessageRole = "USER"
)

func NewChatMessageRoleFromString(s string) (ChatMessageRole, error) {
	switch s {
	case "CHATBOT":
		return ChatMessageRoleChatbot, nil
	case "USER":
		return ChatMessageRoleUser, nil
	}
	var t ChatMessageRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatMessageRole) Ptr() *ChatMessageRole {
	return &c
}

// Defaults to `"accurate"`.
//
// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
type ChatRequestCitationQuality string

const (
	ChatRequestCitationQualityFast     ChatRequestCitationQuality = "fast"
	ChatRequestCitationQualityAccurate ChatRequestCitationQuality = "accurate"
)

func NewChatRequestCitationQualityFromString(s string) (ChatRequestCitationQuality, error) {
	switch s {
	case "fast":
		return ChatRequestCitationQualityFast, nil
	case "accurate":
		return ChatRequestCitationQualityAccurate, nil
	}
	var t ChatRequestCitationQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatRequestCitationQuality) Ptr() *ChatRequestCitationQuality {
	return &c
}

// (internal) Overrides specified parts of the default Chat or RAG preamble. It is recommended that these options only be used in specific scenarios where the defaults are not adequate.
type ChatRequestPromptOverride struct {
	Preamble        interface{} `json:"preamble,omitempty"`
	TaskDescription interface{} `json:"task_description,omitempty"`
	StyleGuide      interface{} `json:"style_guide,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatRequestPromptOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatRequestPromptOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatRequestPromptOverride(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatRequestPromptOverride) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
//
// Dictates how the prompt will be constructed.
//
// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.
//
// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
type ChatRequestPromptTruncation string

const (
	ChatRequestPromptTruncationOff  ChatRequestPromptTruncation = "OFF"
	ChatRequestPromptTruncationAuto ChatRequestPromptTruncation = "AUTO"
)

func NewChatRequestPromptTruncationFromString(s string) (ChatRequestPromptTruncation, error) {
	switch s {
	case "OFF":
		return ChatRequestPromptTruncationOff, nil
	case "AUTO":
		return ChatRequestPromptTruncationAuto, nil
	}
	var t ChatRequestPromptTruncation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatRequestPromptTruncation) Ptr() *ChatRequestPromptTruncation {
	return &c
}

// (internal) Sets inference and model options for RAG search query and tool use generations. Defaults are used when options are not specified here, meaning that other parameters outside of search_options are ignored (such as model= or temperature=).
type ChatRequestSearchOptions struct {
	Model       interface{} `json:"model,omitempty"`
	Temperature interface{} `json:"temperature,omitempty"`
	MaxTokens   interface{} `json:"max_tokens,omitempty"`
	Preamble    interface{} `json:"preamble,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatRequestSearchOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatRequestSearchOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatRequestSearchOptions(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatRequestSearchOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatSearchQueriesGenerationEvent struct {
	// Generated search queries, meant to be used as part of the RAG flow.
	SearchQueries []*ChatSearchQuery `json:"search_queries,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchQueriesGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchQueriesGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchQueriesGenerationEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchQueriesGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The generated search query. Contains the text of the query and a unique identifier for the query.
type ChatSearchQuery struct {
	// The text of the search query.
	Text string `json:"text"`
	// Unique identifier for the generated search query. Useful for submitting feedback.
	GenerationId string `json:"generation_id"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchQuery(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchQuery) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatSearchResult struct {
	SearchQuery *ChatSearchQuery `json:"search_query,omitempty"`
	// The connector from which this result comes from.
	Connector *ChatSearchResultConnector `json:"connector,omitempty"`
	// Identifiers of documents found by this search query.
	DocumentIds []string `json:"document_ids,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchResult(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The connector used for fetching documents.
type ChatSearchResultConnector struct {
	// The identifier of the connector.
	Id string `json:"id"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchResultConnector) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchResultConnector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchResultConnector(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchResultConnector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatSearchResultsEvent struct {
	// Conducted searches and the ids of documents retrieved from each of them.
	SearchResults []*ChatSearchResult `json:"search_results,omitempty"`
	// Documents fetched from searches or provided by the user.
	Documents []ChatDocument `json:"documents,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchResultsEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchResultsEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchResultsEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchResultsEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatStreamEndEvent struct {
	// - `COMPLETE` - the model sent back a finished reply
	// - `ERROR_LIMIT` - the reply was cut off because the model reached the maximum number of tokens for its context length
	// - `MAX_TOKENS` - the reply was cut off because the model reached the maximum number of tokens specified by the max_tokens parameter
	// - `ERROR` - something went wrong when generating the reply
	// - `ERROR_TOXIC` - the model generated a reply that was deemed toxic
	FinishReason ChatStreamEndEventFinishReason `json:"finish_reason,omitempty"`
	// The consolidated response from the model. Contains the generated reply and all the other information streamed back in the previous events.
	Response *ChatStreamEndEventResponse `json:"response,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatStreamEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamEndEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamEndEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// - `COMPLETE` - the model sent back a finished reply
// - `ERROR_LIMIT` - the reply was cut off because the model reached the maximum number of tokens for its context length
// - `MAX_TOKENS` - the reply was cut off because the model reached the maximum number of tokens specified by the max_tokens parameter
// - `ERROR` - something went wrong when generating the reply
// - `ERROR_TOXIC` - the model generated a reply that was deemed toxic
type ChatStreamEndEventFinishReason string

const (
	ChatStreamEndEventFinishReasonComplete   ChatStreamEndEventFinishReason = "COMPLETE"
	ChatStreamEndEventFinishReasonErrorLimit ChatStreamEndEventFinishReason = "ERROR_LIMIT"
	ChatStreamEndEventFinishReasonMaxTokens  ChatStreamEndEventFinishReason = "MAX_TOKENS"
	ChatStreamEndEventFinishReasonError      ChatStreamEndEventFinishReason = "ERROR"
	ChatStreamEndEventFinishReasonErrorToxic ChatStreamEndEventFinishReason = "ERROR_TOXIC"
)

func NewChatStreamEndEventFinishReasonFromString(s string) (ChatStreamEndEventFinishReason, error) {
	switch s {
	case "COMPLETE":
		return ChatStreamEndEventFinishReasonComplete, nil
	case "ERROR_LIMIT":
		return ChatStreamEndEventFinishReasonErrorLimit, nil
	case "MAX_TOKENS":
		return ChatStreamEndEventFinishReasonMaxTokens, nil
	case "ERROR":
		return ChatStreamEndEventFinishReasonError, nil
	case "ERROR_TOXIC":
		return ChatStreamEndEventFinishReasonErrorToxic, nil
	}
	var t ChatStreamEndEventFinishReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatStreamEndEventFinishReason) Ptr() *ChatStreamEndEventFinishReason {
	return &c
}

// The consolidated response from the model. Contains the generated reply and all the other information streamed back in the previous events.
type ChatStreamEndEventResponse struct {
	typeName                  string
	NonStreamedChatResponse   *NonStreamedChatResponse
	SearchQueriesOnlyResponse *SearchQueriesOnlyResponse
}

func NewChatStreamEndEventResponseFromNonStreamedChatResponse(value *NonStreamedChatResponse) *ChatStreamEndEventResponse {
	return &ChatStreamEndEventResponse{typeName: "nonStreamedChatResponse", NonStreamedChatResponse: value}
}

func NewChatStreamEndEventResponseFromSearchQueriesOnlyResponse(value *SearchQueriesOnlyResponse) *ChatStreamEndEventResponse {
	return &ChatStreamEndEventResponse{typeName: "searchQueriesOnlyResponse", SearchQueriesOnlyResponse: value}
}

func (c *ChatStreamEndEventResponse) UnmarshalJSON(data []byte) error {
	valueNonStreamedChatResponse := new(NonStreamedChatResponse)
	if err := json.Unmarshal(data, &valueNonStreamedChatResponse); err == nil {
		c.typeName = "nonStreamedChatResponse"
		c.NonStreamedChatResponse = valueNonStreamedChatResponse
		return nil
	}
	valueSearchQueriesOnlyResponse := new(SearchQueriesOnlyResponse)
	if err := json.Unmarshal(data, &valueSearchQueriesOnlyResponse); err == nil {
		c.typeName = "searchQueriesOnlyResponse"
		c.SearchQueriesOnlyResponse = valueSearchQueriesOnlyResponse
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ChatStreamEndEventResponse) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "nonStreamedChatResponse":
		return json.Marshal(c.NonStreamedChatResponse)
	case "searchQueriesOnlyResponse":
		return json.Marshal(c.SearchQueriesOnlyResponse)
	}
}

type ChatStreamEndEventResponseVisitor interface {
	VisitNonStreamedChatResponse(*NonStreamedChatResponse) error
	VisitSearchQueriesOnlyResponse(*SearchQueriesOnlyResponse) error
}

func (c *ChatStreamEndEventResponse) Accept(visitor ChatStreamEndEventResponseVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "nonStreamedChatResponse":
		return visitor.VisitNonStreamedChatResponse(c.NonStreamedChatResponse)
	case "searchQueriesOnlyResponse":
		return visitor.VisitSearchQueriesOnlyResponse(c.SearchQueriesOnlyResponse)
	}
}

type ChatStreamEvent struct {
	_rawJSON json.RawMessage
}

func (c *ChatStreamEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `"accurate"`.
//
// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
type ChatStreamRequestCitationQuality string

const (
	ChatStreamRequestCitationQualityFast     ChatStreamRequestCitationQuality = "fast"
	ChatStreamRequestCitationQualityAccurate ChatStreamRequestCitationQuality = "accurate"
)

func NewChatStreamRequestCitationQualityFromString(s string) (ChatStreamRequestCitationQuality, error) {
	switch s {
	case "fast":
		return ChatStreamRequestCitationQualityFast, nil
	case "accurate":
		return ChatStreamRequestCitationQualityAccurate, nil
	}
	var t ChatStreamRequestCitationQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatStreamRequestCitationQuality) Ptr() *ChatStreamRequestCitationQuality {
	return &c
}

// (internal) Overrides specified parts of the default Chat or RAG preamble. It is recommended that these options only be used in specific scenarios where the defaults are not adequate.
type ChatStreamRequestPromptOverride struct {
	Preamble        interface{} `json:"preamble,omitempty"`
	TaskDescription interface{} `json:"task_description,omitempty"`
	StyleGuide      interface{} `json:"style_guide,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatStreamRequestPromptOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamRequestPromptOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamRequestPromptOverride(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamRequestPromptOverride) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
//
// Dictates how the prompt will be constructed.
//
// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.
//
// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
type ChatStreamRequestPromptTruncation string

const (
	ChatStreamRequestPromptTruncationOff  ChatStreamRequestPromptTruncation = "OFF"
	ChatStreamRequestPromptTruncationAuto ChatStreamRequestPromptTruncation = "AUTO"
)

func NewChatStreamRequestPromptTruncationFromString(s string) (ChatStreamRequestPromptTruncation, error) {
	switch s {
	case "OFF":
		return ChatStreamRequestPromptTruncationOff, nil
	case "AUTO":
		return ChatStreamRequestPromptTruncationAuto, nil
	}
	var t ChatStreamRequestPromptTruncation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatStreamRequestPromptTruncation) Ptr() *ChatStreamRequestPromptTruncation {
	return &c
}

// (internal) Sets inference and model options for RAG search query and tool use generations. Defaults are used when options are not specified here, meaning that other parameters outside of search_options are ignored (such as model= or temperature=).
type ChatStreamRequestSearchOptions struct {
	Model       interface{} `json:"model,omitempty"`
	Temperature interface{} `json:"temperature,omitempty"`
	MaxTokens   interface{} `json:"max_tokens,omitempty"`
	Preamble    interface{} `json:"preamble,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatStreamRequestSearchOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamRequestSearchOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamRequestSearchOptions(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamRequestSearchOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatStreamStartEvent struct {
	// Unique identifier for the generated reply. Useful for submitting feedback.
	GenerationId string `json:"generation_id"`

	_rawJSON json.RawMessage
}

func (c *ChatStreamStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamStartEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamStartEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatTextGenerationEvent struct {
	// The next batch of text generated by the model.
	Text string `json:"text"`

	_rawJSON json.RawMessage
}

func (c *ChatTextGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatTextGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatTextGenerationEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatTextGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClassifyExample struct {
	Text  *string `json:"text,omitempty"`
	Label *string `json:"label,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClassifyExample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyExample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyExample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type ClassifyRequestTruncate string

const (
	ClassifyRequestTruncateNone  ClassifyRequestTruncate = "NONE"
	ClassifyRequestTruncateStart ClassifyRequestTruncate = "START"
	ClassifyRequestTruncateEnd   ClassifyRequestTruncate = "END"
)

func NewClassifyRequestTruncateFromString(s string) (ClassifyRequestTruncate, error) {
	switch s {
	case "NONE":
		return ClassifyRequestTruncateNone, nil
	case "START":
		return ClassifyRequestTruncateStart, nil
	case "END":
		return ClassifyRequestTruncateEnd, nil
	}
	var t ClassifyRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClassifyRequestTruncate) Ptr() *ClassifyRequestTruncate {
	return &c
}

type ClassifyResponse struct {
	Id              string                                 `json:"id"`
	Classifications []*ClassifyResponseClassificationsItem `json:"classifications,omitempty"`
	Meta            *ApiMeta                               `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClassifyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClassifyResponseClassificationsItem struct {
	Id string `json:"id"`
	// The input text that was classified
	Input *string `json:"input,omitempty"`
	// The predicted label for the associated query (only filled for single-label models)
	Prediction *string `json:"prediction,omitempty"`
	// An array containing the predicted labels for the associated query (only filled for single-label classification)
	Predictions []string `json:"predictions,omitempty"`
	// The confidence score for the top predicted class (only filled for single-label classification)
	Confidence *float64 `json:"confidence,omitempty"`
	// An array containing the confidence scores of all the predictions in the same order
	Confidences []float64 `json:"confidences,omitempty"`
	// A map containing each label and its confidence score according to the classifier. All the confidence scores add up to 1 for single-label classification. For multi-label classification the label confidences are independent of each other, so they don't have to sum up to 1.
	Labels map[string]*ClassifyResponseClassificationsItemLabelsValue `json:"labels,omitempty"`
	// The type of classification performed
	ClassificationType ClassifyResponseClassificationsItemClassificationType `json:"classification_type,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClassifyResponseClassificationsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyResponseClassificationsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyResponseClassificationsItem(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyResponseClassificationsItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of classification performed
type ClassifyResponseClassificationsItemClassificationType string

const (
	ClassifyResponseClassificationsItemClassificationTypeSingleLabel ClassifyResponseClassificationsItemClassificationType = "single-label"
	ClassifyResponseClassificationsItemClassificationTypeMultiLabel  ClassifyResponseClassificationsItemClassificationType = "multi-label"
)

func NewClassifyResponseClassificationsItemClassificationTypeFromString(s string) (ClassifyResponseClassificationsItemClassificationType, error) {
	switch s {
	case "single-label":
		return ClassifyResponseClassificationsItemClassificationTypeSingleLabel, nil
	case "multi-label":
		return ClassifyResponseClassificationsItemClassificationTypeMultiLabel, nil
	}
	var t ClassifyResponseClassificationsItemClassificationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClassifyResponseClassificationsItemClassificationType) Ptr() *ClassifyResponseClassificationsItemClassificationType {
	return &c
}

type ClassifyResponseClassificationsItemLabelsValue struct {
	Confidence *float64 `json:"confidence,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClassifyResponseClassificationsItemLabelsValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyResponseClassificationsItemLabelsValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyResponseClassificationsItemLabelsValue(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyResponseClassificationsItemLabelsValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A connector allows you to integrate data sources with the '/chat' endpoint to create grounded generations with citations to the data source.
// documents to help answer users.
type Connector struct {
	// The unique identifier of the connector (used in both `/connectors` & `/chat` endpoints).
	// This is automatically created from the name of the connector upon registration.
	Id string `json:"id"`
	// The organization to which this connector belongs. This is automatically set to
	// the organization of the user who created the connector.
	OrganizationId *string `json:"organization_id,omitempty"`
	// A human-readable name for the connector.
	Name string `json:"name"`
	// A description of the connector.
	Description *string `json:"description,omitempty"`
	// The URL of the connector that will be used to search for documents.
	Url *string `json:"url,omitempty"`
	// The UTC time at which the connector was created.
	CreatedAt time.Time `json:"created_at"`
	// The UTC time at which the connector was last updated.
	UpdatedAt time.Time `json:"updated_at"`
	// A list of fields to exclude from the prompt (fields remain in the document).
	Excludes []string `json:"excludes,omitempty"`
	// The type of authentication/authorization used by the connector. Possible values: [oauth, service_auth]
	AuthType *string `json:"auth_type,omitempty"`
	// The OAuth 2.0 configuration for the connector.
	Oauth *ConnectorOAuth `json:"oauth,omitempty"`
	// The OAuth status for the user making the request. One of ["valid", "expired", ""]. Empty string (field is omitted) means the user has not authorized the connector yet.
	AuthStatus *ConnectorAuthStatus `json:"auth_status,omitempty"`
	// Whether the connector is active or not.
	Active *bool `json:"active,omitempty"`
	// Whether a chat request should continue or not if the request to this connector fails.
	ContinueOnFailure *bool `json:"continue_on_failure,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Connector) UnmarshalJSON(data []byte) error {
	type unmarshaler Connector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Connector(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Connector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The OAuth status for the user making the request. One of ["valid", "expired", ""]. Empty string (field is omitted) means the user has not authorized the connector yet.
type ConnectorAuthStatus string

const (
	ConnectorAuthStatusValid   ConnectorAuthStatus = "valid"
	ConnectorAuthStatusExpired ConnectorAuthStatus = "expired"
)

func NewConnectorAuthStatusFromString(s string) (ConnectorAuthStatus, error) {
	switch s {
	case "valid":
		return ConnectorAuthStatusValid, nil
	case "expired":
		return ConnectorAuthStatusExpired, nil
	}
	var t ConnectorAuthStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectorAuthStatus) Ptr() *ConnectorAuthStatus {
	return &c
}

type ConnectorOAuth struct {
	// The OAuth 2.0 /authorize endpoint to use when users authorize the connector.
	AuthorizeUrl string `json:"authorize_url"`
	// The OAuth 2.0 /token endpoint to use when users authorize the connector.
	TokenUrl string `json:"token_url"`
	// The OAuth scopes to request when users authorize the connector.
	Scope *string `json:"scope,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectorOAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectorOAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectorOAuth(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectorOAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorOAuth struct {
	// The OAuth 2.0 client ID. This fields is encrypted at rest.
	ClientId *string `json:"client_id,omitempty"`
	// The OAuth 2.0 client Secret. This field is encrypted at rest and never returned in a response.
	ClientSecret *string `json:"client_secret,omitempty"`
	// The OAuth 2.0 /authorize endpoint to use when users authorize the connector.
	AuthorizeUrl *string `json:"authorize_url,omitempty"`
	// The OAuth 2.0 /token endpoint to use when users authorize the connector.
	TokenUrl *string `json:"token_url,omitempty"`
	// The OAuth scopes to request when users authorize the connector.
	Scope *string `json:"scope,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectorOAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorOAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorOAuth(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorOAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorResponse struct {
	Connector *Connector `json:"connector,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorServiceAuth struct {
	Type AuthTokenType `json:"type,omitempty"`
	// The token that will be used in the HTTP Authorization header when making requests to the connector. This field is encrypted at rest and never returned in a response.
	Token string `json:"token"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectorServiceAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorServiceAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorServiceAuth(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorServiceAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response from creating an embed job.
type CreateEmbedJobResponse struct {
	JobId string   `json:"job_id"`
	Meta  *ApiMeta `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateEmbedJobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateEmbedJobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateEmbedJobResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEmbedJobResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Dataset struct {
	// The dataset ID
	Id string `json:"id"`
	// The name of the dataset
	Name string `json:"name"`
	// The creation date
	CreatedAt time.Time `json:"created_at"`
	// The last update date
	UpdatedAt        time.Time               `json:"updated_at"`
	DatasetType      DatasetType             `json:"dataset_type,omitempty"`
	ValidationStatus DatasetValidationStatus `json:"validation_status,omitempty"`
	// Errors found during validation
	ValidationError *string `json:"validation_error,omitempty"`
	// the avro schema of the dataset
	Schema         *string  `json:"schema,omitempty"`
	RequiredFields []string `json:"required_fields,omitempty"`
	PreserveFields []string `json:"preserve_fields,omitempty"`
	// the underlying files that make up the dataset
	DatasetParts []*DatasetPart `json:"dataset_parts,omitempty"`
	// warnings found during validation
	ValidationWarnings []string `json:"validation_warnings,omitempty"`

	_rawJSON json.RawMessage
}

func (d *Dataset) UnmarshalJSON(data []byte) error {
	type unmarshaler Dataset
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Dataset(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Dataset) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DatasetPart struct {
	// The dataset part ID
	Id string `json:"id"`
	// The name of the dataset part
	Name string `json:"name"`
	// The download url of the file
	Url *string `json:"url,omitempty"`
	// The index of the file
	Index *int `json:"index,omitempty"`
	// The size of the file in bytes
	SizeBytes *int `json:"size_bytes,omitempty"`
	// The number of rows in the file
	NumRows *int `json:"num_rows,omitempty"`
	// The download url of the original file
	OriginalUrl *string `json:"original_url,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DatasetPart) UnmarshalJSON(data []byte) error {
	type unmarshaler DatasetPart
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DatasetPart(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DatasetPart) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The type of the dataset
type DatasetType string

const (
	DatasetTypeEmbedInput                             DatasetType = "embed-input"
	DatasetTypeEmbedResult                            DatasetType = "embed-result"
	DatasetTypeClusterResult                          DatasetType = "cluster-result"
	DatasetTypeClusterOutliers                        DatasetType = "cluster-outliers"
	DatasetTypeRerankerFinetuneInput                  DatasetType = "reranker-finetune-input"
	DatasetTypePromptCompletionFinetuneInput          DatasetType = "prompt-completion-finetune-input"
	DatasetTypeSingleLabelClassificationFinetuneInput DatasetType = "single-label-classification-finetune-input"
	DatasetTypeChatFinetuneInput                      DatasetType = "chat-finetune-input"
	DatasetTypeMultiLabelClassificationFinetuneInput  DatasetType = "multi-label-classification-finetune-input"
)

func NewDatasetTypeFromString(s string) (DatasetType, error) {
	switch s {
	case "embed-input":
		return DatasetTypeEmbedInput, nil
	case "embed-result":
		return DatasetTypeEmbedResult, nil
	case "cluster-result":
		return DatasetTypeClusterResult, nil
	case "cluster-outliers":
		return DatasetTypeClusterOutliers, nil
	case "reranker-finetune-input":
		return DatasetTypeRerankerFinetuneInput, nil
	case "prompt-completion-finetune-input":
		return DatasetTypePromptCompletionFinetuneInput, nil
	case "single-label-classification-finetune-input":
		return DatasetTypeSingleLabelClassificationFinetuneInput, nil
	case "chat-finetune-input":
		return DatasetTypeChatFinetuneInput, nil
	case "multi-label-classification-finetune-input":
		return DatasetTypeMultiLabelClassificationFinetuneInput, nil
	}
	var t DatasetType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatasetType) Ptr() *DatasetType {
	return &d
}

// The validation status of the dataset
type DatasetValidationStatus string

const (
	DatasetValidationStatusUnknown    DatasetValidationStatus = "unknown"
	DatasetValidationStatusQueued     DatasetValidationStatus = "queued"
	DatasetValidationStatusProcessing DatasetValidationStatus = "processing"
	DatasetValidationStatusFailed     DatasetValidationStatus = "failed"
	DatasetValidationStatusValidated  DatasetValidationStatus = "validated"
	DatasetValidationStatusSkipped    DatasetValidationStatus = "skipped"
)

func NewDatasetValidationStatusFromString(s string) (DatasetValidationStatus, error) {
	switch s {
	case "unknown":
		return DatasetValidationStatusUnknown, nil
	case "queued":
		return DatasetValidationStatusQueued, nil
	case "processing":
		return DatasetValidationStatusProcessing, nil
	case "failed":
		return DatasetValidationStatusFailed, nil
	case "validated":
		return DatasetValidationStatusValidated, nil
	case "skipped":
		return DatasetValidationStatusSkipped, nil
	}
	var t DatasetValidationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatasetValidationStatus) Ptr() *DatasetValidationStatus {
	return &d
}

type DeleteConnectorResponse = map[string]interface{}

type DetokenizeResponse struct {
	// A string representing the list of tokens.
	Text string   `json:"text"`
	Meta *ApiMeta `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DetokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DetokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetokenizeResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetokenizeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EmbedByTypeResponse struct {
	Id string `json:"id"`
	// An object with different embedding types. The length of each embedding type array will be the same as the length of the original `texts` array.
	Embeddings *EmbedByTypeResponseEmbeddings `json:"embeddings,omitempty"`
	// The text entries for which embeddings were returned.
	Texts []string `json:"texts,omitempty"`
	Meta  *ApiMeta `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmbedByTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedByTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedByTypeResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedByTypeResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// An object with different embedding types. The length of each embedding type array will be the same as the length of the original `texts` array.
type EmbedByTypeResponseEmbeddings struct {
	// An array of float embeddings.
	Float [][]float64 `json:"float,omitempty"`
	// An array of signed int8 embeddings. Each value is between -128 and 127.
	Int8 [][]float64 `json:"int8,omitempty"`
	// An array of unsigned int8 embeddings. Each value is between 0 and 255.
	Uint8 [][]float64 `json:"uint8,omitempty"`
	// An array of packed signed binary embeddings. The length of each binary embedding is 1/8 the length of the float embeddings of the provided model. Each value is between -128 and 127.
	Binary [][]float64 `json:"binary,omitempty"`
	// An array of packed unsigned binary embeddings. The length of each binary embedding is 1/8 the length of the float embeddings of the provided model. Each value is between 0 and 255.
	Ubinary [][]float64 `json:"ubinary,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmbedByTypeResponseEmbeddings) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedByTypeResponseEmbeddings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedByTypeResponseEmbeddings(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedByTypeResponseEmbeddings) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmbedFloatsResponse struct {
	Id string `json:"id"`
	// An array of embeddings, where each embedding is an array of floats. The length of the `embeddings` array will be the same as the length of the original `texts` array.
	Embeddings [][]float64 `json:"embeddings,omitempty"`
	// The text entries for which embeddings were returned.
	Texts []string `json:"texts,omitempty"`
	Meta  *ApiMeta `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmbedFloatsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedFloatsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedFloatsResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedFloatsResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Specifies the type of input passed to the model. Required for embedding models v3 and higher.
//
// - `"search_document"`: Used for embeddings stored in a vector database for search use-cases.
// - `"search_query"`: Used for embeddings of search queries run against a vector DB to find relevant documents.
// - `"classification"`: Used for embeddings passed through a text classifier.
// - `"clustering"`: Used for the embeddings run through a clustering algorithm.
type EmbedInputType string

const (
	EmbedInputTypeSearchDocument EmbedInputType = "search_document"
	EmbedInputTypeSearchQuery    EmbedInputType = "search_query"
	EmbedInputTypeClassification EmbedInputType = "classification"
	EmbedInputTypeClustering     EmbedInputType = "clustering"
)

func NewEmbedInputTypeFromString(s string) (EmbedInputType, error) {
	switch s {
	case "search_document":
		return EmbedInputTypeSearchDocument, nil
	case "search_query":
		return EmbedInputTypeSearchQuery, nil
	case "classification":
		return EmbedInputTypeClassification, nil
	case "clustering":
		return EmbedInputTypeClustering, nil
	}
	var t EmbedInputType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedInputType) Ptr() *EmbedInputType {
	return &e
}

type EmbedJob struct {
	// ID of the embed job
	JobId string `json:"job_id"`
	// The name of the embed job
	Name *string `json:"name,omitempty"`
	// The status of the embed job
	Status EmbedJobStatus `json:"status,omitempty"`
	// The creation date of the embed job
	CreatedAt time.Time `json:"created_at"`
	// ID of the input dataset
	InputDatasetId string `json:"input_dataset_id"`
	// ID of the resulting output dataset
	OutputDatasetId *string `json:"output_dataset_id,omitempty"`
	// ID of the model used to embed
	Model string `json:"model"`
	// The truncation option used
	Truncate EmbedJobTruncate `json:"truncate,omitempty"`
	Meta     *ApiMeta         `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmbedJob) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedJob
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedJob(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedJob) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The status of the embed job
type EmbedJobStatus string

const (
	EmbedJobStatusProcessing EmbedJobStatus = "processing"
	EmbedJobStatusComplete   EmbedJobStatus = "complete"
	EmbedJobStatusCancelling EmbedJobStatus = "cancelling"
	EmbedJobStatusCancelled  EmbedJobStatus = "cancelled"
	EmbedJobStatusFailed     EmbedJobStatus = "failed"
)

func NewEmbedJobStatusFromString(s string) (EmbedJobStatus, error) {
	switch s {
	case "processing":
		return EmbedJobStatusProcessing, nil
	case "complete":
		return EmbedJobStatusComplete, nil
	case "cancelling":
		return EmbedJobStatusCancelling, nil
	case "cancelled":
		return EmbedJobStatusCancelled, nil
	case "failed":
		return EmbedJobStatusFailed, nil
	}
	var t EmbedJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedJobStatus) Ptr() *EmbedJobStatus {
	return &e
}

// The truncation option used
type EmbedJobTruncate string

const (
	EmbedJobTruncateStart EmbedJobTruncate = "START"
	EmbedJobTruncateEnd   EmbedJobTruncate = "END"
)

func NewEmbedJobTruncateFromString(s string) (EmbedJobTruncate, error) {
	switch s {
	case "START":
		return EmbedJobTruncateStart, nil
	case "END":
		return EmbedJobTruncateEnd, nil
	}
	var t EmbedJobTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedJobTruncate) Ptr() *EmbedJobTruncate {
	return &e
}

type EmbedRequestEmbeddingTypesItem string

const (
	EmbedRequestEmbeddingTypesItemFloat   EmbedRequestEmbeddingTypesItem = "float"
	EmbedRequestEmbeddingTypesItemInt8    EmbedRequestEmbeddingTypesItem = "int8"
	EmbedRequestEmbeddingTypesItemUint8   EmbedRequestEmbeddingTypesItem = "uint8"
	EmbedRequestEmbeddingTypesItemBinary  EmbedRequestEmbeddingTypesItem = "binary"
	EmbedRequestEmbeddingTypesItemUbinary EmbedRequestEmbeddingTypesItem = "ubinary"
)

func NewEmbedRequestEmbeddingTypesItemFromString(s string) (EmbedRequestEmbeddingTypesItem, error) {
	switch s {
	case "float":
		return EmbedRequestEmbeddingTypesItemFloat, nil
	case "int8":
		return EmbedRequestEmbeddingTypesItemInt8, nil
	case "uint8":
		return EmbedRequestEmbeddingTypesItemUint8, nil
	case "binary":
		return EmbedRequestEmbeddingTypesItemBinary, nil
	case "ubinary":
		return EmbedRequestEmbeddingTypesItemUbinary, nil
	}
	var t EmbedRequestEmbeddingTypesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedRequestEmbeddingTypesItem) Ptr() *EmbedRequestEmbeddingTypesItem {
	return &e
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type EmbedRequestTruncate string

const (
	EmbedRequestTruncateNone  EmbedRequestTruncate = "NONE"
	EmbedRequestTruncateStart EmbedRequestTruncate = "START"
	EmbedRequestTruncateEnd   EmbedRequestTruncate = "END"
)

func NewEmbedRequestTruncateFromString(s string) (EmbedRequestTruncate, error) {
	switch s {
	case "NONE":
		return EmbedRequestTruncateNone, nil
	case "START":
		return EmbedRequestTruncateStart, nil
	case "END":
		return EmbedRequestTruncateEnd, nil
	}
	var t EmbedRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedRequestTruncate) Ptr() *EmbedRequestTruncate {
	return &e
}

type EmbedResponse struct {
	ResponseType     string
	EmbeddingsFloats *EmbedFloatsResponse
	EmbeddingsByType *EmbedByTypeResponse
}

func NewEmbedResponseFromEmbeddingsFloats(value *EmbedFloatsResponse) *EmbedResponse {
	return &EmbedResponse{ResponseType: "embeddings_floats", EmbeddingsFloats: value}
}

func NewEmbedResponseFromEmbeddingsByType(value *EmbedByTypeResponse) *EmbedResponse {
	return &EmbedResponse{ResponseType: "embeddings_by_type", EmbeddingsByType: value}
}

func (e *EmbedResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ResponseType string `json:"response_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.ResponseType = unmarshaler.ResponseType
	switch unmarshaler.ResponseType {
	case "embeddings_floats":
		value := new(EmbedFloatsResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EmbeddingsFloats = value
	case "embeddings_by_type":
		value := new(EmbedByTypeResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EmbeddingsByType = value
	}
	return nil
}

func (e EmbedResponse) MarshalJSON() ([]byte, error) {
	switch e.ResponseType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.ResponseType, e)
	case "embeddings_floats":
		var marshaler = struct {
			ResponseType string `json:"response_type"`
			*EmbedFloatsResponse
		}{
			ResponseType:        e.ResponseType,
			EmbedFloatsResponse: e.EmbeddingsFloats,
		}
		return json.Marshal(marshaler)
	case "embeddings_by_type":
		var marshaler = struct {
			ResponseType string `json:"response_type"`
			*EmbedByTypeResponse
		}{
			ResponseType:        e.ResponseType,
			EmbedByTypeResponse: e.EmbeddingsByType,
		}
		return json.Marshal(marshaler)
	}
}

type EmbedResponseVisitor interface {
	VisitEmbeddingsFloats(*EmbedFloatsResponse) error
	VisitEmbeddingsByType(*EmbedByTypeResponse) error
}

func (e *EmbedResponse) Accept(visitor EmbedResponseVisitor) error {
	switch e.ResponseType {
	default:
		return fmt.Errorf("invalid type %s in %T", e.ResponseType, e)
	case "embeddings_floats":
		return visitor.VisitEmbeddingsFloats(e.EmbeddingsFloats)
	case "embeddings_by_type":
		return visitor.VisitEmbeddingsByType(e.EmbeddingsByType)
	}
}

type FinishReason string

const (
	FinishReasonComplete   FinishReason = "COMPLETE"
	FinishReasonError      FinishReason = "ERROR"
	FinishReasonErrorToxic FinishReason = "ERROR_TOXIC"
	FinishReasonErrorLimit FinishReason = "ERROR_LIMIT"
	FinishReasonUserCancel FinishReason = "USER_CANCEL"
	FinishReasonMaxTokens  FinishReason = "MAX_TOKENS"
)

func NewFinishReasonFromString(s string) (FinishReason, error) {
	switch s {
	case "COMPLETE":
		return FinishReasonComplete, nil
	case "ERROR":
		return FinishReasonError, nil
	case "ERROR_TOXIC":
		return FinishReasonErrorToxic, nil
	case "ERROR_LIMIT":
		return FinishReasonErrorLimit, nil
	case "USER_CANCEL":
		return FinishReasonUserCancel, nil
	case "MAX_TOKENS":
		return FinishReasonMaxTokens, nil
	}
	var t FinishReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FinishReason) Ptr() *FinishReason {
	return &f
}

// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
//
// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
//
// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
type GenerateRequestReturnLikelihoods string

const (
	GenerateRequestReturnLikelihoodsGeneration GenerateRequestReturnLikelihoods = "GENERATION"
	GenerateRequestReturnLikelihoodsAll        GenerateRequestReturnLikelihoods = "ALL"
	GenerateRequestReturnLikelihoodsNone       GenerateRequestReturnLikelihoods = "NONE"
)

func NewGenerateRequestReturnLikelihoodsFromString(s string) (GenerateRequestReturnLikelihoods, error) {
	switch s {
	case "GENERATION":
		return GenerateRequestReturnLikelihoodsGeneration, nil
	case "ALL":
		return GenerateRequestReturnLikelihoodsAll, nil
	case "NONE":
		return GenerateRequestReturnLikelihoodsNone, nil
	}
	var t GenerateRequestReturnLikelihoods
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateRequestReturnLikelihoods) Ptr() *GenerateRequestReturnLikelihoods {
	return &g
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type GenerateRequestTruncate string

const (
	GenerateRequestTruncateNone  GenerateRequestTruncate = "NONE"
	GenerateRequestTruncateStart GenerateRequestTruncate = "START"
	GenerateRequestTruncateEnd   GenerateRequestTruncate = "END"
)

func NewGenerateRequestTruncateFromString(s string) (GenerateRequestTruncate, error) {
	switch s {
	case "NONE":
		return GenerateRequestTruncateNone, nil
	case "START":
		return GenerateRequestTruncateStart, nil
	case "END":
		return GenerateRequestTruncateEnd, nil
	}
	var t GenerateRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateRequestTruncate) Ptr() *GenerateRequestTruncate {
	return &g
}

type GenerateStreamEnd struct {
	IsFinished   bool                       `json:"is_finished"`
	FinishReason *FinishReason              `json:"finish_reason,omitempty"`
	Response     *GenerateStreamEndResponse `json:"response,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GenerateStreamEnd) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamEnd
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamEnd(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamEnd) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateStreamEndResponse struct {
	Id          string                      `json:"id"`
	Prompt      *string                     `json:"prompt,omitempty"`
	Generations []*SingleGenerationInStream `json:"generations,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GenerateStreamEndResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamEndResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamEndResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamEndResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateStreamError struct {
	// Refers to the nth generation. Only present when `num_generations` is greater than zero.
	Index        *int         `json:"index,omitempty"`
	IsFinished   bool         `json:"is_finished"`
	FinishReason FinishReason `json:"finish_reason,omitempty"`
	// Error message
	Err string `json:"err"`

	_rawJSON json.RawMessage
}

func (g *GenerateStreamError) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamError(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamError) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateStreamEvent struct {
	_rawJSON json.RawMessage
}

func (g *GenerateStreamEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamEvent(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamEvent) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
//
// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
//
// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
type GenerateStreamRequestReturnLikelihoods string

const (
	GenerateStreamRequestReturnLikelihoodsGeneration GenerateStreamRequestReturnLikelihoods = "GENERATION"
	GenerateStreamRequestReturnLikelihoodsAll        GenerateStreamRequestReturnLikelihoods = "ALL"
	GenerateStreamRequestReturnLikelihoodsNone       GenerateStreamRequestReturnLikelihoods = "NONE"
)

func NewGenerateStreamRequestReturnLikelihoodsFromString(s string) (GenerateStreamRequestReturnLikelihoods, error) {
	switch s {
	case "GENERATION":
		return GenerateStreamRequestReturnLikelihoodsGeneration, nil
	case "ALL":
		return GenerateStreamRequestReturnLikelihoodsAll, nil
	case "NONE":
		return GenerateStreamRequestReturnLikelihoodsNone, nil
	}
	var t GenerateStreamRequestReturnLikelihoods
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateStreamRequestReturnLikelihoods) Ptr() *GenerateStreamRequestReturnLikelihoods {
	return &g
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type GenerateStreamRequestTruncate string

const (
	GenerateStreamRequestTruncateNone  GenerateStreamRequestTruncate = "NONE"
	GenerateStreamRequestTruncateStart GenerateStreamRequestTruncate = "START"
	GenerateStreamRequestTruncateEnd   GenerateStreamRequestTruncate = "END"
)

func NewGenerateStreamRequestTruncateFromString(s string) (GenerateStreamRequestTruncate, error) {
	switch s {
	case "NONE":
		return GenerateStreamRequestTruncateNone, nil
	case "START":
		return GenerateStreamRequestTruncateStart, nil
	case "END":
		return GenerateStreamRequestTruncateEnd, nil
	}
	var t GenerateStreamRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateStreamRequestTruncate) Ptr() *GenerateStreamRequestTruncate {
	return &g
}

type GenerateStreamText struct {
	// A segment of text of the generation.
	Text string `json:"text"`
	// Refers to the nth generation. Only present when `num_generations` is greater than zero, and only when text responses are being streamed.
	Index      *int `json:"index,omitempty"`
	IsFinished bool `json:"is_finished"`

	_rawJSON json.RawMessage
}

func (g *GenerateStreamText) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamText(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamText) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Response in content type stream when `stream` is `true` in the request parameters. Generation tokens are streamed with the GenerationStream response. The final response is of type GenerationFinalResponse.
type GenerateStreamedResponse struct {
	EventType      string
	TextGeneration *GenerateStreamText
	StreamEnd      *GenerateStreamEnd
	StreamError    *GenerateStreamError
}

func NewGenerateStreamedResponseFromTextGeneration(value *GenerateStreamText) *GenerateStreamedResponse {
	return &GenerateStreamedResponse{EventType: "text-generation", TextGeneration: value}
}

func NewGenerateStreamedResponseFromStreamEnd(value *GenerateStreamEnd) *GenerateStreamedResponse {
	return &GenerateStreamedResponse{EventType: "stream-end", StreamEnd: value}
}

func NewGenerateStreamedResponseFromStreamError(value *GenerateStreamError) *GenerateStreamedResponse {
	return &GenerateStreamedResponse{EventType: "stream-error", StreamError: value}
}

func (g *GenerateStreamedResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"event_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.EventType = unmarshaler.EventType
	switch unmarshaler.EventType {
	case "text-generation":
		value := new(GenerateStreamText)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.TextGeneration = value
	case "stream-end":
		value := new(GenerateStreamEnd)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.StreamEnd = value
	case "stream-error":
		value := new(GenerateStreamError)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.StreamError = value
	}
	return nil
}

func (g GenerateStreamedResponse) MarshalJSON() ([]byte, error) {
	switch g.EventType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.EventType, g)
	case "text-generation":
		var marshaler = struct {
			EventType string `json:"event_type"`
			*GenerateStreamText
		}{
			EventType:          g.EventType,
			GenerateStreamText: g.TextGeneration,
		}
		return json.Marshal(marshaler)
	case "stream-end":
		var marshaler = struct {
			EventType string `json:"event_type"`
			*GenerateStreamEnd
		}{
			EventType:         g.EventType,
			GenerateStreamEnd: g.StreamEnd,
		}
		return json.Marshal(marshaler)
	case "stream-error":
		var marshaler = struct {
			EventType string `json:"event_type"`
			*GenerateStreamError
		}{
			EventType:           g.EventType,
			GenerateStreamError: g.StreamError,
		}
		return json.Marshal(marshaler)
	}
}

type GenerateStreamedResponseVisitor interface {
	VisitTextGeneration(*GenerateStreamText) error
	VisitStreamEnd(*GenerateStreamEnd) error
	VisitStreamError(*GenerateStreamError) error
}

func (g *GenerateStreamedResponse) Accept(visitor GenerateStreamedResponseVisitor) error {
	switch g.EventType {
	default:
		return fmt.Errorf("invalid type %s in %T", g.EventType, g)
	case "text-generation":
		return visitor.VisitTextGeneration(g.TextGeneration)
	case "stream-end":
		return visitor.VisitStreamEnd(g.StreamEnd)
	case "stream-error":
		return visitor.VisitStreamError(g.StreamError)
	}
}

type Generation struct {
	Id string `json:"id"`
	// Prompt used for generations.
	Prompt *string `json:"prompt,omitempty"`
	// List of generated results
	Generations []*SingleGeneration `json:"generations,omitempty"`
	Meta        *ApiMeta            `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (g *Generation) UnmarshalJSON(data []byte) error {
	type unmarshaler Generation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Generation(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Generation) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetConnectorResponse struct {
	Connector *Connector `json:"connector,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetConnectorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetConnectorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetConnectorResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetConnectorResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListConnectorsResponse struct {
	Connectors []*Connector `json:"connectors,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListConnectorsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListConnectorsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListConnectorsResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListConnectorsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListEmbedJobResponse struct {
	EmbedJobs []*EmbedJob `json:"embed_jobs,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListEmbedJobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEmbedJobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEmbedJobResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEmbedJobResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type NonStreamedChatResponse struct {
	// Contents of the reply generated by the model.
	Text string `json:"text"`
	// Unique identifier for the generated reply. Useful for submitting feedback.
	GenerationId string `json:"generation_id"`
	// Inline citations for the generated reply.
	Citations []*ChatCitation `json:"citations,omitempty"`
	// Documents seen by the model when generating the reply.
	Documents []ChatDocument `json:"documents,omitempty"`
	// Generated search queries, meant to be used as part of the RAG flow.
	SearchQueries []*ChatSearchQuery `json:"search_queries,omitempty"`
	// Documents retrieved from each of the conducted searches.
	SearchResults []*ChatSearchResult `json:"search_results,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NonStreamedChatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler NonStreamedChatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NonStreamedChatResponse(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NonStreamedChatResponse) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type OAuthAuthorizeResponse struct {
	// The OAuth 2.0 redirect url. Redirect the user to this url to authorize the connector.
	RedirectUrl *string `json:"redirect_url,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OAuthAuthorizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthAuthorizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthAuthorizeResponse(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuthAuthorizeResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type ParseInfo struct {
	Separator *string `json:"separator,omitempty"`
	Delimiter *string `json:"delimiter,omitempty"`

	_rawJSON json.RawMessage
}

func (p *ParseInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ParseInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ParseInfo(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ParseInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RerankRequestDocumentsItem struct {
	typeName                       string
	String                         string
	RerankRequestDocumentsItemText *RerankRequestDocumentsItemText
}

func NewRerankRequestDocumentsItemFromString(value string) *RerankRequestDocumentsItem {
	return &RerankRequestDocumentsItem{typeName: "string", String: value}
}

func NewRerankRequestDocumentsItemFromRerankRequestDocumentsItemText(value *RerankRequestDocumentsItemText) *RerankRequestDocumentsItem {
	return &RerankRequestDocumentsItem{typeName: "rerankRequestDocumentsItemText", RerankRequestDocumentsItemText: value}
}

func (r *RerankRequestDocumentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRerankRequestDocumentsItemText := new(RerankRequestDocumentsItemText)
	if err := json.Unmarshal(data, &valueRerankRequestDocumentsItemText); err == nil {
		r.typeName = "rerankRequestDocumentsItemText"
		r.RerankRequestDocumentsItemText = valueRerankRequestDocumentsItemText
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RerankRequestDocumentsItem) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "rerankRequestDocumentsItemText":
		return json.Marshal(r.RerankRequestDocumentsItemText)
	}
}

type RerankRequestDocumentsItemVisitor interface {
	VisitString(string) error
	VisitRerankRequestDocumentsItemText(*RerankRequestDocumentsItemText) error
}

func (r *RerankRequestDocumentsItem) Accept(visitor RerankRequestDocumentsItemVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "rerankRequestDocumentsItemText":
		return visitor.VisitRerankRequestDocumentsItemText(r.RerankRequestDocumentsItemText)
	}
}

type RerankRequestDocumentsItemText struct {
	// The text of the document to rerank.
	Text string `json:"text"`

	_rawJSON json.RawMessage
}

func (r *RerankRequestDocumentsItemText) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankRequestDocumentsItemText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankRequestDocumentsItemText(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankRequestDocumentsItemText) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RerankResponse struct {
	Id *string `json:"id,omitempty"`
	// An ordered list of ranked documents
	Results []*RerankResponseResultsItem `json:"results,omitempty"`
	Meta    *ApiMeta                     `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RerankResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RerankResponseResultsItem struct {
	// The doc object which was ranked
	Document *RerankResponseResultsItemDocument `json:"document,omitempty"`
	// The index of the input document
	Index int `json:"index"`
	// A relevance score assigned to the ranking
	RelevanceScore float64 `json:"relevance_score"`

	_rawJSON json.RawMessage
}

func (r *RerankResponseResultsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankResponseResultsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankResponseResultsItem(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankResponseResultsItem) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The doc object which was ranked
type RerankResponseResultsItemDocument struct {
	// The text of the document to rerank
	Text string `json:"text"`

	_rawJSON json.RawMessage
}

func (r *RerankResponseResultsItemDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankResponseResultsItemDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankResponseResultsItemDocument(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankResponseResultsItemDocument) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SearchQueriesOnlyResponse struct {
	// Generated search queries, meant to be used as part of the RAG flow.
	SearchQueries []*ChatSearchQuery `json:"search_queries,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SearchQueriesOnlyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchQueriesOnlyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchQueriesOnlyResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchQueriesOnlyResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleGeneration struct {
	Id   string `json:"id"`
	Text string `json:"text"`
	// Refers to the nth generation. Only present when `num_generations` is greater than zero.
	Index      *int     `json:"index,omitempty"`
	Likelihood *float64 `json:"likelihood,omitempty"`
	// Only returned if `return_likelihoods` is set to `GENERATION` or `ALL`. The likelihood refers to the average log-likelihood of the entire specified string, which is useful for [evaluating the performance of your model](likelihood-eval), especially if you've created a [custom model](/docs/training-custom-models). Individual token likelihoods provide the log-likelihood of each token. The first token will not have a likelihood.
	TokenLikelihoods []*SingleGenerationTokenLikelihoodsItem `json:"token_likelihoods,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SingleGeneration) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleGeneration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleGeneration(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleGeneration) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleGenerationInStream struct {
	Id string `json:"id"`
	// Full text of the generation.
	Text string `json:"text"`
	// Refers to the nth generation. Only present when `num_generations` is greater than zero.
	Index        *int         `json:"index,omitempty"`
	FinishReason FinishReason `json:"finish_reason,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SingleGenerationInStream) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleGenerationInStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleGenerationInStream(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleGenerationInStream) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleGenerationTokenLikelihoodsItem struct {
	Token      string  `json:"token"`
	Likelihood float64 `json:"likelihood"`

	_rawJSON json.RawMessage
}

func (s *SingleGenerationTokenLikelihoodsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleGenerationTokenLikelihoodsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleGenerationTokenLikelihoodsItem(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleGenerationTokenLikelihoodsItem) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// StreamedChatResponse is returned in streaming mode (specified with `stream=True` in the request).
type StreamedChatResponse struct {
	EventType               string
	StreamStart             *ChatStreamStartEvent
	SearchQueriesGeneration *ChatSearchQueriesGenerationEvent
	SearchResults           *ChatSearchResultsEvent
	TextGeneration          *ChatTextGenerationEvent
	CitationGeneration      *ChatCitationGenerationEvent
	StreamEnd               *ChatStreamEndEvent
}

func NewStreamedChatResponseFromStreamStart(value *ChatStreamStartEvent) *StreamedChatResponse {
	return &StreamedChatResponse{EventType: "stream-start", StreamStart: value}
}

func NewStreamedChatResponseFromSearchQueriesGeneration(value *ChatSearchQueriesGenerationEvent) *StreamedChatResponse {
	return &StreamedChatResponse{EventType: "search-queries-generation", SearchQueriesGeneration: value}
}

func NewStreamedChatResponseFromSearchResults(value *ChatSearchResultsEvent) *StreamedChatResponse {
	return &StreamedChatResponse{EventType: "search-results", SearchResults: value}
}

func NewStreamedChatResponseFromTextGeneration(value *ChatTextGenerationEvent) *StreamedChatResponse {
	return &StreamedChatResponse{EventType: "text-generation", TextGeneration: value}
}

func NewStreamedChatResponseFromCitationGeneration(value *ChatCitationGenerationEvent) *StreamedChatResponse {
	return &StreamedChatResponse{EventType: "citation-generation", CitationGeneration: value}
}

func NewStreamedChatResponseFromStreamEnd(value *ChatStreamEndEvent) *StreamedChatResponse {
	return &StreamedChatResponse{EventType: "stream-end", StreamEnd: value}
}

func (s *StreamedChatResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"event_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.EventType = unmarshaler.EventType
	switch unmarshaler.EventType {
	case "stream-start":
		value := new(ChatStreamStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.StreamStart = value
	case "search-queries-generation":
		value := new(ChatSearchQueriesGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SearchQueriesGeneration = value
	case "search-results":
		value := new(ChatSearchResultsEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SearchResults = value
	case "text-generation":
		value := new(ChatTextGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.TextGeneration = value
	case "citation-generation":
		value := new(ChatCitationGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.CitationGeneration = value
	case "stream-end":
		value := new(ChatStreamEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.StreamEnd = value
	}
	return nil
}

func (s StreamedChatResponse) MarshalJSON() ([]byte, error) {
	switch s.EventType {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.EventType, s)
	case "stream-start":
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatStreamStartEvent
		}{
			EventType:            s.EventType,
			ChatStreamStartEvent: s.StreamStart,
		}
		return json.Marshal(marshaler)
	case "search-queries-generation":
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatSearchQueriesGenerationEvent
		}{
			EventType:                        s.EventType,
			ChatSearchQueriesGenerationEvent: s.SearchQueriesGeneration,
		}
		return json.Marshal(marshaler)
	case "search-results":
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatSearchResultsEvent
		}{
			EventType:              s.EventType,
			ChatSearchResultsEvent: s.SearchResults,
		}
		return json.Marshal(marshaler)
	case "text-generation":
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatTextGenerationEvent
		}{
			EventType:               s.EventType,
			ChatTextGenerationEvent: s.TextGeneration,
		}
		return json.Marshal(marshaler)
	case "citation-generation":
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatCitationGenerationEvent
		}{
			EventType:                   s.EventType,
			ChatCitationGenerationEvent: s.CitationGeneration,
		}
		return json.Marshal(marshaler)
	case "stream-end":
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatStreamEndEvent
		}{
			EventType:          s.EventType,
			ChatStreamEndEvent: s.StreamEnd,
		}
		return json.Marshal(marshaler)
	}
}

type StreamedChatResponseVisitor interface {
	VisitStreamStart(*ChatStreamStartEvent) error
	VisitSearchQueriesGeneration(*ChatSearchQueriesGenerationEvent) error
	VisitSearchResults(*ChatSearchResultsEvent) error
	VisitTextGeneration(*ChatTextGenerationEvent) error
	VisitCitationGeneration(*ChatCitationGenerationEvent) error
	VisitStreamEnd(*ChatStreamEndEvent) error
}

func (s *StreamedChatResponse) Accept(visitor StreamedChatResponseVisitor) error {
	switch s.EventType {
	default:
		return fmt.Errorf("invalid type %s in %T", s.EventType, s)
	case "stream-start":
		return visitor.VisitStreamStart(s.StreamStart)
	case "search-queries-generation":
		return visitor.VisitSearchQueriesGeneration(s.SearchQueriesGeneration)
	case "search-results":
		return visitor.VisitSearchResults(s.SearchResults)
	case "text-generation":
		return visitor.VisitTextGeneration(s.TextGeneration)
	case "citation-generation":
		return visitor.VisitCitationGeneration(s.CitationGeneration)
	case "stream-end":
		return visitor.VisitStreamEnd(s.StreamEnd)
	}
}

// One of `low`, `medium`, `high`, or `auto`, defaults to `auto`. Controls how close to the original text the summary is. `high` extractiveness summaries will lean towards reusing sentences verbatim, while `low` extractiveness summaries will tend to paraphrase more. If `auto` is selected, the best option will be picked based on the input text.
type SummarizeRequestExtractiveness string

const (
	SummarizeRequestExtractivenessLow    SummarizeRequestExtractiveness = "low"
	SummarizeRequestExtractivenessMedium SummarizeRequestExtractiveness = "medium"
	SummarizeRequestExtractivenessHigh   SummarizeRequestExtractiveness = "high"
)

func NewSummarizeRequestExtractivenessFromString(s string) (SummarizeRequestExtractiveness, error) {
	switch s {
	case "low":
		return SummarizeRequestExtractivenessLow, nil
	case "medium":
		return SummarizeRequestExtractivenessMedium, nil
	case "high":
		return SummarizeRequestExtractivenessHigh, nil
	}
	var t SummarizeRequestExtractiveness
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SummarizeRequestExtractiveness) Ptr() *SummarizeRequestExtractiveness {
	return &s
}

// One of `paragraph`, `bullets`, or `auto`, defaults to `auto`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If `auto` is selected, the best option will be picked based on the input text.
type SummarizeRequestFormat string

const (
	SummarizeRequestFormatParagraph SummarizeRequestFormat = "paragraph"
	SummarizeRequestFormatBullets   SummarizeRequestFormat = "bullets"
)

func NewSummarizeRequestFormatFromString(s string) (SummarizeRequestFormat, error) {
	switch s {
	case "paragraph":
		return SummarizeRequestFormatParagraph, nil
	case "bullets":
		return SummarizeRequestFormatBullets, nil
	}
	var t SummarizeRequestFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SummarizeRequestFormat) Ptr() *SummarizeRequestFormat {
	return &s
}

// One of `short`, `medium`, `long`, or `auto` defaults to `auto`. Indicates the approximate length of the summary. If `auto` is selected, the best option will be picked based on the input text.
type SummarizeRequestLength string

const (
	SummarizeRequestLengthShort  SummarizeRequestLength = "short"
	SummarizeRequestLengthMedium SummarizeRequestLength = "medium"
	SummarizeRequestLengthLong   SummarizeRequestLength = "long"
)

func NewSummarizeRequestLengthFromString(s string) (SummarizeRequestLength, error) {
	switch s {
	case "short":
		return SummarizeRequestLengthShort, nil
	case "medium":
		return SummarizeRequestLengthMedium, nil
	case "long":
		return SummarizeRequestLengthLong, nil
	}
	var t SummarizeRequestLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SummarizeRequestLength) Ptr() *SummarizeRequestLength {
	return &s
}

type SummarizeResponse struct {
	// Generated ID for the summary
	Id *string `json:"id,omitempty"`
	// Generated summary for the text
	Summary *string  `json:"summary,omitempty"`
	Meta    *ApiMeta `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SummarizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SummarizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummarizeResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummarizeResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TokenizeResponse struct {
	// An array of tokens, where each token is an integer.
	Tokens       []int    `json:"tokens,omitempty"`
	TokenStrings []string `json:"token_strings,omitempty"`
	Meta         *ApiMeta `json:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeResponse(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UpdateConnectorResponse struct {
	Connector *Connector `json:"connector,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateConnectorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateConnectorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateConnectorResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateConnectorResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
