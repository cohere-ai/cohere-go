// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/cohere-ai/cohere-go/v2/internal"
)

type V2ChatRequest struct {
	// Defaults to `false`.
	//
	// When `true`, the response will be a SSE stream of events.
	//
	// Streaming is beneficial for user interfaces that render the contents of the response piece by piece, as it gets generated.
	// The name of a compatible [Cohere model](https://docs.cohere.com/v2/docs/models).
	Model    string       `json:"model" url:"-"`
	Messages ChatMessages `json:"messages,omitempty" url:"-"`
	// A list of tools (functions) available to the model. The model response may contain 'tool_calls' to the specified tools.
	//
	// Learn more in the [Tool Use guide](https://docs.cohere.com/docs/tools).
	Tools []*ToolV2 `json:"tools,omitempty" url:"-"`
	// When set to `true`, tool calls in the Assistant message will be forced to follow the tool definition strictly. Learn more in the [Structured Outputs (Tools) guide](https://docs.cohere.com/docs/structured-outputs-json#structured-outputs-tools).
	//
	// **Note**: The first few requests with a new set of tools will take longer to process.
	StrictTools *bool `json:"strict_tools,omitempty" url:"-"`
	// A list of relevant documents that the model can cite to generate a more accurate reply. Each document is either a string or document object with content and metadata.
	Documents       []*V2ChatRequestDocumentsItem `json:"documents,omitempty" url:"-"`
	CitationOptions *CitationOptions              `json:"citation_options,omitempty" url:"-"`
	ResponseFormat  *ResponseFormatV2             `json:"response_format,omitempty" url:"-"`
	// Used to select the [safety instruction](https://docs.cohere.com/v2/docs/safety-modes) inserted into the prompt. Defaults to `CONTEXTUAL`.
	// When `OFF` is specified, the safety instruction will be omitted.
	//
	// Safety modes are not yet configurable in combination with `tools` and `documents` parameters.
	//
	// **Note**: This parameter is only compatible newer Cohere models, starting with [Command R 08-2024](https://docs.cohere.com/docs/command-r#august-2024-release) and [Command R+ 08-2024](https://docs.cohere.com/docs/command-r-plus#august-2024-release).
	//
	// **Note**: `command-r7b-12-2024` and newer models only support `"CONTEXTUAL"` and `"STRICT"` modes.
	SafetyMode *V2ChatRequestSafetyMode `json:"safety_mode,omitempty" url:"-"`
	// The maximum number of output tokens the model will generate in the response. If not set, `max_tokens` defaults to the model's maximum output token limit. You can find the maximum output token limits for each model in the [model documentation](https://docs.cohere.com/docs/models).
	//
	// **Note**: Setting a low value may result in incomplete generations. In such cases, the `finish_reason` field in the response will be set to `"MAX_TOKENS"`.
	//
	// **Note**: If `max_tokens` is set higher than the model's maximum output token limit, the generation will be capped at that model-specific maximum limit.
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// A list of up to 5 strings that the model will use to stop generation. If the model generates a string that matches any of the strings in the list, it will stop generating tokens and return the generated text up to that point not including the stop sequence.
	StopSequences []string `json:"stop_sequences,omitempty" url:"-"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	Temperature *float64 `json:"temperature,omitempty" url:"-"`
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	Seed *int `json:"seed,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	// Used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"-"`
	// Ensures that only the top `k` most likely tokens are considered for generation at each step. When `k` is set to `0`, k-sampling is disabled.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"-"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"-"`
	// Defaults to `false`. When set to `true`, the log probabilities of the generated tokens will be included in the response.
	Logprobs *bool `json:"logprobs,omitempty" url:"-"`
	// Used to control whether or not the model will be forced to use a tool when answering. When `REQUIRED` is specified, the model will be forced to use at least one of the user-defined tools, and the `tools` parameter must be passed in the request.
	// When `NONE` is specified, the model will be forced **not** to use one of the specified tools, and give a direct response.
	// If tool_choice isn't specified, then the model is free to choose whether to use the specified tools or not.
	//
	// **Note**: This parameter is only compatible with models [Command-r7b](https://docs.cohere.com/v2/docs/command-r7b) and newer.
	ToolChoice *V2ChatRequestToolChoice `json:"tool_choice,omitempty" url:"-"`
	Thinking   *Thinking                `json:"thinking,omitempty" url:"-"`
	// The priority of the request (lower means earlier handling; default 0 highest priority).
	// Higher priority requests are handled first, and dropped last when the system is under load.
	Priority *int `json:"priority,omitempty" url:"-"`
	stream   bool
}

func (v *V2ChatRequest) Stream() bool {
	return v.stream
}

func (v *V2ChatRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V2ChatRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*v = V2ChatRequest(body)
	v.stream = false
	return nil
}

func (v *V2ChatRequest) MarshalJSON() ([]byte, error) {
	type embed V2ChatRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*v),
		Stream: false,
	}
	return json.Marshal(marshaler)
}

type V2ChatStreamRequest struct {
	// Defaults to `false`.
	//
	// When `true`, the response will be a SSE stream of events.
	//
	// Streaming is beneficial for user interfaces that render the contents of the response piece by piece, as it gets generated.
	// The name of a compatible [Cohere model](https://docs.cohere.com/v2/docs/models).
	Model    string       `json:"model" url:"-"`
	Messages ChatMessages `json:"messages,omitempty" url:"-"`
	// A list of tools (functions) available to the model. The model response may contain 'tool_calls' to the specified tools.
	//
	// Learn more in the [Tool Use guide](https://docs.cohere.com/docs/tools).
	Tools []*ToolV2 `json:"tools,omitempty" url:"-"`
	// When set to `true`, tool calls in the Assistant message will be forced to follow the tool definition strictly. Learn more in the [Structured Outputs (Tools) guide](https://docs.cohere.com/docs/structured-outputs-json#structured-outputs-tools).
	//
	// **Note**: The first few requests with a new set of tools will take longer to process.
	StrictTools *bool `json:"strict_tools,omitempty" url:"-"`
	// A list of relevant documents that the model can cite to generate a more accurate reply. Each document is either a string or document object with content and metadata.
	Documents       []*V2ChatStreamRequestDocumentsItem `json:"documents,omitempty" url:"-"`
	CitationOptions *CitationOptions                    `json:"citation_options,omitempty" url:"-"`
	ResponseFormat  *ResponseFormatV2                   `json:"response_format,omitempty" url:"-"`
	// Used to select the [safety instruction](https://docs.cohere.com/v2/docs/safety-modes) inserted into the prompt. Defaults to `CONTEXTUAL`.
	// When `OFF` is specified, the safety instruction will be omitted.
	//
	// Safety modes are not yet configurable in combination with `tools` and `documents` parameters.
	//
	// **Note**: This parameter is only compatible newer Cohere models, starting with [Command R 08-2024](https://docs.cohere.com/docs/command-r#august-2024-release) and [Command R+ 08-2024](https://docs.cohere.com/docs/command-r-plus#august-2024-release).
	//
	// **Note**: `command-r7b-12-2024` and newer models only support `"CONTEXTUAL"` and `"STRICT"` modes.
	SafetyMode *V2ChatStreamRequestSafetyMode `json:"safety_mode,omitempty" url:"-"`
	// The maximum number of output tokens the model will generate in the response. If not set, `max_tokens` defaults to the model's maximum output token limit. You can find the maximum output token limits for each model in the [model documentation](https://docs.cohere.com/docs/models).
	//
	// **Note**: Setting a low value may result in incomplete generations. In such cases, the `finish_reason` field in the response will be set to `"MAX_TOKENS"`.
	//
	// **Note**: If `max_tokens` is set higher than the model's maximum output token limit, the generation will be capped at that model-specific maximum limit.
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// A list of up to 5 strings that the model will use to stop generation. If the model generates a string that matches any of the strings in the list, it will stop generating tokens and return the generated text up to that point not including the stop sequence.
	StopSequences []string `json:"stop_sequences,omitempty" url:"-"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	Temperature *float64 `json:"temperature,omitempty" url:"-"`
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	Seed *int `json:"seed,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	// Used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"-"`
	// Ensures that only the top `k` most likely tokens are considered for generation at each step. When `k` is set to `0`, k-sampling is disabled.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"-"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"-"`
	// Defaults to `false`. When set to `true`, the log probabilities of the generated tokens will be included in the response.
	Logprobs *bool `json:"logprobs,omitempty" url:"-"`
	// Used to control whether or not the model will be forced to use a tool when answering. When `REQUIRED` is specified, the model will be forced to use at least one of the user-defined tools, and the `tools` parameter must be passed in the request.
	// When `NONE` is specified, the model will be forced **not** to use one of the specified tools, and give a direct response.
	// If tool_choice isn't specified, then the model is free to choose whether to use the specified tools or not.
	//
	// **Note**: This parameter is only compatible with models [Command-r7b](https://docs.cohere.com/v2/docs/command-r7b) and newer.
	ToolChoice *V2ChatStreamRequestToolChoice `json:"tool_choice,omitempty" url:"-"`
	Thinking   *Thinking                      `json:"thinking,omitempty" url:"-"`
	// The priority of the request (lower means earlier handling; default 0 highest priority).
	// Higher priority requests are handled first, and dropped last when the system is under load.
	Priority *int `json:"priority,omitempty" url:"-"`
	stream   bool
}

func (v *V2ChatStreamRequest) Stream() bool {
	return v.stream
}

func (v *V2ChatStreamRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V2ChatStreamRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*v = V2ChatStreamRequest(body)
	v.stream = true
	return nil
}

func (v *V2ChatStreamRequest) MarshalJSON() ([]byte, error) {
	type embed V2ChatStreamRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*v),
		Stream: true,
	}
	return json.Marshal(marshaler)
}

type V2EmbedRequest struct {
	// An array of strings for the model to embed. Maximum number of texts per call is `96`.
	Texts []string `json:"texts,omitempty" url:"-"`
	// An array of image data URIs for the model to embed. Maximum number of images per call is `1`.
	//
	// The image must be a valid [data URI](https://developer.mozilla.org/en-US/docs/Web/URI/Schemes/data). The image must be in either `image/jpeg`, `image/png`, `image/webp`, or `image/gif` format and has a maximum size of 5MB.
	//
	// Image embeddings are supported with Embed v3.0 and newer models.
	Images []string `json:"images,omitempty" url:"-"`
	// ID of one of the available [Embedding models](https://docs.cohere.com/docs/cohere-embed).
	Model     string         `json:"model" url:"-"`
	InputType EmbedInputType `json:"input_type" url:"-"`
	// An array of inputs for the model to embed. Maximum number of inputs per call is `96`. An input can contain a mix of text and image components.
	Inputs []*EmbedInput `json:"inputs,omitempty" url:"-"`
	// The maximum number of tokens to embed per input. If the input text is longer than this, it will be truncated according to the `truncate` parameter.
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// The number of dimensions of the output embedding. This is only available for `embed-v4` and newer models.
	// Possible values are `256`, `512`, `1024`, and `1536`. The default is `1536`.
	OutputDimension *int `json:"output_dimension,omitempty" url:"-"`
	// Specifies the types of embeddings you want to get back. Can be one or more of the following types.
	//
	// * `"float"`: Use this when you want to get back the default float embeddings. Supported with all Embed models.
	// * `"int8"`: Use this when you want to get back signed int8 embeddings. Supported with Embed v3.0 and newer Embed models.
	// * `"uint8"`: Use this when you want to get back unsigned int8 embeddings. Supported with Embed v3.0 and newer Embed models.
	// * `"binary"`: Use this when you want to get back signed binary embeddings. Supported with Embed v3.0 and newer Embed models.
	// * `"ubinary"`: Use this when you want to get back unsigned binary embeddings. Supported with Embed v3.0 and newer Embed models.
	// * `"base64"`: Use this when you want to get back base64 embeddings. Supported with Embed v3.0 and newer Embed models.
	EmbeddingTypes []EmbeddingType `json:"embedding_types,omitempty" url:"-"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *V2EmbedRequestTruncate `json:"truncate,omitempty" url:"-"`
	// The priority of the request (lower means earlier handling; default 0 highest priority).
	// Higher priority requests are handled first, and dropped last when the system is under load.
	Priority *int `json:"priority,omitempty" url:"-"`
}

type V2RerankRequest struct {
	// The identifier of the model to use, eg `rerank-v3.5`.
	Model string `json:"model" url:"-"`
	// The search query
	Query string `json:"query" url:"-"`
	// A list of texts that will be compared to the `query`.
	// For optimal performance we recommend against sending more than 1,000 documents in a single request.
	//
	// **Note**: long documents will automatically be truncated to the value of `max_tokens_per_doc`.
	//
	// **Note**: structured data should be formatted as YAML strings for best performance.
	Documents []string `json:"documents,omitempty" url:"-"`
	// Limits the number of returned rerank results to the specified value. If not passed, all the rerank results will be returned.
	TopN *int `json:"top_n,omitempty" url:"-"`
	// Defaults to `4096`. Long documents will be automatically truncated to the specified number of tokens.
	MaxTokensPerDoc *int `json:"max_tokens_per_doc,omitempty" url:"-"`
	// The priority of the request (lower means earlier handling; default 0 highest priority).
	// Higher priority requests are handled first, and dropped last when the system is under load.
	Priority *int `json:"priority,omitempty" url:"-"`
}

// A message from the assistant role can contain text and tool call information.
type AssistantMessage struct {
	ToolCalls []*ToolCallV2 `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`
	// A chain-of-thought style reflection and plan that the model generates when working with Tools.
	ToolPlan  *string                    `json:"tool_plan,omitempty" url:"tool_plan,omitempty"`
	Content   *AssistantMessageV2Content `json:"content,omitempty" url:"content,omitempty"`
	Citations []*Citation                `json:"citations,omitempty" url:"citations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessage) GetToolCalls() []*ToolCallV2 {
	if a == nil {
		return nil
	}
	return a.ToolCalls
}

func (a *AssistantMessage) GetToolPlan() *string {
	if a == nil {
		return nil
	}
	return a.ToolPlan
}

func (a *AssistantMessage) GetContent() *AssistantMessageV2Content {
	if a == nil {
		return nil
	}
	return a.Content
}

func (a *AssistantMessage) GetCitations() []*Citation {
	if a == nil {
		return nil
	}
	return a.Citations
}

func (a *AssistantMessage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessage) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A message from the assistant role can contain text and tool call information.
type AssistantMessageResponse struct {
	ToolCalls []*ToolCallV2 `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`
	// A chain-of-thought style reflection and plan that the model generates when working with Tools.
	ToolPlan  *string                                `json:"tool_plan,omitempty" url:"tool_plan,omitempty"`
	Content   []*AssistantMessageResponseContentItem `json:"content,omitempty" url:"content,omitempty"`
	Citations []*Citation                            `json:"citations,omitempty" url:"citations,omitempty"`
	role      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageResponse) GetToolCalls() []*ToolCallV2 {
	if a == nil {
		return nil
	}
	return a.ToolCalls
}

func (a *AssistantMessageResponse) GetToolPlan() *string {
	if a == nil {
		return nil
	}
	return a.ToolPlan
}

func (a *AssistantMessageResponse) GetContent() []*AssistantMessageResponseContentItem {
	if a == nil {
		return nil
	}
	return a.Content
}

func (a *AssistantMessageResponse) GetCitations() []*Citation {
	if a == nil {
		return nil
	}
	return a.Citations
}

func (a *AssistantMessageResponse) Role() string {
	return a.role
}

func (a *AssistantMessageResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageResponse) UnmarshalJSON(data []byte) error {
	type embed AssistantMessageResponse
	var unmarshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantMessageResponse(unmarshaler.embed)
	if unmarshaler.Role != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assistant", unmarshaler.Role)
	}
	a.role = unmarshaler.Role
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "role")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageResponse) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageResponse
	var marshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*a),
		Role:  "assistant",
	}
	return json.Marshal(marshaler)
}

func (a *AssistantMessageResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantMessageResponseContentItem struct {
	Type     string
	Text     *ChatTextContent
	Thinking *ChatThinkingContent
}

func (a *AssistantMessageResponseContentItem) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AssistantMessageResponseContentItem) GetText() *ChatTextContent {
	if a == nil {
		return nil
	}
	return a.Text
}

func (a *AssistantMessageResponseContentItem) GetThinking() *ChatThinkingContent {
	if a == nil {
		return nil
	}
	return a.Thinking
}

func (a *AssistantMessageResponseContentItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Text = value
	case "thinking":
		value := new(ChatThinkingContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Thinking = value
	}
	return nil
}

func (a AssistantMessageResponseContentItem) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Text != nil {
		return internal.MarshalJSONWithExtraProperty(a.Text, "type", "text")
	}
	if a.Thinking != nil {
		return internal.MarshalJSONWithExtraProperty(a.Thinking, "type", "thinking")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AssistantMessageResponseContentItemVisitor interface {
	VisitText(*ChatTextContent) error
	VisitThinking(*ChatThinkingContent) error
}

func (a *AssistantMessageResponseContentItem) Accept(visitor AssistantMessageResponseContentItemVisitor) error {
	if a.Text != nil {
		return visitor.VisitText(a.Text)
	}
	if a.Thinking != nil {
		return visitor.VisitThinking(a.Thinking)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *AssistantMessageResponseContentItem) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Text != nil {
		fields = append(fields, "text")
	}
	if a.Thinking != nil {
		fields = append(fields, "thinking")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

type AssistantMessageV2Content struct {
	String                            string
	AssistantMessageV2ContentItemList []*AssistantMessageV2ContentItem

	typ string
}

func (a *AssistantMessageV2Content) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *AssistantMessageV2Content) GetAssistantMessageV2ContentItemList() []*AssistantMessageV2ContentItem {
	if a == nil {
		return nil
	}
	return a.AssistantMessageV2ContentItemList
}

func (a *AssistantMessageV2Content) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	var valueAssistantMessageV2ContentItemList []*AssistantMessageV2ContentItem
	if err := json.Unmarshal(data, &valueAssistantMessageV2ContentItemList); err == nil {
		a.typ = "AssistantMessageV2ContentItemList"
		a.AssistantMessageV2ContentItemList = valueAssistantMessageV2ContentItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantMessageV2Content) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "AssistantMessageV2ContentItemList" || a.AssistantMessageV2ContentItemList != nil {
		return json.Marshal(a.AssistantMessageV2ContentItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantMessageV2ContentVisitor interface {
	VisitString(string) error
	VisitAssistantMessageV2ContentItemList([]*AssistantMessageV2ContentItem) error
}

func (a *AssistantMessageV2Content) Accept(visitor AssistantMessageV2ContentVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "AssistantMessageV2ContentItemList" || a.AssistantMessageV2ContentItemList != nil {
		return visitor.VisitAssistantMessageV2ContentItemList(a.AssistantMessageV2ContentItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantMessageV2ContentItem struct {
	Type     string
	Text     *ChatTextContent
	Thinking *ChatThinkingContent
}

func (a *AssistantMessageV2ContentItem) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AssistantMessageV2ContentItem) GetText() *ChatTextContent {
	if a == nil {
		return nil
	}
	return a.Text
}

func (a *AssistantMessageV2ContentItem) GetThinking() *ChatThinkingContent {
	if a == nil {
		return nil
	}
	return a.Thinking
}

func (a *AssistantMessageV2ContentItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Text = value
	case "thinking":
		value := new(ChatThinkingContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Thinking = value
	}
	return nil
}

func (a AssistantMessageV2ContentItem) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Text != nil {
		return internal.MarshalJSONWithExtraProperty(a.Text, "type", "text")
	}
	if a.Thinking != nil {
		return internal.MarshalJSONWithExtraProperty(a.Thinking, "type", "thinking")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AssistantMessageV2ContentItemVisitor interface {
	VisitText(*ChatTextContent) error
	VisitThinking(*ChatThinkingContent) error
}

func (a *AssistantMessageV2ContentItem) Accept(visitor AssistantMessageV2ContentItemVisitor) error {
	if a.Text != nil {
		return visitor.VisitText(a.Text)
	}
	if a.Thinking != nil {
		return visitor.VisitThinking(a.Thinking)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *AssistantMessageV2ContentItem) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Text != nil {
		fields = append(fields, "text")
	}
	if a.Thinking != nil {
		fields = append(fields, "thinking")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

// A streamed delta event which contains a delta of chat text content.
type ChatContentDeltaEvent struct {
	Index    *int                        `json:"index,omitempty" url:"index,omitempty"`
	Delta    *ChatContentDeltaEventDelta `json:"delta,omitempty" url:"delta,omitempty"`
	Logprobs *LogprobItem                `json:"logprobs,omitempty" url:"logprobs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentDeltaEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatContentDeltaEvent) GetDelta() *ChatContentDeltaEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatContentDeltaEvent) GetLogprobs() *LogprobItem {
	if c == nil {
		return nil
	}
	return c.Logprobs
}

func (c *ChatContentDeltaEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentDeltaEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentDeltaEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentDeltaEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentDeltaEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentDeltaEventDelta struct {
	Message *ChatContentDeltaEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentDeltaEventDelta) GetMessage() *ChatContentDeltaEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatContentDeltaEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentDeltaEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentDeltaEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentDeltaEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentDeltaEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentDeltaEventDeltaMessage struct {
	Content *ChatContentDeltaEventDeltaMessageContent `json:"content,omitempty" url:"content,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentDeltaEventDeltaMessage) GetContent() *ChatContentDeltaEventDeltaMessageContent {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ChatContentDeltaEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentDeltaEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentDeltaEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentDeltaEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentDeltaEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentDeltaEventDeltaMessageContent struct {
	Thinking *string `json:"thinking,omitempty" url:"thinking,omitempty"`
	Text     *string `json:"text,omitempty" url:"text,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentDeltaEventDeltaMessageContent) GetThinking() *string {
	if c == nil {
		return nil
	}
	return c.Thinking
}

func (c *ChatContentDeltaEventDeltaMessageContent) GetText() *string {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *ChatContentDeltaEventDeltaMessageContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentDeltaEventDeltaMessageContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentDeltaEventDeltaMessageContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentDeltaEventDeltaMessageContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentDeltaEventDeltaMessageContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed delta event which signifies that the content block has ended.
type ChatContentEndEvent struct {
	Index *int `json:"index,omitempty" url:"index,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentEndEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatContentEndEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentEndEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentEndEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed delta event which signifies that a new content block has started.
type ChatContentStartEvent struct {
	Index *int                        `json:"index,omitempty" url:"index,omitempty"`
	Delta *ChatContentStartEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentStartEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatContentStartEvent) GetDelta() *ChatContentStartEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatContentStartEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentStartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentStartEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentStartEventDelta struct {
	Message *ChatContentStartEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentStartEventDelta) GetMessage() *ChatContentStartEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatContentStartEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentStartEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentStartEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentStartEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentStartEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentStartEventDeltaMessage struct {
	Content *ChatContentStartEventDeltaMessageContent `json:"content,omitempty" url:"content,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentStartEventDeltaMessage) GetContent() *ChatContentStartEventDeltaMessageContent {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ChatContentStartEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentStartEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentStartEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentStartEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentStartEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentStartEventDeltaMessageContent struct {
	Thinking *string                                       `json:"thinking,omitempty" url:"thinking,omitempty"`
	Text     *string                                       `json:"text,omitempty" url:"text,omitempty"`
	Type     *ChatContentStartEventDeltaMessageContentType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentStartEventDeltaMessageContent) GetThinking() *string {
	if c == nil {
		return nil
	}
	return c.Thinking
}

func (c *ChatContentStartEventDeltaMessageContent) GetText() *string {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *ChatContentStartEventDeltaMessageContent) GetType() *ChatContentStartEventDeltaMessageContentType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ChatContentStartEventDeltaMessageContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentStartEventDeltaMessageContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentStartEventDeltaMessageContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentStartEventDeltaMessageContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentStartEventDeltaMessageContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentStartEventDeltaMessageContentType string

const (
	ChatContentStartEventDeltaMessageContentTypeText     ChatContentStartEventDeltaMessageContentType = "text"
	ChatContentStartEventDeltaMessageContentTypeThinking ChatContentStartEventDeltaMessageContentType = "thinking"
)

func NewChatContentStartEventDeltaMessageContentTypeFromString(s string) (ChatContentStartEventDeltaMessageContentType, error) {
	switch s {
	case "text":
		return ChatContentStartEventDeltaMessageContentTypeText, nil
	case "thinking":
		return ChatContentStartEventDeltaMessageContentTypeThinking, nil
	}
	var t ChatContentStartEventDeltaMessageContentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatContentStartEventDeltaMessageContentType) Ptr() *ChatContentStartEventDeltaMessageContentType {
	return &c
}

// A document source object containing the unique identifier of the document and the document itself.
type ChatDocumentSource struct {
	// The unique identifier of the document
	Id       *string                `json:"id,omitempty" url:"id,omitempty"`
	Document map[string]interface{} `json:"document,omitempty" url:"document,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatDocumentSource) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ChatDocumentSource) GetDocument() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Document
}

func (c *ChatDocumentSource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatDocumentSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatDocumentSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatDocumentSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatDocumentSource) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The reason a chat request has finished.
//
// - **complete**: The model finished sending a complete message.
// - **max_tokens**: The number of generated tokens exceeded the model's context length or the value specified via the `max_tokens` parameter.
// - **stop_sequence**: One of the provided `stop_sequence` entries was reached in the model's generation.
// - **tool_call**: The model generated a Tool Call and is expecting a Tool Message in return
// - **error**: The generation failed due to an internal error
// - **timeout**: The generation was stopped because it exceeded the allowed time limit.
type ChatFinishReason string

const (
	ChatFinishReasonComplete     ChatFinishReason = "COMPLETE"
	ChatFinishReasonStopSequence ChatFinishReason = "STOP_SEQUENCE"
	ChatFinishReasonMaxTokens    ChatFinishReason = "MAX_TOKENS"
	ChatFinishReasonToolCall     ChatFinishReason = "TOOL_CALL"
	ChatFinishReasonError        ChatFinishReason = "ERROR"
	ChatFinishReasonTimeout      ChatFinishReason = "TIMEOUT"
)

func NewChatFinishReasonFromString(s string) (ChatFinishReason, error) {
	switch s {
	case "COMPLETE":
		return ChatFinishReasonComplete, nil
	case "STOP_SEQUENCE":
		return ChatFinishReasonStopSequence, nil
	case "MAX_TOKENS":
		return ChatFinishReasonMaxTokens, nil
	case "TOOL_CALL":
		return ChatFinishReasonToolCall, nil
	case "ERROR":
		return ChatFinishReasonError, nil
	case "TIMEOUT":
		return ChatFinishReasonTimeout, nil
	}
	var t ChatFinishReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatFinishReason) Ptr() *ChatFinishReason {
	return &c
}

// A streamed event which signifies that the chat message has ended.
type ChatMessageEndEvent struct {
	Id    *string                   `json:"id,omitempty" url:"id,omitempty"`
	Delta *ChatMessageEndEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageEndEvent) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ChatMessageEndEvent) GetDelta() *ChatMessageEndEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatMessageEndEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageEndEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageEndEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatMessageEndEventDelta struct {
	// An error message if an error occurred during the generation.
	Error        *string           `json:"error,omitempty" url:"error,omitempty"`
	FinishReason *ChatFinishReason `json:"finish_reason,omitempty" url:"finish_reason,omitempty"`
	Usage        *Usage            `json:"usage,omitempty" url:"usage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageEndEventDelta) GetError() *string {
	if c == nil {
		return nil
	}
	return c.Error
}

func (c *ChatMessageEndEventDelta) GetFinishReason() *ChatFinishReason {
	if c == nil {
		return nil
	}
	return c.FinishReason
}

func (c *ChatMessageEndEventDelta) GetUsage() *Usage {
	if c == nil {
		return nil
	}
	return c.Usage
}

func (c *ChatMessageEndEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageEndEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageEndEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageEndEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageEndEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event which signifies that a stream has started.
type ChatMessageStartEvent struct {
	// Unique identifier for the generated reply.
	Id    *string                     `json:"id,omitempty" url:"id,omitempty"`
	Delta *ChatMessageStartEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageStartEvent) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ChatMessageStartEvent) GetDelta() *ChatMessageStartEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatMessageStartEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageStartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageStartEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatMessageStartEventDelta struct {
	Message *ChatMessageStartEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageStartEventDelta) GetMessage() *ChatMessageStartEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatMessageStartEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageStartEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageStartEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageStartEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageStartEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatMessageStartEventDeltaMessage struct {
	// The role of the message.
	Role *string `json:"role,omitempty" url:"role,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageStartEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageStartEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageStartEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageStartEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageStartEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a single message in the chat history from a given role.
type ChatMessageV2 struct {
	Role      string
	User      *UserMessageV2
	Assistant *AssistantMessage
	System    *SystemMessageV2
	Tool      *ToolMessageV2
}

func (c *ChatMessageV2) GetRole() string {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ChatMessageV2) GetUser() *UserMessageV2 {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *ChatMessageV2) GetAssistant() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ChatMessageV2) GetSystem() *SystemMessageV2 {
	if c == nil {
		return nil
	}
	return c.System
}

func (c *ChatMessageV2) GetTool() *ToolMessageV2 {
	if c == nil {
		return nil
	}
	return c.Tool
}

func (c *ChatMessageV2) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Role string `json:"role"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Role = unmarshaler.Role
	if unmarshaler.Role == "" {
		return fmt.Errorf("%T did not include discriminant role", c)
	}
	switch unmarshaler.Role {
	case "user":
		value := new(UserMessageV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.User = value
	case "assistant":
		value := new(AssistantMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Assistant = value
	case "system":
		value := new(SystemMessageV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.System = value
	case "tool":
		value := new(ToolMessageV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Tool = value
	}
	return nil
}

func (c ChatMessageV2) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.User != nil {
		return internal.MarshalJSONWithExtraProperty(c.User, "role", "user")
	}
	if c.Assistant != nil {
		return internal.MarshalJSONWithExtraProperty(c.Assistant, "role", "assistant")
	}
	if c.System != nil {
		return internal.MarshalJSONWithExtraProperty(c.System, "role", "system")
	}
	if c.Tool != nil {
		return internal.MarshalJSONWithExtraProperty(c.Tool, "role", "tool")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ChatMessageV2Visitor interface {
	VisitUser(*UserMessageV2) error
	VisitAssistant(*AssistantMessage) error
	VisitSystem(*SystemMessageV2) error
	VisitTool(*ToolMessageV2) error
}

func (c *ChatMessageV2) Accept(visitor ChatMessageV2Visitor) error {
	if c.User != nil {
		return visitor.VisitUser(c.User)
	}
	if c.Assistant != nil {
		return visitor.VisitAssistant(c.Assistant)
	}
	if c.System != nil {
		return visitor.VisitSystem(c.System)
	}
	if c.Tool != nil {
		return visitor.VisitTool(c.Tool)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ChatMessageV2) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.User != nil {
		fields = append(fields, "user")
	}
	if c.Assistant != nil {
		fields = append(fields, "assistant")
	}
	if c.System != nil {
		fields = append(fields, "system")
	}
	if c.Tool != nil {
		fields = append(fields, "tool")
	}
	if len(fields) == 0 {
		if c.Role != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Role)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Role != "" {
		field := fields[0]
		if c.Role != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Role,
				c,
			)
		}
	}
	return nil
}

// A list of chat messages in chronological order, representing a conversation between the user and the model.
//
// Messages can be from `User`, `Assistant`, `Tool` and `System` roles. Learn more about messages and roles in [the Chat API guide](https://docs.cohere.com/v2/docs/chat-api).
type ChatMessages = []*ChatMessageV2

// The streamed event types
type ChatStreamEventType struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatStreamEventType) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatStreamEventType) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamEventType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamEventType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamEventType) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Text content of the message.
type ChatTextContent struct {
	Text string `json:"text" url:"text"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatTextContent) GetText() string {
	if c == nil {
		return ""
	}
	return c.Text
}

func (c *ChatTextContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatTextContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatTextContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatTextContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatTextContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatTextResponseFormatV2 struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatTextResponseFormatV2) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatTextResponseFormatV2) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatTextResponseFormatV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatTextResponseFormatV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatTextResponseFormatV2) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Thinking content of the message. This will be present when `thinking` is enabled, and will contain the models internal reasoning.
type ChatThinkingContent struct {
	Thinking string `json:"thinking" url:"thinking"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatThinkingContent) GetThinking() string {
	if c == nil {
		return ""
	}
	return c.Thinking
}

func (c *ChatThinkingContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatThinkingContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatThinkingContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatThinkingContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatThinkingContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event delta which signifies a delta in tool call arguments.
type ChatToolCallDeltaEvent struct {
	Index *int                         `json:"index,omitempty" url:"index,omitempty"`
	Delta *ChatToolCallDeltaEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatToolCallDeltaEvent) GetDelta() *ChatToolCallDeltaEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatToolCallDeltaEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallDeltaEventDelta struct {
	Message *ChatToolCallDeltaEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEventDelta) GetMessage() *ChatToolCallDeltaEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatToolCallDeltaEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallDeltaEventDeltaMessage struct {
	ToolCalls *ChatToolCallDeltaEventDeltaMessageToolCalls `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEventDeltaMessage) GetToolCalls() *ChatToolCallDeltaEventDeltaMessageToolCalls {
	if c == nil {
		return nil
	}
	return c.ToolCalls
}

func (c *ChatToolCallDeltaEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallDeltaEventDeltaMessageToolCalls struct {
	Function *ChatToolCallDeltaEventDeltaMessageToolCallsFunction `json:"function,omitempty" url:"function,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCalls) GetFunction() *ChatToolCallDeltaEventDeltaMessageToolCallsFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCalls) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEventDeltaMessageToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEventDeltaMessageToolCalls(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCalls) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallDeltaEventDeltaMessageToolCallsFunction struct {
	Arguments *string `json:"arguments,omitempty" url:"arguments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCallsFunction) GetArguments() *string {
	if c == nil {
		return nil
	}
	return c.Arguments
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCallsFunction) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCallsFunction) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEventDeltaMessageToolCallsFunction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEventDeltaMessageToolCallsFunction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCallsFunction) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event delta which signifies a tool call has finished streaming.
type ChatToolCallEndEvent struct {
	Index *int `json:"index,omitempty" url:"index,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallEndEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatToolCallEndEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallEndEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallEndEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event delta which signifies a tool call has started streaming.
type ChatToolCallStartEvent struct {
	Index *int                         `json:"index,omitempty" url:"index,omitempty"`
	Delta *ChatToolCallStartEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallStartEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatToolCallStartEvent) GetDelta() *ChatToolCallStartEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatToolCallStartEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallStartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallStartEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallStartEventDelta struct {
	Message *ChatToolCallStartEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallStartEventDelta) GetMessage() *ChatToolCallStartEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatToolCallStartEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallStartEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallStartEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallStartEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallStartEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallStartEventDeltaMessage struct {
	ToolCalls *ToolCallV2 `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallStartEventDeltaMessage) GetToolCalls() *ToolCallV2 {
	if c == nil {
		return nil
	}
	return c.ToolCalls
}

func (c *ChatToolCallStartEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallStartEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallStartEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallStartEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallStartEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event which contains a delta of tool plan text.
type ChatToolPlanDeltaEvent struct {
	Delta *ChatToolPlanDeltaEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolPlanDeltaEvent) GetDelta() *ChatToolPlanDeltaEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatToolPlanDeltaEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolPlanDeltaEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolPlanDeltaEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolPlanDeltaEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolPlanDeltaEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolPlanDeltaEventDelta struct {
	Message *ChatToolPlanDeltaEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolPlanDeltaEventDelta) GetMessage() *ChatToolPlanDeltaEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatToolPlanDeltaEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolPlanDeltaEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolPlanDeltaEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolPlanDeltaEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolPlanDeltaEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolPlanDeltaEventDeltaMessage struct {
	ToolPlan *string `json:"tool_plan,omitempty" url:"tool_plan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolPlanDeltaEventDeltaMessage) GetToolPlan() *string {
	if c == nil {
		return nil
	}
	return c.ToolPlan
}

func (c *ChatToolPlanDeltaEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolPlanDeltaEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolPlanDeltaEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolPlanDeltaEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolPlanDeltaEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolSource struct {
	// The unique identifier of the document
	Id         *string                `json:"id,omitempty" url:"id,omitempty"`
	ToolOutput map[string]interface{} `json:"tool_output,omitempty" url:"tool_output,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolSource) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ChatToolSource) GetToolOutput() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.ToolOutput
}

func (c *ChatToolSource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolSource) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Citation information containing sources and the text cited.
type Citation struct {
	// Start index of the cited snippet in the original source text.
	Start *int `json:"start,omitempty" url:"start,omitempty"`
	// End index of the cited snippet in the original source text.
	End *int `json:"end,omitempty" url:"end,omitempty"`
	// Text snippet that is being cited.
	Text    *string   `json:"text,omitempty" url:"text,omitempty"`
	Sources []*Source `json:"sources,omitempty" url:"sources,omitempty"`
	// Index of the content block in which this citation appears.
	ContentIndex *int          `json:"content_index,omitempty" url:"content_index,omitempty"`
	Type         *CitationType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Citation) GetStart() *int {
	if c == nil {
		return nil
	}
	return c.Start
}

func (c *Citation) GetEnd() *int {
	if c == nil {
		return nil
	}
	return c.End
}

func (c *Citation) GetText() *string {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *Citation) GetSources() []*Source {
	if c == nil {
		return nil
	}
	return c.Sources
}

func (c *Citation) GetContentIndex() *int {
	if c == nil {
		return nil
	}
	return c.ContentIndex
}

func (c *Citation) GetType() *CitationType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *Citation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Citation) UnmarshalJSON(data []byte) error {
	type unmarshaler Citation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Citation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Citation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event which signifies a citation has finished streaming.
type CitationEndEvent struct {
	Index *int `json:"index,omitempty" url:"index,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationEndEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *CitationEndEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationEndEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationEndEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Options for controlling citation generation.
type CitationOptions struct {
	// Defaults to `"enabled"`.
	// Citations are enabled by default for models that support it, but can be turned off by setting `"type": "disabled"`.
	Mode *CitationOptionsMode `json:"mode,omitempty" url:"mode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationOptions) GetMode() *CitationOptionsMode {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CitationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `"enabled"`.
// Citations are enabled by default for models that support it, but can be turned off by setting `"type": "disabled"`.
type CitationOptionsMode string

const (
	CitationOptionsModeEnabled  CitationOptionsMode = "ENABLED"
	CitationOptionsModeDisabled CitationOptionsMode = "DISABLED"
	CitationOptionsModeFast     CitationOptionsMode = "FAST"
	CitationOptionsModeAccurate CitationOptionsMode = "ACCURATE"
	CitationOptionsModeOff      CitationOptionsMode = "OFF"
)

func NewCitationOptionsModeFromString(s string) (CitationOptionsMode, error) {
	switch s {
	case "ENABLED":
		return CitationOptionsModeEnabled, nil
	case "DISABLED":
		return CitationOptionsModeDisabled, nil
	case "FAST":
		return CitationOptionsModeFast, nil
	case "ACCURATE":
		return CitationOptionsModeAccurate, nil
	case "OFF":
		return CitationOptionsModeOff, nil
	}
	var t CitationOptionsMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CitationOptionsMode) Ptr() *CitationOptionsMode {
	return &c
}

// A streamed event which signifies a citation has been created.
type CitationStartEvent struct {
	Index *int                     `json:"index,omitempty" url:"index,omitempty"`
	Delta *CitationStartEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationStartEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *CitationStartEvent) GetDelta() *CitationStartEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *CitationStartEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationStartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationStartEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CitationStartEventDelta struct {
	Message *CitationStartEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationStartEventDelta) GetMessage() *CitationStartEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *CitationStartEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationStartEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationStartEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationStartEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationStartEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CitationStartEventDeltaMessage struct {
	Citations *Citation `json:"citations,omitempty" url:"citations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationStartEventDeltaMessage) GetCitations() *Citation {
	if c == nil {
		return nil
	}
	return c.Citations
}

func (c *CitationStartEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationStartEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationStartEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationStartEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationStartEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of citation which indicates what part of the response the citation is for.
type CitationType string

const (
	CitationTypeTextContent     CitationType = "TEXT_CONTENT"
	CitationTypeThinkingContent CitationType = "THINKING_CONTENT"
	CitationTypePlan            CitationType = "PLAN"
)

func NewCitationTypeFromString(s string) (CitationType, error) {
	switch s {
	case "TEXT_CONTENT":
		return CitationTypeTextContent, nil
	case "THINKING_CONTENT":
		return CitationTypeThinkingContent, nil
	case "PLAN":
		return CitationTypePlan, nil
	}
	var t CitationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CitationType) Ptr() *CitationType {
	return &c
}

// A Content block which contains information about the content type and the content itself.
type Content struct {
	Type     string
	Text     *ChatTextContent
	ImageUrl *ImageContent
}

func (c *Content) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *Content) GetText() *ChatTextContent {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *Content) GetImageUrl() *ImageContent {
	if c == nil {
		return nil
	}
	return c.ImageUrl
}

func (c *Content) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Text = value
	case "image_url":
		value := new(ImageContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ImageUrl = value
	}
	return nil
}

func (c Content) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.Text != nil {
		return internal.MarshalJSONWithExtraProperty(c.Text, "type", "text")
	}
	if c.ImageUrl != nil {
		return internal.MarshalJSONWithExtraProperty(c.ImageUrl, "type", "image_url")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ContentVisitor interface {
	VisitText(*ChatTextContent) error
	VisitImageUrl(*ImageContent) error
}

func (c *Content) Accept(visitor ContentVisitor) error {
	if c.Text != nil {
		return visitor.VisitText(c.Text)
	}
	if c.ImageUrl != nil {
		return visitor.VisitImageUrl(c.ImageUrl)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *Content) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Text != nil {
		fields = append(fields, "text")
	}
	if c.ImageUrl != nil {
		fields = append(fields, "image_url")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

// Relevant information that could be used by the model to generate a more accurate reply.
// The content of each document are generally short (should be under 300 words). Metadata should be used to provide additional information, both the key name and the value will be
// passed to the model.
type Document struct {
	// A relevant document that the model can cite to generate a more accurate reply. Each document is a string-any dictionary.
	Data map[string]interface{} `json:"data" url:"data"`
	// Unique identifier for this document which will be referenced in citations. If not provided an ID will be automatically generated.
	Id *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Document) GetData() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *Document) GetId() *string {
	if d == nil {
		return nil
	}
	return d.Id
}

func (d *Document) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Document) UnmarshalJSON(data []byte) error {
	type unmarshaler Document
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Document(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Document) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Document content.
type DocumentContent struct {
	Document *Document `json:"document" url:"document"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentContent) GetDocument() *Document {
	if d == nil {
		return nil
	}
	return d.Document
}

func (d *DocumentContent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentContent) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentContent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EmbedContent struct {
	Type     string
	ImageUrl *EmbedImage
	Text     *EmbedText
}

func (e *EmbedContent) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EmbedContent) GetImageUrl() *EmbedImage {
	if e == nil {
		return nil
	}
	return e.ImageUrl
}

func (e *EmbedContent) GetText() *EmbedText {
	if e == nil {
		return nil
	}
	return e.Text
}

func (e *EmbedContent) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "image_url":
		value := new(EmbedImage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ImageUrl = value
	case "text":
		value := new(EmbedText)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Text = value
	}
	return nil
}

func (e EmbedContent) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.ImageUrl != nil {
		return internal.MarshalJSONWithExtraProperty(e.ImageUrl, "type", "image_url")
	}
	if e.Text != nil {
		return internal.MarshalJSONWithExtraProperty(e.Text, "type", "text")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EmbedContentVisitor interface {
	VisitImageUrl(*EmbedImage) error
	VisitText(*EmbedText) error
}

func (e *EmbedContent) Accept(visitor EmbedContentVisitor) error {
	if e.ImageUrl != nil {
		return visitor.VisitImageUrl(e.ImageUrl)
	}
	if e.Text != nil {
		return visitor.VisitText(e.Text)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *EmbedContent) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.ImageUrl != nil {
		fields = append(fields, "image_url")
	}
	if e.Text != nil {
		fields = append(fields, "text")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

// Image content of the input. Supported with Embed v3.0 and newer models.
type EmbedImage struct {
	ImageUrl *EmbedImageUrl `json:"image_url,omitempty" url:"image_url,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmbedImage) GetImageUrl() *EmbedImageUrl {
	if e == nil {
		return nil
	}
	return e.ImageUrl
}

func (e *EmbedImage) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedImage) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedImage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedImage) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Base64 url of image.
type EmbedImageUrl struct {
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmbedImageUrl) GetUrl() string {
	if e == nil {
		return ""
	}
	return e.Url
}

func (e *EmbedImageUrl) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedImageUrl) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedImageUrl
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedImageUrl(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedImageUrl) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmbedInput struct {
	// An array of objects containing the input data for the model to embed.
	Content []*EmbedContent `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmbedInput) GetContent() []*EmbedContent {
	if e == nil {
		return nil
	}
	return e.Content
}

func (e *EmbedInput) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedInput) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedInput(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedInput) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Text content of the input.
type EmbedText struct {
	Text *string `json:"text,omitempty" url:"text,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmbedText) GetText() *string {
	if e == nil {
		return nil
	}
	return e.Text
}

func (e *EmbedText) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedText) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedText(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedText) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Image content of the message.
type ImageContent struct {
	ImageUrl *ImageUrl `json:"image_url" url:"image_url"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ImageContent) GetImageUrl() *ImageUrl {
	if i == nil {
		return nil
	}
	return i.ImageUrl
}

func (i *ImageContent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ImageContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ImageContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ImageContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImageContent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type ImageUrl struct {
	// URL of an image. Can be either a base64 data URI or a web URL.
	Url string `json:"url" url:"url"`
	// Controls the level of detail in image processing. `"auto"` is the default and lets the system choose, `"low"` is faster but less detailed, and `"high"` preserves maximum detail. You can save tokens and speed up responses by using detail: `"low"`.
	Detail *ImageUrlDetail `json:"detail,omitempty" url:"detail,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ImageUrl) GetUrl() string {
	if i == nil {
		return ""
	}
	return i.Url
}

func (i *ImageUrl) GetDetail() *ImageUrlDetail {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *ImageUrl) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ImageUrl) UnmarshalJSON(data []byte) error {
	type unmarshaler ImageUrl
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ImageUrl(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImageUrl) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Controls the level of detail in image processing. `"auto"` is the default and lets the system choose, `"low"` is faster but less detailed, and `"high"` preserves maximum detail. You can save tokens and speed up responses by using detail: `"low"`.
type ImageUrlDetail string

const (
	ImageUrlDetailAuto ImageUrlDetail = "auto"
	ImageUrlDetailLow  ImageUrlDetail = "low"
	ImageUrlDetailHigh ImageUrlDetail = "high"
)

func NewImageUrlDetailFromString(s string) (ImageUrlDetail, error) {
	switch s {
	case "auto":
		return ImageUrlDetailAuto, nil
	case "low":
		return ImageUrlDetailLow, nil
	case "high":
		return ImageUrlDetailHigh, nil
	}
	var t ImageUrlDetail
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i ImageUrlDetail) Ptr() *ImageUrlDetail {
	return &i
}

type JsonResponseFormatV2 struct {
	// A [JSON schema](https://json-schema.org/overview/what-is-jsonschema) object that the output will adhere to. There are some restrictions we have on the schema, refer to [our guide](https://docs.cohere.com/docs/structured-outputs-json#schema-constraints) for more information.
	// Example (required name and age object):
	// ```json
	//
	//	{
	//	  "type": "object",
	//	  "properties": {
	//	    "name": {"type": "string"},
	//	    "age": {"type": "integer"}
	//	  },
	//	  "required": ["name", "age"]
	//	}
	//
	// ```
	//
	// **Note**: This field must not be specified when the `type` is set to `"text"`.
	JsonSchema map[string]interface{} `json:"json_schema,omitempty" url:"json_schema,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JsonResponseFormatV2) GetJsonSchema() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.JsonSchema
}

func (j *JsonResponseFormatV2) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonResponseFormatV2) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonResponseFormatV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonResponseFormatV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonResponseFormatV2) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type LogprobItem struct {
	// The text chunk for which the log probabilities was calculated.
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// The token ids of each token used to construct the text chunk.
	TokenIds []int `json:"token_ids" url:"token_ids"`
	// The log probability of each token used to construct the text chunk.
	Logprobs []float64 `json:"logprobs,omitempty" url:"logprobs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogprobItem) GetText() *string {
	if l == nil {
		return nil
	}
	return l.Text
}

func (l *LogprobItem) GetTokenIds() []int {
	if l == nil {
		return nil
	}
	return l.TokenIds
}

func (l *LogprobItem) GetLogprobs() []float64 {
	if l == nil {
		return nil
	}
	return l.Logprobs
}

func (l *LogprobItem) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogprobItem) UnmarshalJSON(data []byte) error {
	type unmarshaler LogprobItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogprobItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogprobItem) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Configuration for forcing the model output to adhere to the specified format. Supported on [Command R](https://docs.cohere.com/v2/docs/command-r), [Command R+](https://docs.cohere.com/v2/docs/command-r-plus) and newer models.
//
// The model can be forced into outputting JSON objects by setting `{ "type": "json_object" }`.
//
// A [JSON Schema](https://json-schema.org/) can optionally be provided, to ensure a specific structure.
//
// **Note**: When using  `{ "type": "json_object" }` your `message` should always explicitly instruct the model to generate a JSON (eg: _"Generate a JSON ..."_) . Otherwise the model may end up getting stuck generating an infinite stream of characters and eventually run out of context length.
//
// **Note**: When `json_schema` is not specified, the generated object can have up to 5 layers of nesting.
//
// **Limitation**: The parameter is not supported when used in combinations with the `documents` or `tools` parameters.
type ResponseFormatV2 struct {
	Type       string
	Text       *ChatTextResponseFormatV2
	JsonObject *JsonResponseFormatV2
}

func (r *ResponseFormatV2) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseFormatV2) GetText() *ChatTextResponseFormatV2 {
	if r == nil {
		return nil
	}
	return r.Text
}

func (r *ResponseFormatV2) GetJsonObject() *JsonResponseFormatV2 {
	if r == nil {
		return nil
	}
	return r.JsonObject
}

func (r *ResponseFormatV2) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextResponseFormatV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Text = value
	case "json_object":
		value := new(JsonResponseFormatV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.JsonObject = value
	}
	return nil
}

func (r ResponseFormatV2) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Text != nil {
		return internal.MarshalJSONWithExtraProperty(r.Text, "type", "text")
	}
	if r.JsonObject != nil {
		return internal.MarshalJSONWithExtraProperty(r.JsonObject, "type", "json_object")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type ResponseFormatV2Visitor interface {
	VisitText(*ChatTextResponseFormatV2) error
	VisitJsonObject(*JsonResponseFormatV2) error
}

func (r *ResponseFormatV2) Accept(visitor ResponseFormatV2Visitor) error {
	if r.Text != nil {
		return visitor.VisitText(r.Text)
	}
	if r.JsonObject != nil {
		return visitor.VisitJsonObject(r.JsonObject)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *ResponseFormatV2) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Text != nil {
		fields = append(fields, "text")
	}
	if r.JsonObject != nil {
		fields = append(fields, "json_object")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

// A source object containing information about the source of the data cited.
type Source struct {
	Type     string
	Tool     *ChatToolSource
	Document *ChatDocumentSource
}

func (s *Source) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *Source) GetTool() *ChatToolSource {
	if s == nil {
		return nil
	}
	return s.Tool
}

func (s *Source) GetDocument() *ChatDocumentSource {
	if s == nil {
		return nil
	}
	return s.Document
}

func (s *Source) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "tool":
		value := new(ChatToolSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Tool = value
	case "document":
		value := new(ChatDocumentSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Document = value
	}
	return nil
}

func (s Source) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Tool != nil {
		return internal.MarshalJSONWithExtraProperty(s.Tool, "type", "tool")
	}
	if s.Document != nil {
		return internal.MarshalJSONWithExtraProperty(s.Document, "type", "document")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SourceVisitor interface {
	VisitTool(*ChatToolSource) error
	VisitDocument(*ChatDocumentSource) error
}

func (s *Source) Accept(visitor SourceVisitor) error {
	if s.Tool != nil {
		return visitor.VisitTool(s.Tool)
	}
	if s.Document != nil {
		return visitor.VisitDocument(s.Document)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *Source) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Tool != nil {
		fields = append(fields, "tool")
	}
	if s.Document != nil {
		fields = append(fields, "document")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

// A message from the system.
type SystemMessageV2 struct {
	Content *SystemMessageV2Content `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SystemMessageV2) GetContent() *SystemMessageV2Content {
	if s == nil {
		return nil
	}
	return s.Content
}

func (s *SystemMessageV2) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SystemMessageV2) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemMessageV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemMessageV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemMessageV2) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SystemMessageV2Content struct {
	String                         string
	SystemMessageV2ContentItemList []*SystemMessageV2ContentItem

	typ string
}

func (s *SystemMessageV2Content) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SystemMessageV2Content) GetSystemMessageV2ContentItemList() []*SystemMessageV2ContentItem {
	if s == nil {
		return nil
	}
	return s.SystemMessageV2ContentItemList
}

func (s *SystemMessageV2Content) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueSystemMessageV2ContentItemList []*SystemMessageV2ContentItem
	if err := json.Unmarshal(data, &valueSystemMessageV2ContentItemList); err == nil {
		s.typ = "SystemMessageV2ContentItemList"
		s.SystemMessageV2ContentItemList = valueSystemMessageV2ContentItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SystemMessageV2Content) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "SystemMessageV2ContentItemList" || s.SystemMessageV2ContentItemList != nil {
		return json.Marshal(s.SystemMessageV2ContentItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SystemMessageV2ContentVisitor interface {
	VisitString(string) error
	VisitSystemMessageV2ContentItemList([]*SystemMessageV2ContentItem) error
}

func (s *SystemMessageV2Content) Accept(visitor SystemMessageV2ContentVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "SystemMessageV2ContentItemList" || s.SystemMessageV2ContentItemList != nil {
		return visitor.VisitSystemMessageV2ContentItemList(s.SystemMessageV2ContentItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SystemMessageV2ContentItem struct {
	Type string
	Text *ChatTextContent
}

func (s *SystemMessageV2ContentItem) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SystemMessageV2ContentItem) GetText() *ChatTextContent {
	if s == nil {
		return nil
	}
	return s.Text
}

func (s *SystemMessageV2ContentItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Text = value
	}
	return nil
}

func (s SystemMessageV2ContentItem) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Text != nil {
		return internal.MarshalJSONWithExtraProperty(s.Text, "type", "text")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SystemMessageV2ContentItemVisitor interface {
	VisitText(*ChatTextContent) error
}

func (s *SystemMessageV2ContentItem) Accept(visitor SystemMessageV2ContentItemVisitor) error {
	if s.Text != nil {
		return visitor.VisitText(s.Text)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SystemMessageV2ContentItem) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Text != nil {
		fields = append(fields, "text")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

// Configuration for [reasoning features](https://docs.cohere.com/docs/reasoning).
type Thinking struct {
	// Reasoning is enabled by default for models that support it, but can be turned off by setting `"type": "disabled"`.
	Type ThinkingType `json:"type" url:"type"`
	// The maximum number of tokens the model can use for thinking, which must be set to a positive integer.
	// The model will stop thinking if it reaches the thinking token budget and will proceed with the response.
	TokenBudget *int `json:"token_budget,omitempty" url:"token_budget,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Thinking) GetType() ThinkingType {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Thinking) GetTokenBudget() *int {
	if t == nil {
		return nil
	}
	return t.TokenBudget
}

func (t *Thinking) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Thinking) UnmarshalJSON(data []byte) error {
	type unmarshaler Thinking
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Thinking(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Thinking) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Reasoning is enabled by default for models that support it, but can be turned off by setting `"type": "disabled"`.
type ThinkingType string

const (
	ThinkingTypeEnabled  ThinkingType = "enabled"
	ThinkingTypeDisabled ThinkingType = "disabled"
)

func NewThinkingTypeFromString(s string) (ThinkingType, error) {
	switch s {
	case "enabled":
		return ThinkingTypeEnabled, nil
	case "disabled":
		return ThinkingTypeDisabled, nil
	}
	var t ThinkingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t ThinkingType) Ptr() *ThinkingType {
	return &t
}

// An array of tool calls to be made.
type ToolCallV2 struct {
	Id       *string             `json:"id,omitempty" url:"id,omitempty"`
	Type     *string             `json:"type,omitempty" url:"type,omitempty"`
	Function *ToolCallV2Function `json:"function,omitempty" url:"function,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallV2) GetId() *string {
	if t == nil {
		return nil
	}
	return t.Id
}

func (t *ToolCallV2) GetFunction() *ToolCallV2Function {
	if t == nil {
		return nil
	}
	return t.Function
}

func (t *ToolCallV2) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallV2) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallV2) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallV2Function struct {
	Name      *string `json:"name,omitempty" url:"name,omitempty"`
	Arguments *string `json:"arguments,omitempty" url:"arguments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallV2Function) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *ToolCallV2Function) GetArguments() *string {
	if t == nil {
		return nil
	}
	return t.Arguments
}

func (t *ToolCallV2Function) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallV2Function) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallV2Function
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallV2Function(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallV2Function) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// A content block which contains information about the content of a tool result
type ToolContent struct {
	Type     string
	Text     *ChatTextContent
	Document *DocumentContent
}

func (t *ToolContent) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *ToolContent) GetText() *ChatTextContent {
	if t == nil {
		return nil
	}
	return t.Text
}

func (t *ToolContent) GetDocument() *DocumentContent {
	if t == nil {
		return nil
	}
	return t.Document
}

func (t *ToolContent) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Text = value
	case "document":
		value := new(DocumentContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Document = value
	}
	return nil
}

func (t ToolContent) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.Text != nil {
		return internal.MarshalJSONWithExtraProperty(t.Text, "type", "text")
	}
	if t.Document != nil {
		return internal.MarshalJSONWithExtraProperty(t.Document, "type", "document")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type ToolContentVisitor interface {
	VisitText(*ChatTextContent) error
	VisitDocument(*DocumentContent) error
}

func (t *ToolContent) Accept(visitor ToolContentVisitor) error {
	if t.Text != nil {
		return visitor.VisitText(t.Text)
	}
	if t.Document != nil {
		return visitor.VisitDocument(t.Document)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *ToolContent) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Text != nil {
		fields = append(fields, "text")
	}
	if t.Document != nil {
		fields = append(fields, "document")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

// A message with Tool outputs.
type ToolMessageV2 struct {
	// The id of the associated tool call that has provided the given content
	ToolCallId string `json:"tool_call_id" url:"tool_call_id"`
	// Outputs from a tool. The content should formatted as a JSON object string, or a list of tool content blocks
	Content *ToolMessageV2Content `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageV2) GetToolCallId() string {
	if t == nil {
		return ""
	}
	return t.ToolCallId
}

func (t *ToolMessageV2) GetContent() *ToolMessageV2Content {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageV2) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageV2) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolMessageV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolMessageV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageV2) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Outputs from a tool. The content should formatted as a JSON object string, or a list of tool content blocks
type ToolMessageV2Content struct {
	String          string
	ToolContentList []*ToolContent

	typ string
}

func (t *ToolMessageV2Content) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *ToolMessageV2Content) GetToolContentList() []*ToolContent {
	if t == nil {
		return nil
	}
	return t.ToolContentList
}

func (t *ToolMessageV2Content) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	var valueToolContentList []*ToolContent
	if err := json.Unmarshal(data, &valueToolContentList); err == nil {
		t.typ = "ToolContentList"
		t.ToolContentList = valueToolContentList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolMessageV2Content) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "ToolContentList" || t.ToolContentList != nil {
		return json.Marshal(t.ToolContentList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolMessageV2ContentVisitor interface {
	VisitString(string) error
	VisitToolContentList([]*ToolContent) error
}

func (t *ToolMessageV2Content) Accept(visitor ToolMessageV2ContentVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "ToolContentList" || t.ToolContentList != nil {
		return visitor.VisitToolContentList(t.ToolContentList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolV2 struct {
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The function to be executed.
	Function *ToolV2Function `json:"function,omitempty" url:"function,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolV2) GetFunction() *ToolV2Function {
	if t == nil {
		return nil
	}
	return t.Function
}

func (t *ToolV2) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolV2) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolV2) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The function to be executed.
type ToolV2Function struct {
	// The name of the function.
	Name string `json:"name" url:"name"`
	// The description of the function.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The parameters of the function as a JSON schema.
	Parameters map[string]interface{} `json:"parameters" url:"parameters"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolV2Function) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *ToolV2Function) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *ToolV2Function) GetParameters() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Parameters
}

func (t *ToolV2Function) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolV2Function) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolV2Function
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolV2Function(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolV2Function) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Usage struct {
	BilledUnits *UsageBilledUnits `json:"billed_units,omitempty" url:"billed_units,omitempty"`
	Tokens      *UsageTokens      `json:"tokens,omitempty" url:"tokens,omitempty"`
	// The number of prompt tokens that hit the inference cache.
	CachedTokens *float64 `json:"cached_tokens,omitempty" url:"cached_tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *Usage) GetBilledUnits() *UsageBilledUnits {
	if u == nil {
		return nil
	}
	return u.BilledUnits
}

func (u *Usage) GetTokens() *UsageTokens {
	if u == nil {
		return nil
	}
	return u.Tokens
}

func (u *Usage) GetCachedTokens() *float64 {
	if u == nil {
		return nil
	}
	return u.CachedTokens
}

func (u *Usage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Usage) UnmarshalJSON(data []byte) error {
	type unmarshaler Usage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Usage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *Usage) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UsageBilledUnits struct {
	// The number of billed input tokens.
	InputTokens *float64 `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// The number of billed output tokens.
	OutputTokens *float64 `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`
	// The number of billed search units.
	SearchUnits *float64 `json:"search_units,omitempty" url:"search_units,omitempty"`
	// The number of billed classifications units.
	Classifications *float64 `json:"classifications,omitempty" url:"classifications,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UsageBilledUnits) GetInputTokens() *float64 {
	if u == nil {
		return nil
	}
	return u.InputTokens
}

func (u *UsageBilledUnits) GetOutputTokens() *float64 {
	if u == nil {
		return nil
	}
	return u.OutputTokens
}

func (u *UsageBilledUnits) GetSearchUnits() *float64 {
	if u == nil {
		return nil
	}
	return u.SearchUnits
}

func (u *UsageBilledUnits) GetClassifications() *float64 {
	if u == nil {
		return nil
	}
	return u.Classifications
}

func (u *UsageBilledUnits) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsageBilledUnits) UnmarshalJSON(data []byte) error {
	type unmarshaler UsageBilledUnits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsageBilledUnits(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsageBilledUnits) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UsageTokens struct {
	// The number of tokens used as input to the model.
	InputTokens *float64 `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// The number of tokens produced by the model.
	OutputTokens *float64 `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UsageTokens) GetInputTokens() *float64 {
	if u == nil {
		return nil
	}
	return u.InputTokens
}

func (u *UsageTokens) GetOutputTokens() *float64 {
	if u == nil {
		return nil
	}
	return u.OutputTokens
}

func (u *UsageTokens) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsageTokens) UnmarshalJSON(data []byte) error {
	type unmarshaler UsageTokens
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsageTokens(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsageTokens) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// A message from the user.
type UserMessageV2 struct {
	// The content of the message. This can be a string or a list of content blocks.
	// If a string is provided, it will be treated as a text content block.
	Content *UserMessageV2Content `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserMessageV2) GetContent() *UserMessageV2Content {
	if u == nil {
		return nil
	}
	return u.Content
}

func (u *UserMessageV2) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserMessageV2) UnmarshalJSON(data []byte) error {
	type unmarshaler UserMessageV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserMessageV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserMessageV2) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The content of the message. This can be a string or a list of content blocks.
// If a string is provided, it will be treated as a text content block.
type UserMessageV2Content struct {
	String      string
	ContentList []*Content

	typ string
}

func (u *UserMessageV2Content) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UserMessageV2Content) GetContentList() []*Content {
	if u == nil {
		return nil
	}
	return u.ContentList
}

func (u *UserMessageV2Content) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typ = "String"
		u.String = valueString
		return nil
	}
	var valueContentList []*Content
	if err := json.Unmarshal(data, &valueContentList); err == nil {
		u.typ = "ContentList"
		u.ContentList = valueContentList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UserMessageV2Content) MarshalJSON() ([]byte, error) {
	if u.typ == "String" || u.String != "" {
		return json.Marshal(u.String)
	}
	if u.typ == "ContentList" || u.ContentList != nil {
		return json.Marshal(u.ContentList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UserMessageV2ContentVisitor interface {
	VisitString(string) error
	VisitContentList([]*Content) error
}

func (u *UserMessageV2Content) Accept(visitor UserMessageV2ContentVisitor) error {
	if u.typ == "String" || u.String != "" {
		return visitor.VisitString(u.String)
	}
	if u.typ == "ContentList" || u.ContentList != nil {
		return visitor.VisitContentList(u.ContentList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type V2ChatRequestDocumentsItem struct {
	String   string
	Document *Document

	typ string
}

func (v *V2ChatRequestDocumentsItem) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *V2ChatRequestDocumentsItem) GetDocument() *Document {
	if v == nil {
		return nil
	}
	return v.Document
}

func (v *V2ChatRequestDocumentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueDocument := new(Document)
	if err := json.Unmarshal(data, &valueDocument); err == nil {
		v.typ = "Document"
		v.Document = valueDocument
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v V2ChatRequestDocumentsItem) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Document" || v.Document != nil {
		return json.Marshal(v.Document)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type V2ChatRequestDocumentsItemVisitor interface {
	VisitString(string) error
	VisitDocument(*Document) error
}

func (v *V2ChatRequestDocumentsItem) Accept(visitor V2ChatRequestDocumentsItemVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Document" || v.Document != nil {
		return visitor.VisitDocument(v.Document)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// Used to select the [safety instruction](https://docs.cohere.com/v2/docs/safety-modes) inserted into the prompt. Defaults to `CONTEXTUAL`.
// When `OFF` is specified, the safety instruction will be omitted.
//
// Safety modes are not yet configurable in combination with `tools` and `documents` parameters.
//
// **Note**: This parameter is only compatible newer Cohere models, starting with [Command R 08-2024](https://docs.cohere.com/docs/command-r#august-2024-release) and [Command R+ 08-2024](https://docs.cohere.com/docs/command-r-plus#august-2024-release).
//
// **Note**: `command-r7b-12-2024` and newer models only support `"CONTEXTUAL"` and `"STRICT"` modes.
type V2ChatRequestSafetyMode string

const (
	V2ChatRequestSafetyModeContextual V2ChatRequestSafetyMode = "CONTEXTUAL"
	V2ChatRequestSafetyModeStrict     V2ChatRequestSafetyMode = "STRICT"
	V2ChatRequestSafetyModeOff        V2ChatRequestSafetyMode = "OFF"
)

func NewV2ChatRequestSafetyModeFromString(s string) (V2ChatRequestSafetyMode, error) {
	switch s {
	case "CONTEXTUAL":
		return V2ChatRequestSafetyModeContextual, nil
	case "STRICT":
		return V2ChatRequestSafetyModeStrict, nil
	case "OFF":
		return V2ChatRequestSafetyModeOff, nil
	}
	var t V2ChatRequestSafetyMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ChatRequestSafetyMode) Ptr() *V2ChatRequestSafetyMode {
	return &v
}

// Used to control whether or not the model will be forced to use a tool when answering. When `REQUIRED` is specified, the model will be forced to use at least one of the user-defined tools, and the `tools` parameter must be passed in the request.
// When `NONE` is specified, the model will be forced **not** to use one of the specified tools, and give a direct response.
// If tool_choice isn't specified, then the model is free to choose whether to use the specified tools or not.
//
// **Note**: This parameter is only compatible with models [Command-r7b](https://docs.cohere.com/v2/docs/command-r7b) and newer.
type V2ChatRequestToolChoice string

const (
	V2ChatRequestToolChoiceRequired V2ChatRequestToolChoice = "REQUIRED"
	V2ChatRequestToolChoiceNone     V2ChatRequestToolChoice = "NONE"
)

func NewV2ChatRequestToolChoiceFromString(s string) (V2ChatRequestToolChoice, error) {
	switch s {
	case "REQUIRED":
		return V2ChatRequestToolChoiceRequired, nil
	case "NONE":
		return V2ChatRequestToolChoiceNone, nil
	}
	var t V2ChatRequestToolChoice
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ChatRequestToolChoice) Ptr() *V2ChatRequestToolChoice {
	return &v
}

type V2ChatResponse struct {
	// Unique identifier for the generated reply. Useful for submitting feedback.
	Id           string                    `json:"id" url:"id"`
	FinishReason ChatFinishReason          `json:"finish_reason" url:"finish_reason"`
	Message      *AssistantMessageResponse `json:"message" url:"message"`
	Usage        *Usage                    `json:"usage,omitempty" url:"usage,omitempty"`
	Logprobs     []*LogprobItem            `json:"logprobs,omitempty" url:"logprobs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V2ChatResponse) GetId() string {
	if v == nil {
		return ""
	}
	return v.Id
}

func (v *V2ChatResponse) GetFinishReason() ChatFinishReason {
	if v == nil {
		return ""
	}
	return v.FinishReason
}

func (v *V2ChatResponse) GetMessage() *AssistantMessageResponse {
	if v == nil {
		return nil
	}
	return v.Message
}

func (v *V2ChatResponse) GetUsage() *Usage {
	if v == nil {
		return nil
	}
	return v.Usage
}

func (v *V2ChatResponse) GetLogprobs() []*LogprobItem {
	if v == nil {
		return nil
	}
	return v.Logprobs
}

func (v *V2ChatResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V2ChatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V2ChatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V2ChatResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V2ChatResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V2ChatStreamRequestDocumentsItem struct {
	String   string
	Document *Document

	typ string
}

func (v *V2ChatStreamRequestDocumentsItem) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *V2ChatStreamRequestDocumentsItem) GetDocument() *Document {
	if v == nil {
		return nil
	}
	return v.Document
}

func (v *V2ChatStreamRequestDocumentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueDocument := new(Document)
	if err := json.Unmarshal(data, &valueDocument); err == nil {
		v.typ = "Document"
		v.Document = valueDocument
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v V2ChatStreamRequestDocumentsItem) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Document" || v.Document != nil {
		return json.Marshal(v.Document)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type V2ChatStreamRequestDocumentsItemVisitor interface {
	VisitString(string) error
	VisitDocument(*Document) error
}

func (v *V2ChatStreamRequestDocumentsItem) Accept(visitor V2ChatStreamRequestDocumentsItemVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Document" || v.Document != nil {
		return visitor.VisitDocument(v.Document)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// Used to select the [safety instruction](https://docs.cohere.com/v2/docs/safety-modes) inserted into the prompt. Defaults to `CONTEXTUAL`.
// When `OFF` is specified, the safety instruction will be omitted.
//
// Safety modes are not yet configurable in combination with `tools` and `documents` parameters.
//
// **Note**: This parameter is only compatible newer Cohere models, starting with [Command R 08-2024](https://docs.cohere.com/docs/command-r#august-2024-release) and [Command R+ 08-2024](https://docs.cohere.com/docs/command-r-plus#august-2024-release).
//
// **Note**: `command-r7b-12-2024` and newer models only support `"CONTEXTUAL"` and `"STRICT"` modes.
type V2ChatStreamRequestSafetyMode string

const (
	V2ChatStreamRequestSafetyModeContextual V2ChatStreamRequestSafetyMode = "CONTEXTUAL"
	V2ChatStreamRequestSafetyModeStrict     V2ChatStreamRequestSafetyMode = "STRICT"
	V2ChatStreamRequestSafetyModeOff        V2ChatStreamRequestSafetyMode = "OFF"
)

func NewV2ChatStreamRequestSafetyModeFromString(s string) (V2ChatStreamRequestSafetyMode, error) {
	switch s {
	case "CONTEXTUAL":
		return V2ChatStreamRequestSafetyModeContextual, nil
	case "STRICT":
		return V2ChatStreamRequestSafetyModeStrict, nil
	case "OFF":
		return V2ChatStreamRequestSafetyModeOff, nil
	}
	var t V2ChatStreamRequestSafetyMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ChatStreamRequestSafetyMode) Ptr() *V2ChatStreamRequestSafetyMode {
	return &v
}

// Used to control whether or not the model will be forced to use a tool when answering. When `REQUIRED` is specified, the model will be forced to use at least one of the user-defined tools, and the `tools` parameter must be passed in the request.
// When `NONE` is specified, the model will be forced **not** to use one of the specified tools, and give a direct response.
// If tool_choice isn't specified, then the model is free to choose whether to use the specified tools or not.
//
// **Note**: This parameter is only compatible with models [Command-r7b](https://docs.cohere.com/v2/docs/command-r7b) and newer.
type V2ChatStreamRequestToolChoice string

const (
	V2ChatStreamRequestToolChoiceRequired V2ChatStreamRequestToolChoice = "REQUIRED"
	V2ChatStreamRequestToolChoiceNone     V2ChatStreamRequestToolChoice = "NONE"
)

func NewV2ChatStreamRequestToolChoiceFromString(s string) (V2ChatStreamRequestToolChoice, error) {
	switch s {
	case "REQUIRED":
		return V2ChatStreamRequestToolChoiceRequired, nil
	case "NONE":
		return V2ChatStreamRequestToolChoiceNone, nil
	}
	var t V2ChatStreamRequestToolChoice
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ChatStreamRequestToolChoice) Ptr() *V2ChatStreamRequestToolChoice {
	return &v
}

// StreamedChatResponse is returned in streaming mode (specified with `stream=True` in the request).
type V2ChatStreamResponse struct {
	Type          string
	MessageStart  *ChatMessageStartEvent
	ContentStart  *ChatContentStartEvent
	ContentDelta  *ChatContentDeltaEvent
	ContentEnd    *ChatContentEndEvent
	ToolPlanDelta *ChatToolPlanDeltaEvent
	ToolCallStart *ChatToolCallStartEvent
	ToolCallDelta *ChatToolCallDeltaEvent
	ToolCallEnd   *ChatToolCallEndEvent
	CitationStart *CitationStartEvent
	CitationEnd   *CitationEndEvent
	MessageEnd    *ChatMessageEndEvent
	Debug         *ChatDebugEvent
}

func (v *V2ChatStreamResponse) GetType() string {
	if v == nil {
		return ""
	}
	return v.Type
}

func (v *V2ChatStreamResponse) GetMessageStart() *ChatMessageStartEvent {
	if v == nil {
		return nil
	}
	return v.MessageStart
}

func (v *V2ChatStreamResponse) GetContentStart() *ChatContentStartEvent {
	if v == nil {
		return nil
	}
	return v.ContentStart
}

func (v *V2ChatStreamResponse) GetContentDelta() *ChatContentDeltaEvent {
	if v == nil {
		return nil
	}
	return v.ContentDelta
}

func (v *V2ChatStreamResponse) GetContentEnd() *ChatContentEndEvent {
	if v == nil {
		return nil
	}
	return v.ContentEnd
}

func (v *V2ChatStreamResponse) GetToolPlanDelta() *ChatToolPlanDeltaEvent {
	if v == nil {
		return nil
	}
	return v.ToolPlanDelta
}

func (v *V2ChatStreamResponse) GetToolCallStart() *ChatToolCallStartEvent {
	if v == nil {
		return nil
	}
	return v.ToolCallStart
}

func (v *V2ChatStreamResponse) GetToolCallDelta() *ChatToolCallDeltaEvent {
	if v == nil {
		return nil
	}
	return v.ToolCallDelta
}

func (v *V2ChatStreamResponse) GetToolCallEnd() *ChatToolCallEndEvent {
	if v == nil {
		return nil
	}
	return v.ToolCallEnd
}

func (v *V2ChatStreamResponse) GetCitationStart() *CitationStartEvent {
	if v == nil {
		return nil
	}
	return v.CitationStart
}

func (v *V2ChatStreamResponse) GetCitationEnd() *CitationEndEvent {
	if v == nil {
		return nil
	}
	return v.CitationEnd
}

func (v *V2ChatStreamResponse) GetMessageEnd() *ChatMessageEndEvent {
	if v == nil {
		return nil
	}
	return v.MessageEnd
}

func (v *V2ChatStreamResponse) GetDebug() *ChatDebugEvent {
	if v == nil {
		return nil
	}
	return v.Debug
}

func (v *V2ChatStreamResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	v.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", v)
	}
	switch unmarshaler.Type {
	case "message-start":
		value := new(ChatMessageStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.MessageStart = value
	case "content-start":
		value := new(ChatContentStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ContentStart = value
	case "content-delta":
		value := new(ChatContentDeltaEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ContentDelta = value
	case "content-end":
		value := new(ChatContentEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ContentEnd = value
	case "tool-plan-delta":
		value := new(ChatToolPlanDeltaEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ToolPlanDelta = value
	case "tool-call-start":
		value := new(ChatToolCallStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ToolCallStart = value
	case "tool-call-delta":
		value := new(ChatToolCallDeltaEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ToolCallDelta = value
	case "tool-call-end":
		value := new(ChatToolCallEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ToolCallEnd = value
	case "citation-start":
		value := new(CitationStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.CitationStart = value
	case "citation-end":
		value := new(CitationEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.CitationEnd = value
	case "message-end":
		value := new(ChatMessageEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.MessageEnd = value
	case "debug":
		value := new(ChatDebugEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Debug = value
	}
	return nil
}

func (v V2ChatStreamResponse) MarshalJSON() ([]byte, error) {
	if err := v.validate(); err != nil {
		return nil, err
	}
	if v.MessageStart != nil {
		return internal.MarshalJSONWithExtraProperty(v.MessageStart, "type", "message-start")
	}
	if v.ContentStart != nil {
		return internal.MarshalJSONWithExtraProperty(v.ContentStart, "type", "content-start")
	}
	if v.ContentDelta != nil {
		return internal.MarshalJSONWithExtraProperty(v.ContentDelta, "type", "content-delta")
	}
	if v.ContentEnd != nil {
		return internal.MarshalJSONWithExtraProperty(v.ContentEnd, "type", "content-end")
	}
	if v.ToolPlanDelta != nil {
		return internal.MarshalJSONWithExtraProperty(v.ToolPlanDelta, "type", "tool-plan-delta")
	}
	if v.ToolCallStart != nil {
		return internal.MarshalJSONWithExtraProperty(v.ToolCallStart, "type", "tool-call-start")
	}
	if v.ToolCallDelta != nil {
		return internal.MarshalJSONWithExtraProperty(v.ToolCallDelta, "type", "tool-call-delta")
	}
	if v.ToolCallEnd != nil {
		return internal.MarshalJSONWithExtraProperty(v.ToolCallEnd, "type", "tool-call-end")
	}
	if v.CitationStart != nil {
		return internal.MarshalJSONWithExtraProperty(v.CitationStart, "type", "citation-start")
	}
	if v.CitationEnd != nil {
		return internal.MarshalJSONWithExtraProperty(v.CitationEnd, "type", "citation-end")
	}
	if v.MessageEnd != nil {
		return internal.MarshalJSONWithExtraProperty(v.MessageEnd, "type", "message-end")
	}
	if v.Debug != nil {
		return internal.MarshalJSONWithExtraProperty(v.Debug, "type", "debug")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", v)
}

type V2ChatStreamResponseVisitor interface {
	VisitMessageStart(*ChatMessageStartEvent) error
	VisitContentStart(*ChatContentStartEvent) error
	VisitContentDelta(*ChatContentDeltaEvent) error
	VisitContentEnd(*ChatContentEndEvent) error
	VisitToolPlanDelta(*ChatToolPlanDeltaEvent) error
	VisitToolCallStart(*ChatToolCallStartEvent) error
	VisitToolCallDelta(*ChatToolCallDeltaEvent) error
	VisitToolCallEnd(*ChatToolCallEndEvent) error
	VisitCitationStart(*CitationStartEvent) error
	VisitCitationEnd(*CitationEndEvent) error
	VisitMessageEnd(*ChatMessageEndEvent) error
	VisitDebug(*ChatDebugEvent) error
}

func (v *V2ChatStreamResponse) Accept(visitor V2ChatStreamResponseVisitor) error {
	if v.MessageStart != nil {
		return visitor.VisitMessageStart(v.MessageStart)
	}
	if v.ContentStart != nil {
		return visitor.VisitContentStart(v.ContentStart)
	}
	if v.ContentDelta != nil {
		return visitor.VisitContentDelta(v.ContentDelta)
	}
	if v.ContentEnd != nil {
		return visitor.VisitContentEnd(v.ContentEnd)
	}
	if v.ToolPlanDelta != nil {
		return visitor.VisitToolPlanDelta(v.ToolPlanDelta)
	}
	if v.ToolCallStart != nil {
		return visitor.VisitToolCallStart(v.ToolCallStart)
	}
	if v.ToolCallDelta != nil {
		return visitor.VisitToolCallDelta(v.ToolCallDelta)
	}
	if v.ToolCallEnd != nil {
		return visitor.VisitToolCallEnd(v.ToolCallEnd)
	}
	if v.CitationStart != nil {
		return visitor.VisitCitationStart(v.CitationStart)
	}
	if v.CitationEnd != nil {
		return visitor.VisitCitationEnd(v.CitationEnd)
	}
	if v.MessageEnd != nil {
		return visitor.VisitMessageEnd(v.MessageEnd)
	}
	if v.Debug != nil {
		return visitor.VisitDebug(v.Debug)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", v)
}

func (v *V2ChatStreamResponse) validate() error {
	if v == nil {
		return fmt.Errorf("type %T is nil", v)
	}
	var fields []string
	if v.MessageStart != nil {
		fields = append(fields, "message-start")
	}
	if v.ContentStart != nil {
		fields = append(fields, "content-start")
	}
	if v.ContentDelta != nil {
		fields = append(fields, "content-delta")
	}
	if v.ContentEnd != nil {
		fields = append(fields, "content-end")
	}
	if v.ToolPlanDelta != nil {
		fields = append(fields, "tool-plan-delta")
	}
	if v.ToolCallStart != nil {
		fields = append(fields, "tool-call-start")
	}
	if v.ToolCallDelta != nil {
		fields = append(fields, "tool-call-delta")
	}
	if v.ToolCallEnd != nil {
		fields = append(fields, "tool-call-end")
	}
	if v.CitationStart != nil {
		fields = append(fields, "citation-start")
	}
	if v.CitationEnd != nil {
		fields = append(fields, "citation-end")
	}
	if v.MessageEnd != nil {
		fields = append(fields, "message-end")
	}
	if v.Debug != nil {
		fields = append(fields, "debug")
	}
	if len(fields) == 0 {
		if v.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", v, v.Type)
		}
		return fmt.Errorf("type %T is empty", v)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", v, fields)
	}
	if v.Type != "" {
		field := fields[0]
		if v.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				v,
				v.Type,
				v,
			)
		}
	}
	return nil
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type V2EmbedRequestTruncate string

const (
	V2EmbedRequestTruncateNone  V2EmbedRequestTruncate = "NONE"
	V2EmbedRequestTruncateStart V2EmbedRequestTruncate = "START"
	V2EmbedRequestTruncateEnd   V2EmbedRequestTruncate = "END"
)

func NewV2EmbedRequestTruncateFromString(s string) (V2EmbedRequestTruncate, error) {
	switch s {
	case "NONE":
		return V2EmbedRequestTruncateNone, nil
	case "START":
		return V2EmbedRequestTruncateStart, nil
	case "END":
		return V2EmbedRequestTruncateEnd, nil
	}
	var t V2EmbedRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2EmbedRequestTruncate) Ptr() *V2EmbedRequestTruncate {
	return &v
}

type V2RerankResponse struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An ordered list of ranked documents
	Results []*V2RerankResponseResultsItem `json:"results" url:"results"`
	Meta    *ApiMeta                       `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V2RerankResponse) GetId() *string {
	if v == nil {
		return nil
	}
	return v.Id
}

func (v *V2RerankResponse) GetResults() []*V2RerankResponseResultsItem {
	if v == nil {
		return nil
	}
	return v.Results
}

func (v *V2RerankResponse) GetMeta() *ApiMeta {
	if v == nil {
		return nil
	}
	return v.Meta
}

func (v *V2RerankResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V2RerankResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V2RerankResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V2RerankResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V2RerankResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V2RerankResponseResultsItem struct {
	// Corresponds to the index in the original list of documents to which the ranked document belongs. (i.e. if the first value in the `results` object has an `index` value of 3, it means in the list of documents passed in, the document at `index=3` had the highest relevance)
	Index int `json:"index" url:"index"`
	// Relevance scores are normalized to be in the range `[0, 1]`. Scores close to `1` indicate a high relevance to the query, and scores closer to `0` indicate low relevance. It is not accurate to assume a score of 0.9 means the document is 2x more relevant than a document with a score of 0.45
	RelevanceScore float64 `json:"relevance_score" url:"relevance_score"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V2RerankResponseResultsItem) GetIndex() int {
	if v == nil {
		return 0
	}
	return v.Index
}

func (v *V2RerankResponseResultsItem) GetRelevanceScore() float64 {
	if v == nil {
		return 0
	}
	return v.RelevanceScore
}

func (v *V2RerankResponseResultsItem) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V2RerankResponseResultsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler V2RerankResponseResultsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V2RerankResponseResultsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V2RerankResponseResultsItem) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
