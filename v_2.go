// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/cohere-ai/cohere-go/v2/internal"
)

type V2ChatRequest struct {
	// Defaults to `false`.
	//
	// When `true`, the response will be a SSE stream of events.
	//
	// Streaming is beneficial for user interfaces that render the contents of the response piece by piece, as it gets generated.
	// The name of a compatible [Cohere model](https://docs.cohere.com/v2/docs/models) or the ID of a [fine-tuned](https://docs.cohere.com/v2/docs/chat-fine-tuning) model.
	Model    string       `json:"model" url:"-"`
	Messages ChatMessages `json:"messages,omitempty" url:"-"`
	// A list of tools (functions) available to the model. The model response may contain 'tool_calls' to the specified tools.
	//
	// Learn more in the [Tool Use guide](https://docs.cohere.com/docs/tools).
	Tools []*ToolV2 `json:"tools,omitempty" url:"-"`
	// When set to `true`, tool calls in the Assistant message will be forced to follow the tool definition strictly. Learn more in the [Structured Outputs (Tools) guide](https://docs.cohere.com/docs/structured-outputs-json#structured-outputs-tools).
	//
	// **Note**: The first few requests with a new set of tools will take longer to process.
	StrictTools *bool `json:"strict_tools,omitempty" url:"-"`
	// A list of relevant documents that the model can cite to generate a more accurate reply. Each document is either a string or document object with content and metadata.
	Documents       []*V2ChatRequestDocumentsItem `json:"documents,omitempty" url:"-"`
	CitationOptions *CitationOptions              `json:"citation_options,omitempty" url:"-"`
	ResponseFormat  *ResponseFormatV2             `json:"response_format,omitempty" url:"-"`
	// Used to select the [safety instruction](https://docs.cohere.com/v2/docs/safety-modes) inserted into the prompt. Defaults to `CONTEXTUAL`.
	// When `OFF` is specified, the safety instruction will be omitted.
	//
	// Safety modes are not yet configurable in combination with `tools` and `documents` parameters.
	//
	// **Note**: This parameter is only compatible newer Cohere models, starting with [Command R 08-2024](https://docs.cohere.com/docs/command-r#august-2024-release) and [Command R+ 08-2024](https://docs.cohere.com/docs/command-r-plus#august-2024-release).
	//
	// **Note**: `command-r7b-12-2024` and newer models only support `"CONTEXTUAL"` and `"STRICT"` modes.
	SafetyMode *V2ChatRequestSafetyMode `json:"safety_mode,omitempty" url:"-"`
	// The maximum number of output tokens the model will generate in the response. If not set, `max_tokens` defaults to the model's maximum output token limit. You can find the maximum output token limits for each model in the [model documentation](https://docs.cohere.com/docs/models).
	//
	// **Note**: Setting a low value may result in incomplete generations. In such cases, the `finish_reason` field in the response will be set to `"MAX_TOKENS"`.
	//
	// **Note**: If `max_tokens` is set higher than the model's maximum output token limit, the generation will be capped at that model-specific maximum limit.
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// A list of up to 5 strings that the model will use to stop generation. If the model generates a string that matches any of the strings in the list, it will stop generating tokens and return the generated text up to that point not including the stop sequence.
	StopSequences []string `json:"stop_sequences,omitempty" url:"-"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	Temperature *float64 `json:"temperature,omitempty" url:"-"`
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	Seed *int `json:"seed,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	// Used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"-"`
	// Ensures that only the top `k` most likely tokens are considered for generation at each step. When `k` is set to `0`, k-sampling is disabled.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"-"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"-"`
	// Defaults to `false`. When set to `true`, the log probabilities of the generated tokens will be included in the response.
	Logprobs *bool `json:"logprobs,omitempty" url:"-"`
	// Used to control whether or not the model will be forced to use a tool when answering. When `REQUIRED` is specified, the model will be forced to use at least one of the user-defined tools, and the `tools` parameter must be passed in the request.
	// When `NONE` is specified, the model will be forced **not** to use one of the specified tools, and give a direct response.
	// If tool_choice isn't specified, then the model is free to choose whether to use the specified tools or not.
	//
	// **Note**: This parameter is only compatible with models [Command-r7b](https://docs.cohere.com/v2/docs/command-r7b) and newer.
	//
	// **Note**: The same functionality can be achieved in `/v1/chat` using the `force_single_step` parameter. If `force_single_step=true`, this is equivalent to specifying `REQUIRED`. While if `force_single_step=true` and `tool_results` are passed, this is equivalent to specifying `NONE`.
	ToolChoice *V2ChatRequestToolChoice `json:"tool_choice,omitempty" url:"-"`
	Thinking   *Thinking                `json:"thinking,omitempty" url:"-"`
	// When enabled, the user's prompt will be sent to the model without
	// any pre-processing.
	//
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker/Bedrock, Private Deployments
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"-"`
	stream       bool
}

func (v *V2ChatRequest) Stream() bool {
	return v.stream
}

func (v *V2ChatRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V2ChatRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*v = V2ChatRequest(body)
	v.stream = false
	return nil
}

func (v *V2ChatRequest) MarshalJSON() ([]byte, error) {
	type embed V2ChatRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*v),
		Stream: false,
	}
	return json.Marshal(marshaler)
}

type V2ChatStreamRequest struct {
	// Defaults to `false`.
	//
	// When `true`, the response will be a SSE stream of events.
	//
	// Streaming is beneficial for user interfaces that render the contents of the response piece by piece, as it gets generated.
	// The name of a compatible [Cohere model](https://docs.cohere.com/v2/docs/models) or the ID of a [fine-tuned](https://docs.cohere.com/v2/docs/chat-fine-tuning) model.
	Model    string       `json:"model" url:"-"`
	Messages ChatMessages `json:"messages,omitempty" url:"-"`
	// A list of tools (functions) available to the model. The model response may contain 'tool_calls' to the specified tools.
	//
	// Learn more in the [Tool Use guide](https://docs.cohere.com/docs/tools).
	Tools []*ToolV2 `json:"tools,omitempty" url:"-"`
	// When set to `true`, tool calls in the Assistant message will be forced to follow the tool definition strictly. Learn more in the [Structured Outputs (Tools) guide](https://docs.cohere.com/docs/structured-outputs-json#structured-outputs-tools).
	//
	// **Note**: The first few requests with a new set of tools will take longer to process.
	StrictTools *bool `json:"strict_tools,omitempty" url:"-"`
	// A list of relevant documents that the model can cite to generate a more accurate reply. Each document is either a string or document object with content and metadata.
	Documents       []*V2ChatStreamRequestDocumentsItem `json:"documents,omitempty" url:"-"`
	CitationOptions *CitationOptions                    `json:"citation_options,omitempty" url:"-"`
	ResponseFormat  *ResponseFormatV2                   `json:"response_format,omitempty" url:"-"`
	// Used to select the [safety instruction](https://docs.cohere.com/v2/docs/safety-modes) inserted into the prompt. Defaults to `CONTEXTUAL`.
	// When `OFF` is specified, the safety instruction will be omitted.
	//
	// Safety modes are not yet configurable in combination with `tools` and `documents` parameters.
	//
	// **Note**: This parameter is only compatible newer Cohere models, starting with [Command R 08-2024](https://docs.cohere.com/docs/command-r#august-2024-release) and [Command R+ 08-2024](https://docs.cohere.com/docs/command-r-plus#august-2024-release).
	//
	// **Note**: `command-r7b-12-2024` and newer models only support `"CONTEXTUAL"` and `"STRICT"` modes.
	SafetyMode *V2ChatStreamRequestSafetyMode `json:"safety_mode,omitempty" url:"-"`
	// The maximum number of output tokens the model will generate in the response. If not set, `max_tokens` defaults to the model's maximum output token limit. You can find the maximum output token limits for each model in the [model documentation](https://docs.cohere.com/docs/models).
	//
	// **Note**: Setting a low value may result in incomplete generations. In such cases, the `finish_reason` field in the response will be set to `"MAX_TOKENS"`.
	//
	// **Note**: If `max_tokens` is set higher than the model's maximum output token limit, the generation will be capped at that model-specific maximum limit.
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// A list of up to 5 strings that the model will use to stop generation. If the model generates a string that matches any of the strings in the list, it will stop generating tokens and return the generated text up to that point not including the stop sequence.
	StopSequences []string `json:"stop_sequences,omitempty" url:"-"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	Temperature *float64 `json:"temperature,omitempty" url:"-"`
	// If specified, the backend will make a best effort to sample tokens
	// deterministically, such that repeated requests with the same
	// seed and parameters should return the same result. However,
	// determinism cannot be totally guaranteed.
	Seed *int `json:"seed,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"-"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	// Used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"-"`
	// Ensures that only the top `k` most likely tokens are considered for generation at each step. When `k` is set to `0`, k-sampling is disabled.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"-"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"-"`
	// Defaults to `false`. When set to `true`, the log probabilities of the generated tokens will be included in the response.
	Logprobs *bool `json:"logprobs,omitempty" url:"-"`
	// Used to control whether or not the model will be forced to use a tool when answering. When `REQUIRED` is specified, the model will be forced to use at least one of the user-defined tools, and the `tools` parameter must be passed in the request.
	// When `NONE` is specified, the model will be forced **not** to use one of the specified tools, and give a direct response.
	// If tool_choice isn't specified, then the model is free to choose whether to use the specified tools or not.
	//
	// **Note**: This parameter is only compatible with models [Command-r7b](https://docs.cohere.com/v2/docs/command-r7b) and newer.
	//
	// **Note**: The same functionality can be achieved in `/v1/chat` using the `force_single_step` parameter. If `force_single_step=true`, this is equivalent to specifying `REQUIRED`. While if `force_single_step=true` and `tool_results` are passed, this is equivalent to specifying `NONE`.
	ToolChoice *V2ChatStreamRequestToolChoice `json:"tool_choice,omitempty" url:"-"`
	Thinking   *Thinking                      `json:"thinking,omitempty" url:"-"`
	// When enabled, the user's prompt will be sent to the model without
	// any pre-processing.
	//
	// Compatible Deployments: Cohere Platform, Azure, AWS Sagemaker/Bedrock, Private Deployments
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"-"`
	stream       bool
}

func (v *V2ChatStreamRequest) Stream() bool {
	return v.stream
}

func (v *V2ChatStreamRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V2ChatStreamRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*v = V2ChatStreamRequest(body)
	v.stream = true
	return nil
}

func (v *V2ChatStreamRequest) MarshalJSON() ([]byte, error) {
	type embed V2ChatStreamRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*v),
		Stream: true,
	}
	return json.Marshal(marshaler)
}

type V2EmbedRequest struct {
	// An array of strings for the model to embed. Maximum number of texts per call is `96`.
	Texts []string `json:"texts,omitempty" url:"-"`
	// An array of image data URIs for the model to embed. Maximum number of images per call is `1`.
	//
	// The image must be a valid [data URI](https://developer.mozilla.org/en-US/docs/Web/URI/Schemes/data). The image must be in either `image/jpeg` or `image/png` format and has a maximum size of 5MB.
	//
	// Image embeddings are supported with Embed v3.0 and newer models.
	Images []string `json:"images,omitempty" url:"-"`
	// ID of one of the available [Embedding models](https://docs.cohere.com/docs/cohere-embed).
	Model     string         `json:"model" url:"-"`
	InputType EmbedInputType `json:"input_type" url:"-"`
	// An array of inputs for the model to embed. Maximum number of inputs per call is `96`. An input can contain a mix of text and image components.
	Inputs []*EmbedInput `json:"inputs,omitempty" url:"-"`
	// The maximum number of tokens to embed per input. If the input text is longer than this, it will be truncated according to the `truncate` parameter.
	MaxTokens *int `json:"max_tokens,omitempty" url:"-"`
	// The number of dimensions of the output embedding. This is only available for `embed-v4` and newer models.
	// Possible values are `256`, `512`, `1024`, and `1536`. The default is `1536`.
	OutputDimension *int `json:"output_dimension,omitempty" url:"-"`
	// Specifies the types of embeddings you want to get back. Can be one or more of the following types.
	//
	// * `"float"`: Use this when you want to get back the default float embeddings. Supported with all Embed models.
	// * `"int8"`: Use this when you want to get back signed int8 embeddings. Supported with Embed v3.0 and newer Embed models.
	// * `"uint8"`: Use this when you want to get back unsigned int8 embeddings. Supported with Embed v3.0 and newer Embed models.
	// * `"binary"`: Use this when you want to get back signed binary embeddings. Supported with Embed v3.0 and newer Embed models.
	// * `"ubinary"`: Use this when you want to get back unsigned binary embeddings. Supported with Embed v3.0 and newer Embed models.
	EmbeddingTypes []EmbeddingType `json:"embedding_types,omitempty" url:"-"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *V2EmbedRequestTruncate `json:"truncate,omitempty" url:"-"`
}

type V2RerankRequest struct {
	// The identifier of the model to use, eg `rerank-v3.5`.
	Model string `json:"model" url:"-"`
	// The search query
	Query string `json:"query" url:"-"`
	// A list of texts that will be compared to the `query`.
	// For optimal performance we recommend against sending more than 1,000 documents in a single request.
	//
	// **Note**: long documents will automatically be truncated to the value of `max_tokens_per_doc`.
	//
	// **Note**: structured data should be formatted as YAML strings for best performance.
	Documents []string `json:"documents,omitempty" url:"-"`
	// Limits the number of returned rerank results to the specified value. If not passed, all the rerank results will be returned.
	TopN *int `json:"top_n,omitempty" url:"-"`
	// Defaults to `4096`. Long documents will be automatically truncated to the specified number of tokens.
	MaxTokensPerDoc *int `json:"max_tokens_per_doc,omitempty" url:"-"`
}

// A message from the assistant role can contain text and tool call information.
type AssistantMessage struct {
	ToolCalls []*ToolCallV2 `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`
	// A chain-of-thought style reflection and plan that the model generates when working with Tools.
	ToolPlan  *string                    `json:"tool_plan,omitempty" url:"tool_plan,omitempty"`
	Content   *AssistantMessageV2Content `json:"content,omitempty" url:"content,omitempty"`
	Citations []*Citation                `json:"citations,omitempty" url:"citations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessage) GetToolCalls() []*ToolCallV2 {
	if a == nil {
		return nil
	}
	return a.ToolCalls
}

func (a *AssistantMessage) GetToolPlan() *string {
	if a == nil {
		return nil
	}
	return a.ToolPlan
}

func (a *AssistantMessage) GetContent() *AssistantMessageV2Content {
	if a == nil {
		return nil
	}
	return a.Content
}

func (a *AssistantMessage) GetCitations() []*Citation {
	if a == nil {
		return nil
	}
	return a.Citations
}

func (a *AssistantMessage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler AssistantMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssistantMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessage) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A message from the assistant role can contain text and tool call information.
type AssistantMessageResponse struct {
	ToolCalls []*ToolCallV2 `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`
	// A chain-of-thought style reflection and plan that the model generates when working with Tools.
	ToolPlan  *string                                `json:"tool_plan,omitempty" url:"tool_plan,omitempty"`
	Content   []*AssistantMessageResponseContentItem `json:"content,omitempty" url:"content,omitempty"`
	Citations []*Citation                            `json:"citations,omitempty" url:"citations,omitempty"`
	role      string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssistantMessageResponse) GetToolCalls() []*ToolCallV2 {
	if a == nil {
		return nil
	}
	return a.ToolCalls
}

func (a *AssistantMessageResponse) GetToolPlan() *string {
	if a == nil {
		return nil
	}
	return a.ToolPlan
}

func (a *AssistantMessageResponse) GetContent() []*AssistantMessageResponseContentItem {
	if a == nil {
		return nil
	}
	return a.Content
}

func (a *AssistantMessageResponse) GetCitations() []*Citation {
	if a == nil {
		return nil
	}
	return a.Citations
}

func (a *AssistantMessageResponse) Role() string {
	return a.role
}

func (a *AssistantMessageResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssistantMessageResponse) UnmarshalJSON(data []byte) error {
	type embed AssistantMessageResponse
	var unmarshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AssistantMessageResponse(unmarshaler.embed)
	if unmarshaler.Role != "assistant" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "assistant", unmarshaler.Role)
	}
	a.role = unmarshaler.Role
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "role")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssistantMessageResponse) MarshalJSON() ([]byte, error) {
	type embed AssistantMessageResponse
	var marshaler = struct {
		embed
		Role string `json:"role"`
	}{
		embed: embed(*a),
		Role:  "assistant",
	}
	return json.Marshal(marshaler)
}

func (a *AssistantMessageResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AssistantMessageResponseContentItem struct {
	Type     string
	Text     *ChatTextContent
	Thinking interface{}
}

func (a *AssistantMessageResponseContentItem) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AssistantMessageResponseContentItem) GetText() *ChatTextContent {
	if a == nil {
		return nil
	}
	return a.Text
}

func (a *AssistantMessageResponseContentItem) GetThinking() interface{} {
	if a == nil {
		return nil
	}
	return a.Thinking
}

func (a *AssistantMessageResponseContentItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Text = value
	case "thinking":
		var valueUnmarshaler struct {
			Thinking interface{} `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.Thinking = valueUnmarshaler.Thinking
	}
	return nil
}

func (a AssistantMessageResponseContentItem) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Text != nil {
		return internal.MarshalJSONWithExtraProperty(a.Text, "type", "text")
	}
	if a.Thinking != nil {
		var marshaler = struct {
			Type     string      `json:"type"`
			Thinking interface{} `json:"value"`
		}{
			Type:     "thinking",
			Thinking: a.Thinking,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AssistantMessageResponseContentItemVisitor interface {
	VisitText(*ChatTextContent) error
	VisitThinking(interface{}) error
}

func (a *AssistantMessageResponseContentItem) Accept(visitor AssistantMessageResponseContentItemVisitor) error {
	if a.Text != nil {
		return visitor.VisitText(a.Text)
	}
	if a.Thinking != nil {
		return visitor.VisitThinking(a.Thinking)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *AssistantMessageResponseContentItem) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Text != nil {
		fields = append(fields, "text")
	}
	if a.Thinking != nil {
		fields = append(fields, "thinking")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

type AssistantMessageV2Content struct {
	String                            string
	AssistantMessageV2ContentItemList []*AssistantMessageV2ContentItem

	typ string
}

func (a *AssistantMessageV2Content) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *AssistantMessageV2Content) GetAssistantMessageV2ContentItemList() []*AssistantMessageV2ContentItem {
	if a == nil {
		return nil
	}
	return a.AssistantMessageV2ContentItemList
}

func (a *AssistantMessageV2Content) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	var valueAssistantMessageV2ContentItemList []*AssistantMessageV2ContentItem
	if err := json.Unmarshal(data, &valueAssistantMessageV2ContentItemList); err == nil {
		a.typ = "AssistantMessageV2ContentItemList"
		a.AssistantMessageV2ContentItemList = valueAssistantMessageV2ContentItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AssistantMessageV2Content) MarshalJSON() ([]byte, error) {
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	if a.typ == "AssistantMessageV2ContentItemList" || a.AssistantMessageV2ContentItemList != nil {
		return json.Marshal(a.AssistantMessageV2ContentItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantMessageV2ContentVisitor interface {
	VisitString(string) error
	VisitAssistantMessageV2ContentItemList([]*AssistantMessageV2ContentItem) error
}

func (a *AssistantMessageV2Content) Accept(visitor AssistantMessageV2ContentVisitor) error {
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	if a.typ == "AssistantMessageV2ContentItemList" || a.AssistantMessageV2ContentItemList != nil {
		return visitor.VisitAssistantMessageV2ContentItemList(a.AssistantMessageV2ContentItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AssistantMessageV2ContentItem struct {
	Type string
	Text *ChatTextContent
}

func (a *AssistantMessageV2ContentItem) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AssistantMessageV2ContentItem) GetText() *ChatTextContent {
	if a == nil {
		return nil
	}
	return a.Text
}

func (a *AssistantMessageV2ContentItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Text = value
	}
	return nil
}

func (a AssistantMessageV2ContentItem) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Text != nil {
		return internal.MarshalJSONWithExtraProperty(a.Text, "type", "text")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AssistantMessageV2ContentItemVisitor interface {
	VisitText(*ChatTextContent) error
}

func (a *AssistantMessageV2ContentItem) Accept(visitor AssistantMessageV2ContentItemVisitor) error {
	if a.Text != nil {
		return visitor.VisitText(a.Text)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *AssistantMessageV2ContentItem) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Text != nil {
		fields = append(fields, "text")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

// A streamed delta event which contains a delta of chat text content.
type ChatContentDeltaEvent struct {
	Index    *int                        `json:"index,omitempty" url:"index,omitempty"`
	Delta    *ChatContentDeltaEventDelta `json:"delta,omitempty" url:"delta,omitempty"`
	Logprobs *LogprobItem                `json:"logprobs,omitempty" url:"logprobs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentDeltaEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatContentDeltaEvent) GetDelta() *ChatContentDeltaEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatContentDeltaEvent) GetLogprobs() *LogprobItem {
	if c == nil {
		return nil
	}
	return c.Logprobs
}

func (c *ChatContentDeltaEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentDeltaEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentDeltaEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentDeltaEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentDeltaEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentDeltaEventDelta struct {
	Message *ChatContentDeltaEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentDeltaEventDelta) GetMessage() *ChatContentDeltaEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatContentDeltaEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentDeltaEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentDeltaEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentDeltaEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentDeltaEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentDeltaEventDeltaMessage struct {
	Content *ChatContentDeltaEventDeltaMessageContent `json:"content,omitempty" url:"content,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentDeltaEventDeltaMessage) GetContent() *ChatContentDeltaEventDeltaMessageContent {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ChatContentDeltaEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentDeltaEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentDeltaEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentDeltaEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentDeltaEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentDeltaEventDeltaMessageContent struct {
	Text *string `json:"text,omitempty" url:"text,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentDeltaEventDeltaMessageContent) GetText() *string {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *ChatContentDeltaEventDeltaMessageContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentDeltaEventDeltaMessageContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentDeltaEventDeltaMessageContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentDeltaEventDeltaMessageContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentDeltaEventDeltaMessageContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed delta event which signifies that the content block has ended.
type ChatContentEndEvent struct {
	Index *int `json:"index,omitempty" url:"index,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentEndEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatContentEndEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentEndEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentEndEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed delta event which signifies that a new content block has started.
type ChatContentStartEvent struct {
	Index *int                        `json:"index,omitempty" url:"index,omitempty"`
	Delta *ChatContentStartEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentStartEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatContentStartEvent) GetDelta() *ChatContentStartEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatContentStartEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentStartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentStartEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentStartEventDelta struct {
	Message *ChatContentStartEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentStartEventDelta) GetMessage() *ChatContentStartEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatContentStartEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentStartEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentStartEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentStartEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentStartEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentStartEventDeltaMessage struct {
	Content *ChatContentStartEventDeltaMessageContent `json:"content,omitempty" url:"content,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentStartEventDeltaMessage) GetContent() *ChatContentStartEventDeltaMessageContent {
	if c == nil {
		return nil
	}
	return c.Content
}

func (c *ChatContentStartEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentStartEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentStartEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentStartEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentStartEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentStartEventDeltaMessageContent struct {
	Text *string                                       `json:"text,omitempty" url:"text,omitempty"`
	Type *ChatContentStartEventDeltaMessageContentType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatContentStartEventDeltaMessageContent) GetText() *string {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *ChatContentStartEventDeltaMessageContent) GetType() *ChatContentStartEventDeltaMessageContentType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ChatContentStartEventDeltaMessageContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatContentStartEventDeltaMessageContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatContentStartEventDeltaMessageContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatContentStartEventDeltaMessageContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatContentStartEventDeltaMessageContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatContentStartEventDeltaMessageContentType string

const (
	ChatContentStartEventDeltaMessageContentTypeText     ChatContentStartEventDeltaMessageContentType = "text"
	ChatContentStartEventDeltaMessageContentTypeThinking ChatContentStartEventDeltaMessageContentType = "thinking"
)

func NewChatContentStartEventDeltaMessageContentTypeFromString(s string) (ChatContentStartEventDeltaMessageContentType, error) {
	switch s {
	case "text":
		return ChatContentStartEventDeltaMessageContentTypeText, nil
	case "thinking":
		return ChatContentStartEventDeltaMessageContentTypeThinking, nil
	}
	var t ChatContentStartEventDeltaMessageContentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatContentStartEventDeltaMessageContentType) Ptr() *ChatContentStartEventDeltaMessageContentType {
	return &c
}

// A document source object containing the unique identifier of the document and the document itself.
type ChatDocumentSource struct {
	// The unique identifier of the document
	Id       *string                `json:"id,omitempty" url:"id,omitempty"`
	Document map[string]interface{} `json:"document,omitempty" url:"document,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatDocumentSource) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ChatDocumentSource) GetDocument() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Document
}

func (c *ChatDocumentSource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatDocumentSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatDocumentSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatDocumentSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatDocumentSource) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The reason a chat request has finished.
//
// - **complete**: The model finished sending a complete message.
// - **max_tokens**: The number of generated tokens exceeded the model's context length or the value specified via the `max_tokens` parameter.
// - **stop_sequence**: One of the provided `stop_sequence` entries was reached in the model's generation.
// - **tool_call**: The model generated a Tool Call and is expecting a Tool Message in return
// - **error**: The generation failed due to an internal error
type ChatFinishReason string

const (
	ChatFinishReasonComplete     ChatFinishReason = "COMPLETE"
	ChatFinishReasonStopSequence ChatFinishReason = "STOP_SEQUENCE"
	ChatFinishReasonMaxTokens    ChatFinishReason = "MAX_TOKENS"
	ChatFinishReasonToolCall     ChatFinishReason = "TOOL_CALL"
	ChatFinishReasonError        ChatFinishReason = "ERROR"
)

func NewChatFinishReasonFromString(s string) (ChatFinishReason, error) {
	switch s {
	case "COMPLETE":
		return ChatFinishReasonComplete, nil
	case "STOP_SEQUENCE":
		return ChatFinishReasonStopSequence, nil
	case "MAX_TOKENS":
		return ChatFinishReasonMaxTokens, nil
	case "TOOL_CALL":
		return ChatFinishReasonToolCall, nil
	case "ERROR":
		return ChatFinishReasonError, nil
	}
	var t ChatFinishReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatFinishReason) Ptr() *ChatFinishReason {
	return &c
}

// A streamed event which signifies that the chat message has ended.
type ChatMessageEndEvent struct {
	Id    *string                   `json:"id,omitempty" url:"id,omitempty"`
	Delta *ChatMessageEndEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageEndEvent) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ChatMessageEndEvent) GetDelta() *ChatMessageEndEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatMessageEndEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageEndEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageEndEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatMessageEndEventDelta struct {
	// An error message if an error occurred during the generation.
	Error        *string           `json:"error,omitempty" url:"error,omitempty"`
	FinishReason *ChatFinishReason `json:"finish_reason,omitempty" url:"finish_reason,omitempty"`
	Usage        *Usage            `json:"usage,omitempty" url:"usage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageEndEventDelta) GetError() *string {
	if c == nil {
		return nil
	}
	return c.Error
}

func (c *ChatMessageEndEventDelta) GetFinishReason() *ChatFinishReason {
	if c == nil {
		return nil
	}
	return c.FinishReason
}

func (c *ChatMessageEndEventDelta) GetUsage() *Usage {
	if c == nil {
		return nil
	}
	return c.Usage
}

func (c *ChatMessageEndEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageEndEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageEndEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageEndEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageEndEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event which signifies that a stream has started.
type ChatMessageStartEvent struct {
	// Unique identifier for the generated reply.
	Id    *string                     `json:"id,omitempty" url:"id,omitempty"`
	Delta *ChatMessageStartEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageStartEvent) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ChatMessageStartEvent) GetDelta() *ChatMessageStartEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatMessageStartEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageStartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageStartEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatMessageStartEventDelta struct {
	Message *ChatMessageStartEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageStartEventDelta) GetMessage() *ChatMessageStartEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatMessageStartEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageStartEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageStartEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageStartEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageStartEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatMessageStartEventDeltaMessage struct {
	// The role of the message.
	Role *string `json:"role,omitempty" url:"role,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatMessageStartEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatMessageStartEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessageStartEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessageStartEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessageStartEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a single message in the chat history from a given role.
type ChatMessageV2 struct {
	Role      string
	User      *UserMessageV2
	Assistant *AssistantMessage
	System    *SystemMessageV2
	Tool      *ToolMessageV2
}

func (c *ChatMessageV2) GetRole() string {
	if c == nil {
		return ""
	}
	return c.Role
}

func (c *ChatMessageV2) GetUser() *UserMessageV2 {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *ChatMessageV2) GetAssistant() *AssistantMessage {
	if c == nil {
		return nil
	}
	return c.Assistant
}

func (c *ChatMessageV2) GetSystem() *SystemMessageV2 {
	if c == nil {
		return nil
	}
	return c.System
}

func (c *ChatMessageV2) GetTool() *ToolMessageV2 {
	if c == nil {
		return nil
	}
	return c.Tool
}

func (c *ChatMessageV2) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Role string `json:"role"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Role = unmarshaler.Role
	if unmarshaler.Role == "" {
		return fmt.Errorf("%T did not include discriminant role", c)
	}
	switch unmarshaler.Role {
	case "user":
		value := new(UserMessageV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.User = value
	case "assistant":
		value := new(AssistantMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Assistant = value
	case "system":
		value := new(SystemMessageV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.System = value
	case "tool":
		value := new(ToolMessageV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Tool = value
	}
	return nil
}

func (c ChatMessageV2) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.User != nil {
		return internal.MarshalJSONWithExtraProperty(c.User, "role", "user")
	}
	if c.Assistant != nil {
		return internal.MarshalJSONWithExtraProperty(c.Assistant, "role", "assistant")
	}
	if c.System != nil {
		return internal.MarshalJSONWithExtraProperty(c.System, "role", "system")
	}
	if c.Tool != nil {
		return internal.MarshalJSONWithExtraProperty(c.Tool, "role", "tool")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ChatMessageV2Visitor interface {
	VisitUser(*UserMessageV2) error
	VisitAssistant(*AssistantMessage) error
	VisitSystem(*SystemMessageV2) error
	VisitTool(*ToolMessageV2) error
}

func (c *ChatMessageV2) Accept(visitor ChatMessageV2Visitor) error {
	if c.User != nil {
		return visitor.VisitUser(c.User)
	}
	if c.Assistant != nil {
		return visitor.VisitAssistant(c.Assistant)
	}
	if c.System != nil {
		return visitor.VisitSystem(c.System)
	}
	if c.Tool != nil {
		return visitor.VisitTool(c.Tool)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ChatMessageV2) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.User != nil {
		fields = append(fields, "user")
	}
	if c.Assistant != nil {
		fields = append(fields, "assistant")
	}
	if c.System != nil {
		fields = append(fields, "system")
	}
	if c.Tool != nil {
		fields = append(fields, "tool")
	}
	if len(fields) == 0 {
		if c.Role != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Role)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Role != "" {
		field := fields[0]
		if c.Role != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Role,
				c,
			)
		}
	}
	return nil
}

// A list of chat messages in chronological order, representing a conversation between the user and the model.
//
// Messages can be from `User`, `Assistant`, `Tool` and `System` roles. Learn more about messages and roles in [the Chat API guide](https://docs.cohere.com/v2/docs/chat-api).
type ChatMessages = []*ChatMessageV2

// The streamed event types
type ChatStreamEventType struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatStreamEventType) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatStreamEventType) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamEventType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamEventType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamEventType) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Text content of the message.
type ChatTextContent struct {
	Text string `json:"text" url:"text"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatTextContent) GetText() string {
	if c == nil {
		return ""
	}
	return c.Text
}

func (c *ChatTextContent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatTextContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatTextContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatTextContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatTextContent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatTextResponseFormatV2 struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatTextResponseFormatV2) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatTextResponseFormatV2) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatTextResponseFormatV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatTextResponseFormatV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatTextResponseFormatV2) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event delta which signifies a delta in tool call arguments.
type ChatToolCallDeltaEvent struct {
	Index *int                         `json:"index,omitempty" url:"index,omitempty"`
	Delta *ChatToolCallDeltaEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatToolCallDeltaEvent) GetDelta() *ChatToolCallDeltaEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatToolCallDeltaEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallDeltaEventDelta struct {
	Message *ChatToolCallDeltaEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEventDelta) GetMessage() *ChatToolCallDeltaEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatToolCallDeltaEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallDeltaEventDeltaMessage struct {
	ToolCalls *ChatToolCallDeltaEventDeltaMessageToolCalls `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEventDeltaMessage) GetToolCalls() *ChatToolCallDeltaEventDeltaMessageToolCalls {
	if c == nil {
		return nil
	}
	return c.ToolCalls
}

func (c *ChatToolCallDeltaEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallDeltaEventDeltaMessageToolCalls struct {
	Function *ChatToolCallDeltaEventDeltaMessageToolCallsFunction `json:"function,omitempty" url:"function,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCalls) GetFunction() *ChatToolCallDeltaEventDeltaMessageToolCallsFunction {
	if c == nil {
		return nil
	}
	return c.Function
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCalls) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCalls) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEventDeltaMessageToolCalls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEventDeltaMessageToolCalls(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCalls) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallDeltaEventDeltaMessageToolCallsFunction struct {
	Arguments *string `json:"arguments,omitempty" url:"arguments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCallsFunction) GetArguments() *string {
	if c == nil {
		return nil
	}
	return c.Arguments
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCallsFunction) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCallsFunction) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallDeltaEventDeltaMessageToolCallsFunction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallDeltaEventDeltaMessageToolCallsFunction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallDeltaEventDeltaMessageToolCallsFunction) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event delta which signifies a tool call has finished streaming.
type ChatToolCallEndEvent struct {
	Index *int `json:"index,omitempty" url:"index,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallEndEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatToolCallEndEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallEndEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallEndEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event delta which signifies a tool call has started streaming.
type ChatToolCallStartEvent struct {
	Index *int                         `json:"index,omitempty" url:"index,omitempty"`
	Delta *ChatToolCallStartEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallStartEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *ChatToolCallStartEvent) GetDelta() *ChatToolCallStartEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatToolCallStartEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallStartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallStartEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallStartEventDelta struct {
	Message *ChatToolCallStartEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallStartEventDelta) GetMessage() *ChatToolCallStartEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatToolCallStartEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallStartEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallStartEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallStartEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallStartEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallStartEventDeltaMessage struct {
	ToolCalls *ToolCallV2 `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolCallStartEventDeltaMessage) GetToolCalls() *ToolCallV2 {
	if c == nil {
		return nil
	}
	return c.ToolCalls
}

func (c *ChatToolCallStartEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolCallStartEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallStartEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallStartEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallStartEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event which contains a delta of tool plan text.
type ChatToolPlanDeltaEvent struct {
	Delta *ChatToolPlanDeltaEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolPlanDeltaEvent) GetDelta() *ChatToolPlanDeltaEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *ChatToolPlanDeltaEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolPlanDeltaEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolPlanDeltaEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolPlanDeltaEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolPlanDeltaEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolPlanDeltaEventDelta struct {
	Message *ChatToolPlanDeltaEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolPlanDeltaEventDelta) GetMessage() *ChatToolPlanDeltaEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ChatToolPlanDeltaEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolPlanDeltaEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolPlanDeltaEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolPlanDeltaEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolPlanDeltaEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolPlanDeltaEventDeltaMessage struct {
	ToolPlan *string `json:"tool_plan,omitempty" url:"tool_plan,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolPlanDeltaEventDeltaMessage) GetToolPlan() *string {
	if c == nil {
		return nil
	}
	return c.ToolPlan
}

func (c *ChatToolPlanDeltaEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolPlanDeltaEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolPlanDeltaEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolPlanDeltaEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolPlanDeltaEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolSource struct {
	// The unique identifier of the document
	Id         *string                `json:"id,omitempty" url:"id,omitempty"`
	ToolOutput map[string]interface{} `json:"tool_output,omitempty" url:"tool_output,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChatToolSource) GetId() *string {
	if c == nil {
		return nil
	}
	return c.Id
}

func (c *ChatToolSource) GetToolOutput() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.ToolOutput
}

func (c *ChatToolSource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChatToolSource) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolSource) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Citation information containing sources and the text cited.
type Citation struct {
	// Start index of the cited snippet in the original source text.
	Start *int `json:"start,omitempty" url:"start,omitempty"`
	// End index of the cited snippet in the original source text.
	End *int `json:"end,omitempty" url:"end,omitempty"`
	// Text snippet that is being cited.
	Text    *string   `json:"text,omitempty" url:"text,omitempty"`
	Sources []*Source `json:"sources,omitempty" url:"sources,omitempty"`
	// Index of the content block in which this citation appears.
	ContentIndex *int          `json:"content_index,omitempty" url:"content_index,omitempty"`
	Type         *CitationType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Citation) GetStart() *int {
	if c == nil {
		return nil
	}
	return c.Start
}

func (c *Citation) GetEnd() *int {
	if c == nil {
		return nil
	}
	return c.End
}

func (c *Citation) GetText() *string {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *Citation) GetSources() []*Source {
	if c == nil {
		return nil
	}
	return c.Sources
}

func (c *Citation) GetContentIndex() *int {
	if c == nil {
		return nil
	}
	return c.ContentIndex
}

func (c *Citation) GetType() *CitationType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *Citation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Citation) UnmarshalJSON(data []byte) error {
	type unmarshaler Citation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Citation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Citation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A streamed event which signifies a citation has finished streaming.
type CitationEndEvent struct {
	Index *int `json:"index,omitempty" url:"index,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationEndEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *CitationEndEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationEndEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationEndEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Options for controlling citation generation.
type CitationOptions struct {
	// Defaults to `"accurate"`.
	// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results, `"fast"` results or no results.
	//
	// **Note**: `command-r7b-12-2024` and `command-a-03-2025` only support `"fast"` and `"off"` modes. The default is `"fast"`.
	Mode *CitationOptionsMode `json:"mode,omitempty" url:"mode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationOptions) GetMode() *CitationOptionsMode {
	if c == nil {
		return nil
	}
	return c.Mode
}

func (c *CitationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `"accurate"`.
// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results, `"fast"` results or no results.
//
// **Note**: `command-r7b-12-2024` and `command-a-03-2025` only support `"fast"` and `"off"` modes. The default is `"fast"`.
type CitationOptionsMode string

const (
	CitationOptionsModeFast     CitationOptionsMode = "FAST"
	CitationOptionsModeAccurate CitationOptionsMode = "ACCURATE"
	CitationOptionsModeOff      CitationOptionsMode = "OFF"
)

func NewCitationOptionsModeFromString(s string) (CitationOptionsMode, error) {
	switch s {
	case "FAST":
		return CitationOptionsModeFast, nil
	case "ACCURATE":
		return CitationOptionsModeAccurate, nil
	case "OFF":
		return CitationOptionsModeOff, nil
	}
	var t CitationOptionsMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CitationOptionsMode) Ptr() *CitationOptionsMode {
	return &c
}

// A streamed event which signifies a citation has been created.
type CitationStartEvent struct {
	Index *int                     `json:"index,omitempty" url:"index,omitempty"`
	Delta *CitationStartEventDelta `json:"delta,omitempty" url:"delta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationStartEvent) GetIndex() *int {
	if c == nil {
		return nil
	}
	return c.Index
}

func (c *CitationStartEvent) GetDelta() *CitationStartEventDelta {
	if c == nil {
		return nil
	}
	return c.Delta
}

func (c *CitationStartEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationStartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationStartEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CitationStartEventDelta struct {
	Message *CitationStartEventDeltaMessage `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationStartEventDelta) GetMessage() *CitationStartEventDeltaMessage {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *CitationStartEventDelta) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationStartEventDelta) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationStartEventDelta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationStartEventDelta(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationStartEventDelta) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CitationStartEventDeltaMessage struct {
	Citations *Citation `json:"citations,omitempty" url:"citations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CitationStartEventDeltaMessage) GetCitations() *Citation {
	if c == nil {
		return nil
	}
	return c.Citations
}

func (c *CitationStartEventDeltaMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CitationStartEventDeltaMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler CitationStartEventDeltaMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CitationStartEventDeltaMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CitationStartEventDeltaMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of citation which indicates what part of the response the citation is for.
type CitationType string

const (
	CitationTypeTextContent     CitationType = "TEXT_CONTENT"
	CitationTypeThinkingContent CitationType = "THINKING_CONTENT"
	CitationTypePlan            CitationType = "PLAN"
)

func NewCitationTypeFromString(s string) (CitationType, error) {
	switch s {
	case "TEXT_CONTENT":
		return CitationTypeTextContent, nil
	case "THINKING_CONTENT":
		return CitationTypeThinkingContent, nil
	case "PLAN":
		return CitationTypePlan, nil
	}
	var t CitationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CitationType) Ptr() *CitationType {
	return &c
}

// A Content block which contains information about the content type and the content itself.
type Content struct {
	Type     string
	Text     *ChatTextContent
	ImageUrl *ImageContent
}

func (c *Content) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *Content) GetText() *ChatTextContent {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *Content) GetImageUrl() *ImageContent {
	if c == nil {
		return nil
	}
	return c.ImageUrl
}

func (c *Content) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Text = value
	case "image_url":
		value := new(ImageContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ImageUrl = value
	}
	return nil
}

func (c Content) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.Text != nil {
		return internal.MarshalJSONWithExtraProperty(c.Text, "type", "text")
	}
	if c.ImageUrl != nil {
		return internal.MarshalJSONWithExtraProperty(c.ImageUrl, "type", "image_url")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ContentVisitor interface {
	VisitText(*ChatTextContent) error
	VisitImageUrl(*ImageContent) error
}

func (c *Content) Accept(visitor ContentVisitor) error {
	if c.Text != nil {
		return visitor.VisitText(c.Text)
	}
	if c.ImageUrl != nil {
		return visitor.VisitImageUrl(c.ImageUrl)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *Content) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Text != nil {
		fields = append(fields, "text")
	}
	if c.ImageUrl != nil {
		fields = append(fields, "image_url")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

// Relevant information that could be used by the model to generate a more accurate reply.
// The content of each document are generally short (should be under 300 words). Metadata should be used to provide additional information, both the key name and the value will be
// passed to the model.
type Document struct {
	// A relevant document that the model can cite to generate a more accurate reply. Each document is a string-any dictionary.
	Data map[string]interface{} `json:"data" url:"data"`
	// Unique identifier for this document which will be referenced in citations. If not provided an ID will be automatically generated.
	Id *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Document) GetData() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *Document) GetId() *string {
	if d == nil {
		return nil
	}
	return d.Id
}

func (d *Document) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Document) UnmarshalJSON(data []byte) error {
	type unmarshaler Document
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Document(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Document) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Document content.
type DocumentContent struct {
	Document *Document `json:"document" url:"document"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentContent) GetDocument() *Document {
	if d == nil {
		return nil
	}
	return d.Document
}

func (d *DocumentContent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentContent) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentContent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EmbedContent struct {
	Type     string
	ImageUrl *EmbedImage
	Text     *EmbedText
}

func (e *EmbedContent) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EmbedContent) GetImageUrl() *EmbedImage {
	if e == nil {
		return nil
	}
	return e.ImageUrl
}

func (e *EmbedContent) GetText() *EmbedText {
	if e == nil {
		return nil
	}
	return e.Text
}

func (e *EmbedContent) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "image_url":
		value := new(EmbedImage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ImageUrl = value
	case "text":
		value := new(EmbedText)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Text = value
	}
	return nil
}

func (e EmbedContent) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.ImageUrl != nil {
		return internal.MarshalJSONWithExtraProperty(e.ImageUrl, "type", "image_url")
	}
	if e.Text != nil {
		return internal.MarshalJSONWithExtraProperty(e.Text, "type", "text")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EmbedContentVisitor interface {
	VisitImageUrl(*EmbedImage) error
	VisitText(*EmbedText) error
}

func (e *EmbedContent) Accept(visitor EmbedContentVisitor) error {
	if e.ImageUrl != nil {
		return visitor.VisitImageUrl(e.ImageUrl)
	}
	if e.Text != nil {
		return visitor.VisitText(e.Text)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *EmbedContent) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.ImageUrl != nil {
		fields = append(fields, "image_url")
	}
	if e.Text != nil {
		fields = append(fields, "text")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

// Image content of the input. Supported with Embed v3.0 and newer models.
type EmbedImage struct {
	ImageUrl *EmbedImageUrl `json:"image_url,omitempty" url:"image_url,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmbedImage) GetImageUrl() *EmbedImageUrl {
	if e == nil {
		return nil
	}
	return e.ImageUrl
}

func (e *EmbedImage) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedImage) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedImage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedImage) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Base64 url of image.
type EmbedImageUrl struct {
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmbedImageUrl) GetUrl() string {
	if e == nil {
		return ""
	}
	return e.Url
}

func (e *EmbedImageUrl) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedImageUrl) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedImageUrl
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedImageUrl(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedImageUrl) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmbedInput struct {
	// An array of objects containing the input data for the model to embed.
	Content []*EmbedContent `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmbedInput) GetContent() []*EmbedContent {
	if e == nil {
		return nil
	}
	return e.Content
}

func (e *EmbedInput) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedInput) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedInput(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedInput) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Text content of the input.
type EmbedText struct {
	Text *string `json:"text,omitempty" url:"text,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmbedText) GetText() *string {
	if e == nil {
		return nil
	}
	return e.Text
}

func (e *EmbedText) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmbedText) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedText(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedText) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Image content of the message.
type ImageContent struct {
	ImageUrl *ImageUrl `json:"image_url" url:"image_url"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ImageContent) GetImageUrl() *ImageUrl {
	if i == nil {
		return nil
	}
	return i.ImageUrl
}

func (i *ImageContent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ImageContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ImageContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ImageContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImageContent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type ImageUrl struct {
	// URL of an image. Can be either a base64 data URI or a web URL.
	Url string `json:"url" url:"url"`
	// Controls the level of detail in image processing. `"auto"` is the default and lets the system choose, `"low"` is faster but less detailed, and `"high"` preserves maximum detail. You can save tokens and speed up responses by using detail: `"low"`.
	Detail *ImageUrlDetail `json:"detail,omitempty" url:"detail,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ImageUrl) GetUrl() string {
	if i == nil {
		return ""
	}
	return i.Url
}

func (i *ImageUrl) GetDetail() *ImageUrlDetail {
	if i == nil {
		return nil
	}
	return i.Detail
}

func (i *ImageUrl) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ImageUrl) UnmarshalJSON(data []byte) error {
	type unmarshaler ImageUrl
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ImageUrl(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImageUrl) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Controls the level of detail in image processing. `"auto"` is the default and lets the system choose, `"low"` is faster but less detailed, and `"high"` preserves maximum detail. You can save tokens and speed up responses by using detail: `"low"`.
type ImageUrlDetail string

const (
	ImageUrlDetailAuto ImageUrlDetail = "auto"
	ImageUrlDetailLow  ImageUrlDetail = "low"
	ImageUrlDetailHigh ImageUrlDetail = "high"
)

func NewImageUrlDetailFromString(s string) (ImageUrlDetail, error) {
	switch s {
	case "auto":
		return ImageUrlDetailAuto, nil
	case "low":
		return ImageUrlDetailLow, nil
	case "high":
		return ImageUrlDetailHigh, nil
	}
	var t ImageUrlDetail
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i ImageUrlDetail) Ptr() *ImageUrlDetail {
	return &i
}

type JsonResponseFormatV2 struct {
	// A [JSON schema](https://json-schema.org/overview/what-is-jsonschema) object that the output will adhere to. There are some restrictions we have on the schema, refer to [our guide](https://docs.cohere.com/docs/structured-outputs-json#schema-constraints) for more information.
	// Example (required name and age object):
	// ```json
	//
	//	{
	//	  "type": "object",
	//	  "properties": {
	//	    "name": {"type": "string"},
	//	    "age": {"type": "integer"}
	//	  },
	//	  "required": ["name", "age"]
	//	}
	//
	// ```
	//
	// **Note**: This field must not be specified when the `type` is set to `"text"`.
	JsonSchema map[string]interface{} `json:"json_schema,omitempty" url:"json_schema,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JsonResponseFormatV2) GetJsonSchema() map[string]interface{} {
	if j == nil {
		return nil
	}
	return j.JsonSchema
}

func (j *JsonResponseFormatV2) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JsonResponseFormatV2) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonResponseFormatV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonResponseFormatV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonResponseFormatV2) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type LogprobItem struct {
	// The text chunk for which the log probabilities was calculated.
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// The token ids of each token used to construct the text chunk.
	TokenIds []int `json:"token_ids" url:"token_ids"`
	// The log probability of each token used to construct the text chunk.
	Logprobs []float64 `json:"logprobs,omitempty" url:"logprobs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogprobItem) GetText() *string {
	if l == nil {
		return nil
	}
	return l.Text
}

func (l *LogprobItem) GetTokenIds() []int {
	if l == nil {
		return nil
	}
	return l.TokenIds
}

func (l *LogprobItem) GetLogprobs() []float64 {
	if l == nil {
		return nil
	}
	return l.Logprobs
}

func (l *LogprobItem) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogprobItem) UnmarshalJSON(data []byte) error {
	type unmarshaler LogprobItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogprobItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogprobItem) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Configuration for forcing the model output to adhere to the specified format. Supported on [Command R](https://docs.cohere.com/v2/docs/command-r), [Command R+](https://docs.cohere.com/v2/docs/command-r-plus) and newer models.
//
// The model can be forced into outputting JSON objects by setting `{ "type": "json_object" }`.
//
// A [JSON Schema](https://json-schema.org/) can optionally be provided, to ensure a specific structure.
//
// **Note**: When using  `{ "type": "json_object" }` your `message` should always explicitly instruct the model to generate a JSON (eg: _"Generate a JSON ..."_) . Otherwise the model may end up getting stuck generating an infinite stream of characters and eventually run out of context length.
//
// **Note**: When `json_schema` is not specified, the generated object can have up to 5 layers of nesting.
//
// **Limitation**: The parameter is not supported when used in combinations with the `documents` or `tools` parameters.
type ResponseFormatV2 struct {
	Type       string
	Text       *ChatTextResponseFormatV2
	JsonObject *JsonResponseFormatV2
}

func (r *ResponseFormatV2) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *ResponseFormatV2) GetText() *ChatTextResponseFormatV2 {
	if r == nil {
		return nil
	}
	return r.Text
}

func (r *ResponseFormatV2) GetJsonObject() *JsonResponseFormatV2 {
	if r == nil {
		return nil
	}
	return r.JsonObject
}

func (r *ResponseFormatV2) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextResponseFormatV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Text = value
	case "json_object":
		value := new(JsonResponseFormatV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.JsonObject = value
	}
	return nil
}

func (r ResponseFormatV2) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Text != nil {
		return internal.MarshalJSONWithExtraProperty(r.Text, "type", "text")
	}
	if r.JsonObject != nil {
		return internal.MarshalJSONWithExtraProperty(r.JsonObject, "type", "json_object")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type ResponseFormatV2Visitor interface {
	VisitText(*ChatTextResponseFormatV2) error
	VisitJsonObject(*JsonResponseFormatV2) error
}

func (r *ResponseFormatV2) Accept(visitor ResponseFormatV2Visitor) error {
	if r.Text != nil {
		return visitor.VisitText(r.Text)
	}
	if r.JsonObject != nil {
		return visitor.VisitJsonObject(r.JsonObject)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *ResponseFormatV2) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Text != nil {
		fields = append(fields, "text")
	}
	if r.JsonObject != nil {
		fields = append(fields, "json_object")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

// A source object containing information about the source of the data cited.
type Source struct {
	Type     string
	Tool     *ChatToolSource
	Document *ChatDocumentSource
}

func (s *Source) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *Source) GetTool() *ChatToolSource {
	if s == nil {
		return nil
	}
	return s.Tool
}

func (s *Source) GetDocument() *ChatDocumentSource {
	if s == nil {
		return nil
	}
	return s.Document
}

func (s *Source) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "tool":
		value := new(ChatToolSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Tool = value
	case "document":
		value := new(ChatDocumentSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Document = value
	}
	return nil
}

func (s Source) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Tool != nil {
		return internal.MarshalJSONWithExtraProperty(s.Tool, "type", "tool")
	}
	if s.Document != nil {
		return internal.MarshalJSONWithExtraProperty(s.Document, "type", "document")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SourceVisitor interface {
	VisitTool(*ChatToolSource) error
	VisitDocument(*ChatDocumentSource) error
}

func (s *Source) Accept(visitor SourceVisitor) error {
	if s.Tool != nil {
		return visitor.VisitTool(s.Tool)
	}
	if s.Document != nil {
		return visitor.VisitDocument(s.Document)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *Source) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Tool != nil {
		fields = append(fields, "tool")
	}
	if s.Document != nil {
		fields = append(fields, "document")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

// A message from the system.
type SystemMessageV2 struct {
	Content *SystemMessageV2Content `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SystemMessageV2) GetContent() *SystemMessageV2Content {
	if s == nil {
		return nil
	}
	return s.Content
}

func (s *SystemMessageV2) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SystemMessageV2) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemMessageV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemMessageV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemMessageV2) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SystemMessageV2Content struct {
	String                         string
	SystemMessageV2ContentItemList []*SystemMessageV2ContentItem

	typ string
}

func (s *SystemMessageV2Content) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SystemMessageV2Content) GetSystemMessageV2ContentItemList() []*SystemMessageV2ContentItem {
	if s == nil {
		return nil
	}
	return s.SystemMessageV2ContentItemList
}

func (s *SystemMessageV2Content) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueSystemMessageV2ContentItemList []*SystemMessageV2ContentItem
	if err := json.Unmarshal(data, &valueSystemMessageV2ContentItemList); err == nil {
		s.typ = "SystemMessageV2ContentItemList"
		s.SystemMessageV2ContentItemList = valueSystemMessageV2ContentItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SystemMessageV2Content) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "SystemMessageV2ContentItemList" || s.SystemMessageV2ContentItemList != nil {
		return json.Marshal(s.SystemMessageV2ContentItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SystemMessageV2ContentVisitor interface {
	VisitString(string) error
	VisitSystemMessageV2ContentItemList([]*SystemMessageV2ContentItem) error
}

func (s *SystemMessageV2Content) Accept(visitor SystemMessageV2ContentVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "SystemMessageV2ContentItemList" || s.SystemMessageV2ContentItemList != nil {
		return visitor.VisitSystemMessageV2ContentItemList(s.SystemMessageV2ContentItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SystemMessageV2ContentItem struct {
	Type string
	Text *ChatTextContent
}

func (s *SystemMessageV2ContentItem) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SystemMessageV2ContentItem) GetText() *ChatTextContent {
	if s == nil {
		return nil
	}
	return s.Text
}

func (s *SystemMessageV2ContentItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Text = value
	}
	return nil
}

func (s SystemMessageV2ContentItem) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Text != nil {
		return internal.MarshalJSONWithExtraProperty(s.Text, "type", "text")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SystemMessageV2ContentItemVisitor interface {
	VisitText(*ChatTextContent) error
}

func (s *SystemMessageV2ContentItem) Accept(visitor SystemMessageV2ContentItemVisitor) error {
	if s.Text != nil {
		return visitor.VisitText(s.Text)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SystemMessageV2ContentItem) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Text != nil {
		fields = append(fields, "text")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

// Thinking gives the model enhanced reasoning capabilities for complex tasks, while also providing transparency into its step-by-step thought process before it delivers its final answer.
// When thinking is turned on, the model creates thinking content blocks where it outputs its internal reasoning. The model will incorporate insights from this reasoning before crafting a final response.
// When thinking is used without tools, the API response will include both thinking and text content blocks. Meanwhile, when thinking is used alongside tools and the model makes tool calls, the API response will include the thinking content block and `tool_calls`.
type Thinking struct {
	Type ThinkingType `json:"type" url:"type"`
	// The maximum number of tokens the model can use for thinking, which must be set to a positive integer.
	// The model will stop thinking if it reaches the thinking token budget and will proceed with the response.
	TokenBudget *int `json:"token_budget,omitempty" url:"token_budget,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Thinking) GetType() ThinkingType {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Thinking) GetTokenBudget() *int {
	if t == nil {
		return nil
	}
	return t.TokenBudget
}

func (t *Thinking) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Thinking) UnmarshalJSON(data []byte) error {
	type unmarshaler Thinking
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Thinking(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Thinking) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ThinkingType string

const (
	ThinkingTypeEnabled  ThinkingType = "enabled"
	ThinkingTypeDisabled ThinkingType = "disabled"
)

func NewThinkingTypeFromString(s string) (ThinkingType, error) {
	switch s {
	case "enabled":
		return ThinkingTypeEnabled, nil
	case "disabled":
		return ThinkingTypeDisabled, nil
	}
	var t ThinkingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t ThinkingType) Ptr() *ThinkingType {
	return &t
}

// An array of tool calls to be made.
type ToolCallV2 struct {
	Id       *string             `json:"id,omitempty" url:"id,omitempty"`
	Type     *string             `json:"type,omitempty" url:"type,omitempty"`
	Function *ToolCallV2Function `json:"function,omitempty" url:"function,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallV2) GetId() *string {
	if t == nil {
		return nil
	}
	return t.Id
}

func (t *ToolCallV2) GetFunction() *ToolCallV2Function {
	if t == nil {
		return nil
	}
	return t.Function
}

func (t *ToolCallV2) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallV2) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallV2) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolCallV2Function struct {
	Name      *string `json:"name,omitempty" url:"name,omitempty"`
	Arguments *string `json:"arguments,omitempty" url:"arguments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolCallV2Function) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *ToolCallV2Function) GetArguments() *string {
	if t == nil {
		return nil
	}
	return t.Arguments
}

func (t *ToolCallV2Function) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolCallV2Function) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCallV2Function
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCallV2Function(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCallV2Function) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// A content block which contains information about the content of a tool result
type ToolContent struct {
	Type     string
	Text     *ChatTextContent
	Document *DocumentContent
}

func (t *ToolContent) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *ToolContent) GetText() *ChatTextContent {
	if t == nil {
		return nil
	}
	return t.Text
}

func (t *ToolContent) GetDocument() *DocumentContent {
	if t == nil {
		return nil
	}
	return t.Document
}

func (t *ToolContent) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(ChatTextContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Text = value
	case "document":
		value := new(DocumentContent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Document = value
	}
	return nil
}

func (t ToolContent) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.Text != nil {
		return internal.MarshalJSONWithExtraProperty(t.Text, "type", "text")
	}
	if t.Document != nil {
		return internal.MarshalJSONWithExtraProperty(t.Document, "type", "document")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type ToolContentVisitor interface {
	VisitText(*ChatTextContent) error
	VisitDocument(*DocumentContent) error
}

func (t *ToolContent) Accept(visitor ToolContentVisitor) error {
	if t.Text != nil {
		return visitor.VisitText(t.Text)
	}
	if t.Document != nil {
		return visitor.VisitDocument(t.Document)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *ToolContent) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Text != nil {
		fields = append(fields, "text")
	}
	if t.Document != nil {
		fields = append(fields, "document")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

// A message with Tool outputs.
type ToolMessageV2 struct {
	// The id of the associated tool call that has provided the given content
	ToolCallId string `json:"tool_call_id" url:"tool_call_id"`
	// Outputs from a tool. The content should formatted as a JSON object string, or a list of tool content blocks
	Content *ToolMessageV2Content `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolMessageV2) GetToolCallId() string {
	if t == nil {
		return ""
	}
	return t.ToolCallId
}

func (t *ToolMessageV2) GetContent() *ToolMessageV2Content {
	if t == nil {
		return nil
	}
	return t.Content
}

func (t *ToolMessageV2) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolMessageV2) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolMessageV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolMessageV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolMessageV2) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Outputs from a tool. The content should formatted as a JSON object string, or a list of tool content blocks
type ToolMessageV2Content struct {
	String          string
	ToolContentList []*ToolContent

	typ string
}

func (t *ToolMessageV2Content) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *ToolMessageV2Content) GetToolContentList() []*ToolContent {
	if t == nil {
		return nil
	}
	return t.ToolContentList
}

func (t *ToolMessageV2Content) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	var valueToolContentList []*ToolContent
	if err := json.Unmarshal(data, &valueToolContentList); err == nil {
		t.typ = "ToolContentList"
		t.ToolContentList = valueToolContentList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t ToolMessageV2Content) MarshalJSON() ([]byte, error) {
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	if t.typ == "ToolContentList" || t.ToolContentList != nil {
		return json.Marshal(t.ToolContentList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolMessageV2ContentVisitor interface {
	VisitString(string) error
	VisitToolContentList([]*ToolContent) error
}

func (t *ToolMessageV2Content) Accept(visitor ToolMessageV2ContentVisitor) error {
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	if t.typ == "ToolContentList" || t.ToolContentList != nil {
		return visitor.VisitToolContentList(t.ToolContentList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type ToolV2 struct {
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The function to be executed.
	Function *ToolV2Function `json:"function,omitempty" url:"function,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolV2) GetFunction() *ToolV2Function {
	if t == nil {
		return nil
	}
	return t.Function
}

func (t *ToolV2) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolV2) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolV2) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The function to be executed.
type ToolV2Function struct {
	// The name of the function.
	Name string `json:"name" url:"name"`
	// The description of the function.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The parameters of the function as a JSON schema.
	Parameters map[string]interface{} `json:"parameters" url:"parameters"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ToolV2Function) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *ToolV2Function) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *ToolV2Function) GetParameters() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Parameters
}

func (t *ToolV2Function) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ToolV2Function) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolV2Function
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolV2Function(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolV2Function) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Usage struct {
	BilledUnits *UsageBilledUnits `json:"billed_units,omitempty" url:"billed_units,omitempty"`
	Tokens      *UsageTokens      `json:"tokens,omitempty" url:"tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *Usage) GetBilledUnits() *UsageBilledUnits {
	if u == nil {
		return nil
	}
	return u.BilledUnits
}

func (u *Usage) GetTokens() *UsageTokens {
	if u == nil {
		return nil
	}
	return u.Tokens
}

func (u *Usage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Usage) UnmarshalJSON(data []byte) error {
	type unmarshaler Usage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Usage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *Usage) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UsageBilledUnits struct {
	// The number of billed input tokens.
	InputTokens *float64 `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// The number of billed output tokens.
	OutputTokens *float64 `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`
	// The number of billed search units.
	SearchUnits *float64 `json:"search_units,omitempty" url:"search_units,omitempty"`
	// The number of billed classifications units.
	Classifications *float64 `json:"classifications,omitempty" url:"classifications,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UsageBilledUnits) GetInputTokens() *float64 {
	if u == nil {
		return nil
	}
	return u.InputTokens
}

func (u *UsageBilledUnits) GetOutputTokens() *float64 {
	if u == nil {
		return nil
	}
	return u.OutputTokens
}

func (u *UsageBilledUnits) GetSearchUnits() *float64 {
	if u == nil {
		return nil
	}
	return u.SearchUnits
}

func (u *UsageBilledUnits) GetClassifications() *float64 {
	if u == nil {
		return nil
	}
	return u.Classifications
}

func (u *UsageBilledUnits) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsageBilledUnits) UnmarshalJSON(data []byte) error {
	type unmarshaler UsageBilledUnits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsageBilledUnits(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsageBilledUnits) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UsageTokens struct {
	// The number of tokens used as input to the model.
	InputTokens *float64 `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// The number of tokens produced by the model.
	OutputTokens *float64 `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UsageTokens) GetInputTokens() *float64 {
	if u == nil {
		return nil
	}
	return u.InputTokens
}

func (u *UsageTokens) GetOutputTokens() *float64 {
	if u == nil {
		return nil
	}
	return u.OutputTokens
}

func (u *UsageTokens) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsageTokens) UnmarshalJSON(data []byte) error {
	type unmarshaler UsageTokens
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsageTokens(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsageTokens) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// A message from the user.
type UserMessageV2 struct {
	// The content of the message. This can be a string or a list of content blocks.
	// If a string is provided, it will be treated as a text content block.
	Content *UserMessageV2Content `json:"content" url:"content"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserMessageV2) GetContent() *UserMessageV2Content {
	if u == nil {
		return nil
	}
	return u.Content
}

func (u *UserMessageV2) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserMessageV2) UnmarshalJSON(data []byte) error {
	type unmarshaler UserMessageV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserMessageV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserMessageV2) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The content of the message. This can be a string or a list of content blocks.
// If a string is provided, it will be treated as a text content block.
type UserMessageV2Content struct {
	String      string
	ContentList []*Content

	typ string
}

func (u *UserMessageV2Content) GetString() string {
	if u == nil {
		return ""
	}
	return u.String
}

func (u *UserMessageV2Content) GetContentList() []*Content {
	if u == nil {
		return nil
	}
	return u.ContentList
}

func (u *UserMessageV2Content) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typ = "String"
		u.String = valueString
		return nil
	}
	var valueContentList []*Content
	if err := json.Unmarshal(data, &valueContentList); err == nil {
		u.typ = "ContentList"
		u.ContentList = valueContentList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UserMessageV2Content) MarshalJSON() ([]byte, error) {
	if u.typ == "String" || u.String != "" {
		return json.Marshal(u.String)
	}
	if u.typ == "ContentList" || u.ContentList != nil {
		return json.Marshal(u.ContentList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", u)
}

type UserMessageV2ContentVisitor interface {
	VisitString(string) error
	VisitContentList([]*Content) error
}

func (u *UserMessageV2Content) Accept(visitor UserMessageV2ContentVisitor) error {
	if u.typ == "String" || u.String != "" {
		return visitor.VisitString(u.String)
	}
	if u.typ == "ContentList" || u.ContentList != nil {
		return visitor.VisitContentList(u.ContentList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", u)
}

type V2ChatRequestDocumentsItem struct {
	String   string
	Document *Document

	typ string
}

func (v *V2ChatRequestDocumentsItem) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *V2ChatRequestDocumentsItem) GetDocument() *Document {
	if v == nil {
		return nil
	}
	return v.Document
}

func (v *V2ChatRequestDocumentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueDocument := new(Document)
	if err := json.Unmarshal(data, &valueDocument); err == nil {
		v.typ = "Document"
		v.Document = valueDocument
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v V2ChatRequestDocumentsItem) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Document" || v.Document != nil {
		return json.Marshal(v.Document)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type V2ChatRequestDocumentsItemVisitor interface {
	VisitString(string) error
	VisitDocument(*Document) error
}

func (v *V2ChatRequestDocumentsItem) Accept(visitor V2ChatRequestDocumentsItemVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Document" || v.Document != nil {
		return visitor.VisitDocument(v.Document)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// Used to select the [safety instruction](https://docs.cohere.com/v2/docs/safety-modes) inserted into the prompt. Defaults to `CONTEXTUAL`.
// When `OFF` is specified, the safety instruction will be omitted.
//
// Safety modes are not yet configurable in combination with `tools` and `documents` parameters.
//
// **Note**: This parameter is only compatible newer Cohere models, starting with [Command R 08-2024](https://docs.cohere.com/docs/command-r#august-2024-release) and [Command R+ 08-2024](https://docs.cohere.com/docs/command-r-plus#august-2024-release).
//
// **Note**: `command-r7b-12-2024` and newer models only support `"CONTEXTUAL"` and `"STRICT"` modes.
type V2ChatRequestSafetyMode string

const (
	V2ChatRequestSafetyModeContextual V2ChatRequestSafetyMode = "CONTEXTUAL"
	V2ChatRequestSafetyModeStrict     V2ChatRequestSafetyMode = "STRICT"
	V2ChatRequestSafetyModeOff        V2ChatRequestSafetyMode = "OFF"
)

func NewV2ChatRequestSafetyModeFromString(s string) (V2ChatRequestSafetyMode, error) {
	switch s {
	case "CONTEXTUAL":
		return V2ChatRequestSafetyModeContextual, nil
	case "STRICT":
		return V2ChatRequestSafetyModeStrict, nil
	case "OFF":
		return V2ChatRequestSafetyModeOff, nil
	}
	var t V2ChatRequestSafetyMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ChatRequestSafetyMode) Ptr() *V2ChatRequestSafetyMode {
	return &v
}

// Used to control whether or not the model will be forced to use a tool when answering. When `REQUIRED` is specified, the model will be forced to use at least one of the user-defined tools, and the `tools` parameter must be passed in the request.
// When `NONE` is specified, the model will be forced **not** to use one of the specified tools, and give a direct response.
// If tool_choice isn't specified, then the model is free to choose whether to use the specified tools or not.
//
// **Note**: This parameter is only compatible with models [Command-r7b](https://docs.cohere.com/v2/docs/command-r7b) and newer.
//
// **Note**: The same functionality can be achieved in `/v1/chat` using the `force_single_step` parameter. If `force_single_step=true`, this is equivalent to specifying `REQUIRED`. While if `force_single_step=true` and `tool_results` are passed, this is equivalent to specifying `NONE`.
type V2ChatRequestToolChoice string

const (
	V2ChatRequestToolChoiceRequired V2ChatRequestToolChoice = "REQUIRED"
	V2ChatRequestToolChoiceNone     V2ChatRequestToolChoice = "NONE"
)

func NewV2ChatRequestToolChoiceFromString(s string) (V2ChatRequestToolChoice, error) {
	switch s {
	case "REQUIRED":
		return V2ChatRequestToolChoiceRequired, nil
	case "NONE":
		return V2ChatRequestToolChoiceNone, nil
	}
	var t V2ChatRequestToolChoice
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ChatRequestToolChoice) Ptr() *V2ChatRequestToolChoice {
	return &v
}

type V2ChatResponse struct {
	// Unique identifier for the generated reply. Useful for submitting feedback.
	Id           string                    `json:"id" url:"id"`
	FinishReason ChatFinishReason          `json:"finish_reason" url:"finish_reason"`
	Message      *AssistantMessageResponse `json:"message" url:"message"`
	Usage        *Usage                    `json:"usage,omitempty" url:"usage,omitempty"`
	Logprobs     []*LogprobItem            `json:"logprobs,omitempty" url:"logprobs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V2ChatResponse) GetId() string {
	if v == nil {
		return ""
	}
	return v.Id
}

func (v *V2ChatResponse) GetFinishReason() ChatFinishReason {
	if v == nil {
		return ""
	}
	return v.FinishReason
}

func (v *V2ChatResponse) GetMessage() *AssistantMessageResponse {
	if v == nil {
		return nil
	}
	return v.Message
}

func (v *V2ChatResponse) GetUsage() *Usage {
	if v == nil {
		return nil
	}
	return v.Usage
}

func (v *V2ChatResponse) GetLogprobs() []*LogprobItem {
	if v == nil {
		return nil
	}
	return v.Logprobs
}

func (v *V2ChatResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V2ChatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V2ChatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V2ChatResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V2ChatResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V2ChatStreamRequestDocumentsItem struct {
	String   string
	Document *Document

	typ string
}

func (v *V2ChatStreamRequestDocumentsItem) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *V2ChatStreamRequestDocumentsItem) GetDocument() *Document {
	if v == nil {
		return nil
	}
	return v.Document
}

func (v *V2ChatStreamRequestDocumentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	valueDocument := new(Document)
	if err := json.Unmarshal(data, &valueDocument); err == nil {
		v.typ = "Document"
		v.Document = valueDocument
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v V2ChatStreamRequestDocumentsItem) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Document" || v.Document != nil {
		return json.Marshal(v.Document)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type V2ChatStreamRequestDocumentsItemVisitor interface {
	VisitString(string) error
	VisitDocument(*Document) error
}

func (v *V2ChatStreamRequestDocumentsItem) Accept(visitor V2ChatStreamRequestDocumentsItemVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Document" || v.Document != nil {
		return visitor.VisitDocument(v.Document)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}

// Used to select the [safety instruction](https://docs.cohere.com/v2/docs/safety-modes) inserted into the prompt. Defaults to `CONTEXTUAL`.
// When `OFF` is specified, the safety instruction will be omitted.
//
// Safety modes are not yet configurable in combination with `tools` and `documents` parameters.
//
// **Note**: This parameter is only compatible newer Cohere models, starting with [Command R 08-2024](https://docs.cohere.com/docs/command-r#august-2024-release) and [Command R+ 08-2024](https://docs.cohere.com/docs/command-r-plus#august-2024-release).
//
// **Note**: `command-r7b-12-2024` and newer models only support `"CONTEXTUAL"` and `"STRICT"` modes.
type V2ChatStreamRequestSafetyMode string

const (
	V2ChatStreamRequestSafetyModeContextual V2ChatStreamRequestSafetyMode = "CONTEXTUAL"
	V2ChatStreamRequestSafetyModeStrict     V2ChatStreamRequestSafetyMode = "STRICT"
	V2ChatStreamRequestSafetyModeOff        V2ChatStreamRequestSafetyMode = "OFF"
)

func NewV2ChatStreamRequestSafetyModeFromString(s string) (V2ChatStreamRequestSafetyMode, error) {
	switch s {
	case "CONTEXTUAL":
		return V2ChatStreamRequestSafetyModeContextual, nil
	case "STRICT":
		return V2ChatStreamRequestSafetyModeStrict, nil
	case "OFF":
		return V2ChatStreamRequestSafetyModeOff, nil
	}
	var t V2ChatStreamRequestSafetyMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ChatStreamRequestSafetyMode) Ptr() *V2ChatStreamRequestSafetyMode {
	return &v
}

// Used to control whether or not the model will be forced to use a tool when answering. When `REQUIRED` is specified, the model will be forced to use at least one of the user-defined tools, and the `tools` parameter must be passed in the request.
// When `NONE` is specified, the model will be forced **not** to use one of the specified tools, and give a direct response.
// If tool_choice isn't specified, then the model is free to choose whether to use the specified tools or not.
//
// **Note**: This parameter is only compatible with models [Command-r7b](https://docs.cohere.com/v2/docs/command-r7b) and newer.
//
// **Note**: The same functionality can be achieved in `/v1/chat` using the `force_single_step` parameter. If `force_single_step=true`, this is equivalent to specifying `REQUIRED`. While if `force_single_step=true` and `tool_results` are passed, this is equivalent to specifying `NONE`.
type V2ChatStreamRequestToolChoice string

const (
	V2ChatStreamRequestToolChoiceRequired V2ChatStreamRequestToolChoice = "REQUIRED"
	V2ChatStreamRequestToolChoiceNone     V2ChatStreamRequestToolChoice = "NONE"
)

func NewV2ChatStreamRequestToolChoiceFromString(s string) (V2ChatStreamRequestToolChoice, error) {
	switch s {
	case "REQUIRED":
		return V2ChatStreamRequestToolChoiceRequired, nil
	case "NONE":
		return V2ChatStreamRequestToolChoiceNone, nil
	}
	var t V2ChatStreamRequestToolChoice
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ChatStreamRequestToolChoice) Ptr() *V2ChatStreamRequestToolChoice {
	return &v
}

// StreamedChatResponse is returned in streaming mode (specified with `stream=True` in the request).
type V2ChatStreamResponse struct {
	Type          string
	MessageStart  *ChatMessageStartEvent
	ContentStart  *ChatContentStartEvent
	ContentDelta  *ChatContentDeltaEvent
	ContentEnd    *ChatContentEndEvent
	ToolPlanDelta *ChatToolPlanDeltaEvent
	ToolCallStart *ChatToolCallStartEvent
	ToolCallDelta *ChatToolCallDeltaEvent
	ToolCallEnd   *ChatToolCallEndEvent
	CitationStart *CitationStartEvent
	CitationEnd   *CitationEndEvent
	MessageEnd    *ChatMessageEndEvent
	Debug         *ChatDebugEvent
}

func (v *V2ChatStreamResponse) GetType() string {
	if v == nil {
		return ""
	}
	return v.Type
}

func (v *V2ChatStreamResponse) GetMessageStart() *ChatMessageStartEvent {
	if v == nil {
		return nil
	}
	return v.MessageStart
}

func (v *V2ChatStreamResponse) GetContentStart() *ChatContentStartEvent {
	if v == nil {
		return nil
	}
	return v.ContentStart
}

func (v *V2ChatStreamResponse) GetContentDelta() *ChatContentDeltaEvent {
	if v == nil {
		return nil
	}
	return v.ContentDelta
}

func (v *V2ChatStreamResponse) GetContentEnd() *ChatContentEndEvent {
	if v == nil {
		return nil
	}
	return v.ContentEnd
}

func (v *V2ChatStreamResponse) GetToolPlanDelta() *ChatToolPlanDeltaEvent {
	if v == nil {
		return nil
	}
	return v.ToolPlanDelta
}

func (v *V2ChatStreamResponse) GetToolCallStart() *ChatToolCallStartEvent {
	if v == nil {
		return nil
	}
	return v.ToolCallStart
}

func (v *V2ChatStreamResponse) GetToolCallDelta() *ChatToolCallDeltaEvent {
	if v == nil {
		return nil
	}
	return v.ToolCallDelta
}

func (v *V2ChatStreamResponse) GetToolCallEnd() *ChatToolCallEndEvent {
	if v == nil {
		return nil
	}
	return v.ToolCallEnd
}

func (v *V2ChatStreamResponse) GetCitationStart() *CitationStartEvent {
	if v == nil {
		return nil
	}
	return v.CitationStart
}

func (v *V2ChatStreamResponse) GetCitationEnd() *CitationEndEvent {
	if v == nil {
		return nil
	}
	return v.CitationEnd
}

func (v *V2ChatStreamResponse) GetMessageEnd() *ChatMessageEndEvent {
	if v == nil {
		return nil
	}
	return v.MessageEnd
}

func (v *V2ChatStreamResponse) GetDebug() *ChatDebugEvent {
	if v == nil {
		return nil
	}
	return v.Debug
}

func (v *V2ChatStreamResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	v.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", v)
	}
	switch unmarshaler.Type {
	case "message-start":
		value := new(ChatMessageStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.MessageStart = value
	case "content-start":
		value := new(ChatContentStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ContentStart = value
	case "content-delta":
		value := new(ChatContentDeltaEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ContentDelta = value
	case "content-end":
		value := new(ChatContentEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ContentEnd = value
	case "tool-plan-delta":
		value := new(ChatToolPlanDeltaEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ToolPlanDelta = value
	case "tool-call-start":
		value := new(ChatToolCallStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ToolCallStart = value
	case "tool-call-delta":
		value := new(ChatToolCallDeltaEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ToolCallDelta = value
	case "tool-call-end":
		value := new(ChatToolCallEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ToolCallEnd = value
	case "citation-start":
		value := new(CitationStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.CitationStart = value
	case "citation-end":
		value := new(CitationEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.CitationEnd = value
	case "message-end":
		value := new(ChatMessageEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.MessageEnd = value
	case "debug":
		value := new(ChatDebugEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Debug = value
	}
	return nil
}

func (v V2ChatStreamResponse) MarshalJSON() ([]byte, error) {
	if err := v.validate(); err != nil {
		return nil, err
	}
	if v.MessageStart != nil {
		return internal.MarshalJSONWithExtraProperty(v.MessageStart, "type", "message-start")
	}
	if v.ContentStart != nil {
		return internal.MarshalJSONWithExtraProperty(v.ContentStart, "type", "content-start")
	}
	if v.ContentDelta != nil {
		return internal.MarshalJSONWithExtraProperty(v.ContentDelta, "type", "content-delta")
	}
	if v.ContentEnd != nil {
		return internal.MarshalJSONWithExtraProperty(v.ContentEnd, "type", "content-end")
	}
	if v.ToolPlanDelta != nil {
		return internal.MarshalJSONWithExtraProperty(v.ToolPlanDelta, "type", "tool-plan-delta")
	}
	if v.ToolCallStart != nil {
		return internal.MarshalJSONWithExtraProperty(v.ToolCallStart, "type", "tool-call-start")
	}
	if v.ToolCallDelta != nil {
		return internal.MarshalJSONWithExtraProperty(v.ToolCallDelta, "type", "tool-call-delta")
	}
	if v.ToolCallEnd != nil {
		return internal.MarshalJSONWithExtraProperty(v.ToolCallEnd, "type", "tool-call-end")
	}
	if v.CitationStart != nil {
		return internal.MarshalJSONWithExtraProperty(v.CitationStart, "type", "citation-start")
	}
	if v.CitationEnd != nil {
		return internal.MarshalJSONWithExtraProperty(v.CitationEnd, "type", "citation-end")
	}
	if v.MessageEnd != nil {
		return internal.MarshalJSONWithExtraProperty(v.MessageEnd, "type", "message-end")
	}
	if v.Debug != nil {
		return internal.MarshalJSONWithExtraProperty(v.Debug, "type", "debug")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", v)
}

type V2ChatStreamResponseVisitor interface {
	VisitMessageStart(*ChatMessageStartEvent) error
	VisitContentStart(*ChatContentStartEvent) error
	VisitContentDelta(*ChatContentDeltaEvent) error
	VisitContentEnd(*ChatContentEndEvent) error
	VisitToolPlanDelta(*ChatToolPlanDeltaEvent) error
	VisitToolCallStart(*ChatToolCallStartEvent) error
	VisitToolCallDelta(*ChatToolCallDeltaEvent) error
	VisitToolCallEnd(*ChatToolCallEndEvent) error
	VisitCitationStart(*CitationStartEvent) error
	VisitCitationEnd(*CitationEndEvent) error
	VisitMessageEnd(*ChatMessageEndEvent) error
	VisitDebug(*ChatDebugEvent) error
}

func (v *V2ChatStreamResponse) Accept(visitor V2ChatStreamResponseVisitor) error {
	if v.MessageStart != nil {
		return visitor.VisitMessageStart(v.MessageStart)
	}
	if v.ContentStart != nil {
		return visitor.VisitContentStart(v.ContentStart)
	}
	if v.ContentDelta != nil {
		return visitor.VisitContentDelta(v.ContentDelta)
	}
	if v.ContentEnd != nil {
		return visitor.VisitContentEnd(v.ContentEnd)
	}
	if v.ToolPlanDelta != nil {
		return visitor.VisitToolPlanDelta(v.ToolPlanDelta)
	}
	if v.ToolCallStart != nil {
		return visitor.VisitToolCallStart(v.ToolCallStart)
	}
	if v.ToolCallDelta != nil {
		return visitor.VisitToolCallDelta(v.ToolCallDelta)
	}
	if v.ToolCallEnd != nil {
		return visitor.VisitToolCallEnd(v.ToolCallEnd)
	}
	if v.CitationStart != nil {
		return visitor.VisitCitationStart(v.CitationStart)
	}
	if v.CitationEnd != nil {
		return visitor.VisitCitationEnd(v.CitationEnd)
	}
	if v.MessageEnd != nil {
		return visitor.VisitMessageEnd(v.MessageEnd)
	}
	if v.Debug != nil {
		return visitor.VisitDebug(v.Debug)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", v)
}

func (v *V2ChatStreamResponse) validate() error {
	if v == nil {
		return fmt.Errorf("type %T is nil", v)
	}
	var fields []string
	if v.MessageStart != nil {
		fields = append(fields, "message-start")
	}
	if v.ContentStart != nil {
		fields = append(fields, "content-start")
	}
	if v.ContentDelta != nil {
		fields = append(fields, "content-delta")
	}
	if v.ContentEnd != nil {
		fields = append(fields, "content-end")
	}
	if v.ToolPlanDelta != nil {
		fields = append(fields, "tool-plan-delta")
	}
	if v.ToolCallStart != nil {
		fields = append(fields, "tool-call-start")
	}
	if v.ToolCallDelta != nil {
		fields = append(fields, "tool-call-delta")
	}
	if v.ToolCallEnd != nil {
		fields = append(fields, "tool-call-end")
	}
	if v.CitationStart != nil {
		fields = append(fields, "citation-start")
	}
	if v.CitationEnd != nil {
		fields = append(fields, "citation-end")
	}
	if v.MessageEnd != nil {
		fields = append(fields, "message-end")
	}
	if v.Debug != nil {
		fields = append(fields, "debug")
	}
	if len(fields) == 0 {
		if v.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", v, v.Type)
		}
		return fmt.Errorf("type %T is empty", v)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", v, fields)
	}
	if v.Type != "" {
		field := fields[0]
		if v.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				v,
				v.Type,
				v,
			)
		}
	}
	return nil
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type V2EmbedRequestTruncate string

const (
	V2EmbedRequestTruncateNone  V2EmbedRequestTruncate = "NONE"
	V2EmbedRequestTruncateStart V2EmbedRequestTruncate = "START"
	V2EmbedRequestTruncateEnd   V2EmbedRequestTruncate = "END"
)

func NewV2EmbedRequestTruncateFromString(s string) (V2EmbedRequestTruncate, error) {
	switch s {
	case "NONE":
		return V2EmbedRequestTruncateNone, nil
	case "START":
		return V2EmbedRequestTruncateStart, nil
	case "END":
		return V2EmbedRequestTruncateEnd, nil
	}
	var t V2EmbedRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2EmbedRequestTruncate) Ptr() *V2EmbedRequestTruncate {
	return &v
}

type V2RerankResponse struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An ordered list of ranked documents
	Results []*V2RerankResponseResultsItem `json:"results" url:"results"`
	Meta    *ApiMeta                       `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V2RerankResponse) GetId() *string {
	if v == nil {
		return nil
	}
	return v.Id
}

func (v *V2RerankResponse) GetResults() []*V2RerankResponseResultsItem {
	if v == nil {
		return nil
	}
	return v.Results
}

func (v *V2RerankResponse) GetMeta() *ApiMeta {
	if v == nil {
		return nil
	}
	return v.Meta
}

func (v *V2RerankResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V2RerankResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V2RerankResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V2RerankResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V2RerankResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V2RerankResponseResultsItem struct {
	// Corresponds to the index in the original list of documents to which the ranked document belongs. (i.e. if the first value in the `results` object has an `index` value of 3, it means in the list of documents passed in, the document at `index=3` had the highest relevance)
	Index int `json:"index" url:"index"`
	// Relevance scores are normalized to be in the range `[0, 1]`. Scores close to `1` indicate a high relevance to the query, and scores closer to `0` indicate low relevance. It is not accurate to assume a score of 0.9 means the document is 2x more relevant than a document with a score of 0.45
	RelevanceScore float64 `json:"relevance_score" url:"relevance_score"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *V2RerankResponseResultsItem) GetIndex() int {
	if v == nil {
		return 0
	}
	return v.Index
}

func (v *V2RerankResponseResultsItem) GetRelevanceScore() float64 {
	if v == nil {
		return 0
	}
	return v.RelevanceScore
}

func (v *V2RerankResponseResultsItem) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V2RerankResponseResultsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler V2RerankResponseResultsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V2RerankResponseResultsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *V2RerankResponseResultsItem) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
